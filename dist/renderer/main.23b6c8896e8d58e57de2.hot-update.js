"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    // Define constants first\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 20; // Smaller width for weekday labels\n    // Debug function to log grid information\n    const debugGridInfo = (0, react_1.useCallback)((grid) => {\n        const totalWeeks = grid.length;\n        const daysInFullYear = new Date(selectedYear, 0, 0).getDate() === 366 ? 366 : 365;\n        const daysInCurrentYear = grid.flat().filter(date => date && date.getFullYear() === selectedYear).length;\n        const jan1 = grid.flat().find(date => date && date.getFullYear() === selectedYear && date.getMonth() === 0 && date.getDate() === 1);\n        const dec31 = grid.flat().find(date => date && date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        console.log(`Grid for ${selectedYear}: ${totalWeeks} weeks Ã— 7 days`);\n        console.log(`Days in year: ${daysInFullYear}, days displayed from year: ${daysInCurrentYear}`);\n        console.log(`Jan 1 present: ${!!jan1}, Dec 31 present: ${!!dec31}`);\n        return {\n            size: totalWeeks,\n            daysInYear: daysInCurrentYear,\n            hasJan1: !!jan1,\n            hasDec31: !!dec31\n        };\n    }, [selectedYear]);\n    // Build a GitHub-style heatmap grid for the selected year\n    const daysOfYear = (0, react_1.useMemo)(() => {\n        const yearStart = new Date(selectedYear, 0, 1); // January 1st\n        const yearEnd = new Date(selectedYear, 11, 31); // December 31st\n        return (0, date_fns_1.eachDayOfInterval)({ start: yearStart, end: yearEnd });\n    }, [selectedYear]);\n    // First day of year adjusted to start on the correct first Sunday\n    const firstDayOfYear = (0, react_1.useMemo)(() => {\n        const jan1 = new Date(selectedYear, 0, 1);\n        // Go back to the previous Sunday (or stay on Sunday if it already is one)\n        const dayOfWeek = (0, date_fns_1.getDay)(jan1);\n        return (0, date_fns_1.addDays)(jan1, -dayOfWeek);\n    }, [selectedYear]);\n    // Calculate the number of weeks in the year correctly\n    const numWeeks = (0, react_1.useMemo)(() => {\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // First week starts with the first Sunday on or before Jan 1\n        const startDay = (0, date_fns_1.getDay)(jan1); // 0=Sunday, 6=Saturday\n        const firstSunday = (0, date_fns_1.addDays)(jan1, -startDay);\n        // Last week includes the last day of the year\n        const endDay = (0, date_fns_1.getDay)(dec31);\n        const lastSaturday = (0, date_fns_1.addDays)(dec31, 6 - endDay);\n        // Calculate weeks between first Sunday and last Saturday\n        return (0, date_fns_1.differenceInCalendarWeeks)(lastSaturday, firstSunday, { weekStartsOn: 0 }) + 1;\n    }, [selectedYear]);\n    const numRows = 7; // Sun-Sat\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        // Get the start and end dates for the year\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // Find the first Sunday before or on Jan 1\n        const firstDayOfGrid = new Date(jan1);\n        const firstDayOfWeek = (0, date_fns_1.getDay)(firstDayOfGrid);\n        firstDayOfGrid.setDate(firstDayOfGrid.getDate() - firstDayOfWeek);\n        // Find the last Saturday after or on Dec 31\n        const lastDayOfGrid = new Date(dec31);\n        const lastDayOfWeek = (0, date_fns_1.getDay)(lastDayOfGrid);\n        lastDayOfGrid.setDate(lastDayOfGrid.getDate() + (6 - lastDayOfWeek));\n        // Calculate the total number of weeks\n        // Add 1 because differenceInCalendarWeeks is exclusive of end date\n        const totalWeeks = Math.ceil((lastDayOfGrid.getTime() - firstDayOfGrid.getTime()) / (7 * 24 * 60 * 60 * 1000));\n        // Create the grid with the correct number of weeks\n        const newGrid = [];\n        // Start with the first day of the grid\n        let currentDate = new Date(firstDayOfGrid);\n        // Generate all weeks\n        for (let week = 0; week < totalWeeks; week++) {\n            const weekRow = [];\n            // Generate days for each week\n            for (let day = 0; day < 7; day++) {\n                weekRow.push(new Date(currentDate));\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            newGrid.push(weekRow);\n        }\n        // Count days in the current year for debugging\n        const daysInYear = newGrid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        // Log debug info\n        console.log(`Calendar grid for ${selectedYear}: ${totalWeeks} weeks (${newGrid.length}x7), ${daysInYear} days in year`);\n        return newGrid;\n    }, [selectedYear]);\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Calculate the smallest possible cell size that fits all weeks without scroll\n        const availableWidth = Math.min(window.innerWidth - 80, 1200);\n        const weekdayLabelSpace = WEEKDAY_LABEL_WIDTH + 4;\n        // We need to fit a full year (52-53 weeks)\n        const totalWeeks = grid.length; // This is now calculated correctly in the grid logic\n        // Calculate size to fill available width without scrolling\n        const cellSizeWithGap = (availableWidth - weekdayLabelSpace) / totalWeeks;\n        const cellSize = Math.floor(cellSizeWithGap - CELL_GAP);\n        // Ensure minimum size but allow smaller cells to fit all\n        return Math.max(cellSize, 8);\n    }, [grid]);\n    // Calculate cell size once on component mount\n    const CELL_SIZE = (0, react_1.useMemo)(() => {\n        // Calculate a proper cell size based on grid width\n        const result = calculateCellSize();\n        // Debug grid information\n        debugGridInfo(grid);\n        return result;\n    }, [calculateCellSize, grid, debugGridInfo]);\n    // Generate month labels based on actual cell dates\n    const monthLabels = (0, react_1.useMemo)(() => {\n        const labels = [];\n        // Find the first column (week) of each month in the grid\n        for (let month = 0; month < 12; month++) {\n            // First day of the month\n            const firstDayOfMonth = new Date(selectedYear, month, 1);\n            let foundColumn = -1;\n            // Find which column (week) contains the first day of this month\n            for (let colIdx = 0; colIdx < grid.length; colIdx++) {\n                for (let rowIdx = 0; rowIdx < 7; rowIdx++) {\n                    const day = grid[colIdx][rowIdx];\n                    // Check if this cell contains the first day of this month\n                    if (day &&\n                        day.getDate() === 1 &&\n                        (0, date_fns_1.getMonth)(day) === month &&\n                        (0, date_fns_1.getYear)(day) === selectedYear) {\n                        foundColumn = colIdx;\n                        break;\n                    }\n                }\n                if (foundColumn !== -1)\n                    break;\n            }\n            // If we found the first day of this month in the grid\n            if (foundColumn !== -1) {\n                labels.push({\n                    col: foundColumn,\n                    month: (0, date_fns_1.format)(firstDayOfMonth, 'MMM')\n                });\n            }\n        }\n        return labels;\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        // For habits that track quantity, use the quantity value\n        if (habit.trackQuantity) {\n            if (quantity !== '') {\n                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n            }\n        }\n        else {\n            // For non-quantity habits, always mark as completed\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [habit.trackQuantity, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2,\n            pb: 1,\n            mb: 2,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 2px 8px rgba(0,0,0,0.3)'\n                : '0 2px 8px rgba(0,0,0,0.05)',\n            width: '100%',\n            maxWidth: '100%',\n            overflowX: 'hidden'\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { width: '100%', mx: 'auto', mb: 0 }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0,\n                            mb: 1,\n                            width: '100%',\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.01em',\n                            textShadow: mode === 'dark'\n                                ? '0 1px 2px rgba(0,0,0,0.3)'\n                                : '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.2rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.5,\n                            position: 'relative',\n                            '&::after': {\n                                content: '\"\"',\n                                position: 'absolute',\n                                bottom: '-2px',\n                                left: 0,\n                                width: '100%',\n                                borderBottom: `2px solid ${habit.color}33`,\n                            }\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            display: 'flex',\n                            justifyContent: 'space-between',\n                            alignItems: 'center',\n                            mb: 0.5,\n                            px: 0.5\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary', p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: {\n                                                mx: 0.5,\n                                                fontWeight: 'bold',\n                                                color: 'text.primary',\n                                                fontSize: '0.8rem'\n                                            }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary', p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.5 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: {\n                                                display: 'flex',\n                                                alignItems: 'center',\n                                                fontSize: '0.8rem'\n                                            }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '2px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, { fontSize: \"small\" }), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.4,\n                                            px: 1,\n                                            minWidth: '50px',\n                                            fontSize: '0.75rem',\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), sx: { p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, { fontSize: \"small\" }) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            width: '100%',\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'flex-start',\n                            overflow: 'hidden',\n                            maxWidth: '100%'\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                    display: 'flex',\n                                    alignItems: 'center',\n                                    mb: 0.5,\n                                    ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                    width: `calc(${grid.length * (CELL_SIZE + CELL_GAP)}px)`,\n                                    justifyContent: 'flex-start',\n                                    position: 'relative',\n                                    height: '16px',\n                                    overflow: 'visible'\n                                }, children: monthLabels.map((label, idx) => {\n                                    // Calculate position to center it precisely above the first cell of the month\n                                    const position = label.col * (CELL_SIZE + CELL_GAP) + (CELL_SIZE / 2);\n                                    return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            position: 'absolute',\n                                            left: `${position}px`,\n                                            transform: 'translateX(-50%)', // Center the label on the cell\n                                            textAlign: 'center',\n                                            zIndex: 2 // Ensure labels don't get overlapped\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", noWrap: true, sx: {\n                                                fontSize: '0.65rem',\n                                                color: 'text.secondary',\n                                                fontWeight: 'bold',\n                                                lineHeight: 1,\n                                                display: 'inline-block',\n                                                whiteSpace: 'nowrap',\n                                                padding: '0 2px'\n                                            }, children: label.month }) }, idx));\n                                }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    display: 'grid',\n                                    gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${grid.length}, ${CELL_SIZE}px)`,\n                                    gap: CELL_GAP,\n                                    mb: 0,\n                                    width: `calc(${WEEKDAY_LABEL_WIDTH}px + ${grid.length * (CELL_SIZE + CELL_GAP)}px - ${CELL_GAP}px)`,\n                                    maxWidth: '100%',\n                                    overflowX: 'hidden',\n                                    overflowY: 'hidden',\n                                    justifyContent: 'flex-start',\n                                    paddingBottom: '2px' // Add a small padding to avoid cut-off\n                                }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            gridColumn: 1,\n                                            gridRow: weekday + 1,\n                                            justifySelf: 'end',\n                                            pr: 0.3,\n                                            width: WEEKDAY_LABEL_WIDTH - 2,\n                                            bgcolor: mode === 'dark' ? 'background.paper' : 'background.paper'\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                fontSize: '0.6rem',\n                                                color: 'text.secondary',\n                                                lineHeight: 1\n                                            }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), grid.map((weekColumn, colIdx) => (weekColumn.map((day, rowIdx) => {\n                                        // Get the date for this cell position from our grid\n                                        const cellDate = day;\n                                        // Empty cell or cell outside current year\n                                        if (!cellDate) {\n                                            return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    gridColumn: colIdx + 2,\n                                                    gridRow: rowIdx + 1,\n                                                    width: CELL_SIZE,\n                                                    height: CELL_SIZE,\n                                                    border: `1px solid ${mode === 'dark' ? '#333' : '#f0f0f0'}`,\n                                                    borderRadius: '2px',\n                                                    opacity: 0.2\n                                                } }, `empty-${colIdx}-${rowIdx}`));\n                                        }\n                                        // Check if this cell's date is in the current year\n                                        const isInCurrentYear = cellDate.getFullYear() === selectedYear;\n                                        // Calculate month and determine boundaries\n                                        const month = (0, date_fns_1.getMonth)(cellDate);\n                                        // Check if this is the first day of a month\n                                        const isFirstDayOfMonth = cellDate.getDate() === 1;\n                                        // Determine month boundaries - last day of the month\n                                        const isLastDayOfMonth = (() => {\n                                            const nextDay = new Date(cellDate);\n                                            nextDay.setDate(cellDate.getDate() + 1);\n                                            return (0, date_fns_1.getMonth)(nextDay) !== (0, date_fns_1.getMonth)(cellDate);\n                                        })();\n                                        const isCompleted = isDayCompleted(cellDate);\n                                        const isFuture = (0, date_fns_1.isAfter)(cellDate, new Date());\n                                        const isCurrentDay = (0, date_fns_1.isToday)(cellDate);\n                                        // Month boundary color\n                                        const monthBorderColor = mode === 'dark'\n                                            ? (isInCurrentYear ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.2)')\n                                            : (isInCurrentYear ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.2)');\n                                        return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                gridColumn: colIdx + 2,\n                                                gridRow: rowIdx + 1,\n                                                width: CELL_SIZE,\n                                                height: CELL_SIZE,\n                                                bgcolor: isCompleted\n                                                    ? habit.color + (mode === 'dark' ? 'aa' : '99')\n                                                    : mode === 'dark'\n                                                        ? (isInCurrentYear ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)')\n                                                        : (isInCurrentYear ? 'transparent' : 'rgba(0,0,0,0.02)'),\n                                                border: isCurrentDay\n                                                    ? `1px solid ${habit.color}`\n                                                    : `1px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`,\n                                                // Add month boundary styling (only for dates in current year)\n                                                ...(isInCurrentYear && {\n                                                    borderLeft: isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                    borderRight: isLastDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                    borderTop: rowIdx === 0 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                    borderBottom: rowIdx === 6 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                }),\n                                                borderRadius: '1px',\n                                                cursor: (isFuture || !isInCurrentYear) ? 'default' : 'pointer',\n                                                opacity: isFuture ? 0.3 : (isInCurrentYear ? 1 : 0.3),\n                                                transition: 'background-color 0.2s',\n                                                '&:hover': isInCurrentYear && !isFuture ? {\n                                                    bgcolor: isCompleted\n                                                        ? habit.color + 'cc'\n                                                        : mode === 'dark' ? 'rgba(255,255,255,0.1)' : '#f5f5f5',\n                                                } : {},\n                                            }, onClick: () => isInCurrentYear && !isFuture && handleDayClick(cellDate) }, cellDate.toString()));\n                                    })))] })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                            color: '#fff',\n                        }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), !habit.trackQuantity ? ((0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                            color: habit.color,\n                                            '&.Mui-checked': {\n                                                color: habit.color,\n                                            }\n                                        } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) })) : (\n                                // For habits that track quantity, always show the quantity field\n                                (0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: {\n                                        mt: 1,\n                                        '& .MuiOutlinedInput-root': {\n                                            '&.Mui-focused fieldset': {\n                                                borderColor: habit.color,\n                                            },\n                                        },\n                                        '& .MuiInputLabel-root.Mui-focused': {\n                                            color: habit.color,\n                                        },\n                                    }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: habit.trackQuantity && quantity === '', sx: {\n                                    borderRadius: '20px',\n                                    px: 2,\n                                    background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                    boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                            color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                        }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxvQ0FBb0MsNkRBQTZELDBIQUEwSCxHQUFHLHVEQUF1RCxNQUFNLDJGQUEyRix5REFBeUQsbURBQW1ELDZCQUE2QixzQkFBc0IsK0NBQStDO0FBQ3JyQjtBQUNBO0FBQ0EsaUNBQWlDLDhDQUE4Qyw2QkFBNkIsc0JBQXNCLElBQUksSUFBSSxJQUFJO0FBQzlJO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2NlbnQvLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy9IYWJpdENhcmQudHN4PzQzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWxcIik7XG5jb25zdCBpY29uc19tYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvaWNvbnMtbWF0ZXJpYWxcIik7XG5jb25zdCBkYXRlX2Zuc18xID0gcmVxdWlyZShcImRhdGUtZm5zXCIpO1xuY29uc3QgVGhlbWVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9UaGVtZUNvbnRleHRcIik7XG5jb25zdCBzdHlsZXNfMSA9IHJlcXVpcmUoXCJAbXVpL21hdGVyaWFsL3N0eWxlc1wiKTtcbmNvbnN0IEhhYml0Q2FyZCA9ICh7IGhhYml0LCBvblRvZ2dsZUNvbXBsZXRpb24sIG9uRGVsZXRlIH0pID0+IHtcbiAgICBjb25zdCB7IG1vZGUgfSA9ICgwLCBUaGVtZUNvbnRleHRfMS51c2VUaGVtZSkoKTtcbiAgICBjb25zdCBtdWlUaGVtZSA9ICgwLCBzdHlsZXNfMS51c2VUaGVtZSkoKTtcbiAgICBjb25zdCBbaXNMb2dEaWFsb2dPcGVuLCBzZXRJc0xvZ0RpYWxvZ09wZW5dID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBbaXNEZWxldGVEaWFsb2dPcGVuLCBzZXRJc0RlbGV0ZURpYWxvZ09wZW5dID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBbc2VsZWN0ZWREYXRlLCBzZXRTZWxlY3RlZERhdGVdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG5ldyBEYXRlKCkpO1xuICAgIGNvbnN0IFtxdWFudGl0eSwgc2V0UXVhbnRpdHldID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCcnKTtcbiAgICBjb25zdCBbdXNlQ2hlY2tib3gsIHNldFVzZUNoZWNrYm94XSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh0cnVlKTtcbiAgICBjb25zdCBbc2VsZWN0ZWRZZWFyLCBzZXRTZWxlY3RlZFllYXJdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7XG4gICAgLy8gRGVmaW5lIGNvbnN0YW50cyBmaXJzdFxuICAgIGNvbnN0IENFTExfR0FQID0gMTsgLy8gTWluaW11bSBnYXAgZm9yIGNvbXBhY3QgbGF5b3V0XG4gICAgY29uc3QgV0VFS0RBWV9MQUJFTF9XSURUSCA9IDIwOyAvLyBTbWFsbGVyIHdpZHRoIGZvciB3ZWVrZGF5IGxhYmVsc1xuICAgIC8vIERlYnVnIGZ1bmN0aW9uIHRvIGxvZyBncmlkIGluZm9ybWF0aW9uXG4gICAgY29uc3QgZGVidWdHcmlkSW5mbyA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZ3JpZCkgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbFdlZWtzID0gZ3JpZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRheXNJbkZ1bGxZZWFyID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAwKS5nZXREYXRlKCkgPT09IDM2NiA/IDM2NiA6IDM2NTtcbiAgICAgICAgY29uc3QgZGF5c0luQ3VycmVudFllYXIgPSBncmlkLmZsYXQoKS5maWx0ZXIoZGF0ZSA9PiBkYXRlICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGphbjEgPSBncmlkLmZsYXQoKS5maW5kKGRhdGUgPT4gZGF0ZSAmJiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDAgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDEpO1xuICAgICAgICBjb25zdCBkZWMzMSA9IGdyaWQuZmxhdCgpLmZpbmQoZGF0ZSA9PiBkYXRlICYmIGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMTEgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDMxKTtcbiAgICAgICAgY29uc29sZS5sb2coYEdyaWQgZm9yICR7c2VsZWN0ZWRZZWFyfTogJHt0b3RhbFdlZWtzfSB3ZWVrcyDDlyA3IGRheXNgKTtcbiAgICAgICAgY29uc29sZS5sb2coYERheXMgaW4geWVhcjogJHtkYXlzSW5GdWxsWWVhcn0sIGRheXMgZGlzcGxheWVkIGZyb20geWVhcjogJHtkYXlzSW5DdXJyZW50WWVhcn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYEphbiAxIHByZXNlbnQ6ICR7ISFqYW4xfSwgRGVjIDMxIHByZXNlbnQ6ICR7ISFkZWMzMX1gKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemU6IHRvdGFsV2Vla3MsXG4gICAgICAgICAgICBkYXlzSW5ZZWFyOiBkYXlzSW5DdXJyZW50WWVhcixcbiAgICAgICAgICAgIGhhc0phbjE6ICEhamFuMSxcbiAgICAgICAgICAgIGhhc0RlYzMxOiAhIWRlYzMxXG4gICAgICAgIH07XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIEJ1aWxkIGEgR2l0SHViLXN0eWxlIGhlYXRtYXAgZ3JpZCBmb3IgdGhlIHNlbGVjdGVkIHllYXJcbiAgICBjb25zdCBkYXlzT2ZZZWFyID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDAsIDEpOyAvLyBKYW51YXJ5IDFzdFxuICAgICAgICBjb25zdCB5ZWFyRW5kID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpOyAvLyBEZWNlbWJlciAzMXN0XG4gICAgICAgIHJldHVybiAoMCwgZGF0ZV9mbnNfMS5lYWNoRGF5T2ZJbnRlcnZhbCkoeyBzdGFydDogeWVhclN0YXJ0LCBlbmQ6IHllYXJFbmQgfSk7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIEZpcnN0IGRheSBvZiB5ZWFyIGFkanVzdGVkIHRvIHN0YXJ0IG9uIHRoZSBjb3JyZWN0IGZpcnN0IFN1bmRheVxuICAgIGNvbnN0IGZpcnN0RGF5T2ZZZWFyID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCBqYW4xID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKTtcbiAgICAgICAgLy8gR28gYmFjayB0byB0aGUgcHJldmlvdXMgU3VuZGF5IChvciBzdGF5IG9uIFN1bmRheSBpZiBpdCBhbHJlYWR5IGlzIG9uZSlcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShqYW4xKTtcbiAgICAgICAgcmV0dXJuICgwLCBkYXRlX2Zuc18xLmFkZERheXMpKGphbjEsIC1kYXlPZldlZWspO1xuICAgIH0sIFtzZWxlY3RlZFllYXJdKTtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiB3ZWVrcyBpbiB0aGUgeWVhciBjb3JyZWN0bHlcbiAgICBjb25zdCBudW1XZWVrcyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgY29uc3QgamFuMSA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGRlYzMxID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpO1xuICAgICAgICAvLyBGaXJzdCB3ZWVrIHN0YXJ0cyB3aXRoIHRoZSBmaXJzdCBTdW5kYXkgb24gb3IgYmVmb3JlIEphbiAxXG4gICAgICAgIGNvbnN0IHN0YXJ0RGF5ID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShqYW4xKTsgLy8gMD1TdW5kYXksIDY9U2F0dXJkYXlcbiAgICAgICAgY29uc3QgZmlyc3RTdW5kYXkgPSAoMCwgZGF0ZV9mbnNfMS5hZGREYXlzKShqYW4xLCAtc3RhcnREYXkpO1xuICAgICAgICAvLyBMYXN0IHdlZWsgaW5jbHVkZXMgdGhlIGxhc3QgZGF5IG9mIHRoZSB5ZWFyXG4gICAgICAgIGNvbnN0IGVuZERheSA9ICgwLCBkYXRlX2Zuc18xLmdldERheSkoZGVjMzEpO1xuICAgICAgICBjb25zdCBsYXN0U2F0dXJkYXkgPSAoMCwgZGF0ZV9mbnNfMS5hZGREYXlzKShkZWMzMSwgNiAtIGVuZERheSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB3ZWVrcyBiZXR3ZWVuIGZpcnN0IFN1bmRheSBhbmQgbGFzdCBTYXR1cmRheVxuICAgICAgICByZXR1cm4gKDAsIGRhdGVfZm5zXzEuZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcykobGFzdFNhdHVyZGF5LCBmaXJzdFN1bmRheSwgeyB3ZWVrU3RhcnRzT246IDAgfSkgKyAxO1xuICAgIH0sIFtzZWxlY3RlZFllYXJdKTtcbiAgICBjb25zdCBudW1Sb3dzID0gNzsgLy8gU3VuLVNhdFxuICAgIC8vIEJ1aWxkIGdyaWQ6IGdyaWRbY29sXVtyb3ddID0gZGF0ZSBvciBudWxsXG4gICAgLy8gQ29sID0gd2VlaywgUm93ID0gd2Vla2RheVxuICAgIGNvbnN0IGdyaWQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIC8vIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBmb3IgdGhlIHllYXJcbiAgICAgICAgY29uc3QgamFuMSA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGRlYzMxID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBTdW5kYXkgYmVmb3JlIG9yIG9uIEphbiAxXG4gICAgICAgIGNvbnN0IGZpcnN0RGF5T2ZHcmlkID0gbmV3IERhdGUoamFuMSk7XG4gICAgICAgIGNvbnN0IGZpcnN0RGF5T2ZXZWVrID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShmaXJzdERheU9mR3JpZCk7XG4gICAgICAgIGZpcnN0RGF5T2ZHcmlkLnNldERhdGUoZmlyc3REYXlPZkdyaWQuZ2V0RGF0ZSgpIC0gZmlyc3REYXlPZldlZWspO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IFNhdHVyZGF5IGFmdGVyIG9yIG9uIERlYyAzMVxuICAgICAgICBjb25zdCBsYXN0RGF5T2ZHcmlkID0gbmV3IERhdGUoZGVjMzEpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZXZWVrID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShsYXN0RGF5T2ZHcmlkKTtcbiAgICAgICAgbGFzdERheU9mR3JpZC5zZXREYXRlKGxhc3REYXlPZkdyaWQuZ2V0RGF0ZSgpICsgKDYgLSBsYXN0RGF5T2ZXZWVrKSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHdlZWtzXG4gICAgICAgIC8vIEFkZCAxIGJlY2F1c2UgZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcyBpcyBleGNsdXNpdmUgb2YgZW5kIGRhdGVcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IE1hdGguY2VpbCgobGFzdERheU9mR3JpZC5nZXRUaW1lKCkgLSBmaXJzdERheU9mR3JpZC5nZXRUaW1lKCkpIC8gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ3JpZCB3aXRoIHRoZSBjb3JyZWN0IG51bWJlciBvZiB3ZWVrc1xuICAgICAgICBjb25zdCBuZXdHcmlkID0gW107XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIGZpcnN0IGRheSBvZiB0aGUgZ3JpZFxuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mR3JpZCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCB3ZWVrc1xuICAgICAgICBmb3IgKGxldCB3ZWVrID0gMDsgd2VlayA8IHRvdGFsV2Vla3M7IHdlZWsrKykge1xuICAgICAgICAgICAgY29uc3Qgd2Vla1JvdyA9IFtdO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgZGF5cyBmb3IgZWFjaCB3ZWVrXG4gICAgICAgICAgICBmb3IgKGxldCBkYXkgPSAwOyBkYXkgPCA3OyBkYXkrKykge1xuICAgICAgICAgICAgICAgIHdlZWtSb3cucHVzaChuZXcgRGF0ZShjdXJyZW50RGF0ZSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdHcmlkLnB1c2god2Vla1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ291bnQgZGF5cyBpbiB0aGUgY3VycmVudCB5ZWFyIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29uc3QgZGF5c0luWWVhciA9IG5ld0dyaWQuZmxhdCgpLmZpbHRlcihkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyKS5sZW5ndGg7XG4gICAgICAgIC8vIExvZyBkZWJ1ZyBpbmZvXG4gICAgICAgIGNvbnNvbGUubG9nKGBDYWxlbmRhciBncmlkIGZvciAke3NlbGVjdGVkWWVhcn06ICR7dG90YWxXZWVrc30gd2Vla3MgKCR7bmV3R3JpZC5sZW5ndGh9eDcpLCAke2RheXNJblllYXJ9IGRheXMgaW4geWVhcmApO1xuICAgICAgICByZXR1cm4gbmV3R3JpZDtcbiAgICB9LCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgLy8gRGVmaW5lIGR5bmFtaWMgY2VsbCBzaXplIGJhc2VkIG9uIGF2YWlsYWJsZSB3aWR0aFxuICAgIGNvbnN0IGNhbGN1bGF0ZUNlbGxTaXplID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzbWFsbGVzdCBwb3NzaWJsZSBjZWxsIHNpemUgdGhhdCBmaXRzIGFsbCB3ZWVrcyB3aXRob3V0IHNjcm9sbFxuICAgICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoIC0gODAsIDEyMDApO1xuICAgICAgICBjb25zdCB3ZWVrZGF5TGFiZWxTcGFjZSA9IFdFRUtEQVlfTEFCRUxfV0lEVEggKyA0O1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGZpdCBhIGZ1bGwgeWVhciAoNTItNTMgd2Vla3MpXG4gICAgICAgIGNvbnN0IHRvdGFsV2Vla3MgPSBncmlkLmxlbmd0aDsgLy8gVGhpcyBpcyBub3cgY2FsY3VsYXRlZCBjb3JyZWN0bHkgaW4gdGhlIGdyaWQgbG9naWNcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNpemUgdG8gZmlsbCBhdmFpbGFibGUgd2lkdGggd2l0aG91dCBzY3JvbGxpbmdcbiAgICAgICAgY29uc3QgY2VsbFNpemVXaXRoR2FwID0gKGF2YWlsYWJsZVdpZHRoIC0gd2Vla2RheUxhYmVsU3BhY2UpIC8gdG90YWxXZWVrcztcbiAgICAgICAgY29uc3QgY2VsbFNpemUgPSBNYXRoLmZsb29yKGNlbGxTaXplV2l0aEdhcCAtIENFTExfR0FQKTtcbiAgICAgICAgLy8gRW5zdXJlIG1pbmltdW0gc2l6ZSBidXQgYWxsb3cgc21hbGxlciBjZWxscyB0byBmaXQgYWxsXG4gICAgICAgIHJldHVybiBNYXRoLm1heChjZWxsU2l6ZSwgOCk7XG4gICAgfSwgW2dyaWRdKTtcbiAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIG9uY2Ugb24gY29tcG9uZW50IG1vdW50XG4gICAgY29uc3QgQ0VMTF9TSVpFID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgYSBwcm9wZXIgY2VsbCBzaXplIGJhc2VkIG9uIGdyaWQgd2lkdGhcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FsY3VsYXRlQ2VsbFNpemUoKTtcbiAgICAgICAgLy8gRGVidWcgZ3JpZCBpbmZvcm1hdGlvblxuICAgICAgICBkZWJ1Z0dyaWRJbmZvKGdyaWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtjYWxjdWxhdGVDZWxsU2l6ZSwgZ3JpZCwgZGVidWdHcmlkSW5mb10pO1xuICAgIC8vIEdlbmVyYXRlIG1vbnRoIGxhYmVscyBiYXNlZCBvbiBhY3R1YWwgY2VsbCBkYXRlc1xuICAgIGNvbnN0IG1vbnRoTGFiZWxzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbHMgPSBbXTtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgY29sdW1uICh3ZWVrKSBvZiBlYWNoIG1vbnRoIGluIHRoZSBncmlkXG4gICAgICAgIGZvciAobGV0IG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xuICAgICAgICAgICAgLy8gRmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgY29uc3QgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCBtb250aCwgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmRDb2x1bW4gPSAtMTtcbiAgICAgICAgICAgIC8vIEZpbmQgd2hpY2ggY29sdW1uICh3ZWVrKSBjb250YWlucyB0aGUgZmlyc3QgZGF5IG9mIHRoaXMgbW9udGhcbiAgICAgICAgICAgIGZvciAobGV0IGNvbElkeCA9IDA7IGNvbElkeCA8IGdyaWQubGVuZ3RoOyBjb2xJZHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IDc7IHJvd0lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRheSA9IGdyaWRbY29sSWR4XVtyb3dJZHhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNlbGwgY29udGFpbnMgdGhlIGZpcnN0IGRheSBvZiB0aGlzIG1vbnRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheS5nZXREYXRlKCkgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBkYXRlX2Zuc18xLmdldE1vbnRoKShkYXkpID09PSBtb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRhdGVfZm5zXzEuZ2V0WWVhcikoZGF5KSA9PT0gc2VsZWN0ZWRZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZENvbHVtbiA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZENvbHVtbiAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgdGhlIGZpcnN0IGRheSBvZiB0aGlzIG1vbnRoIGluIHRoZSBncmlkXG4gICAgICAgICAgICBpZiAoZm91bmRDb2x1bW4gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2w6IGZvdW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBtb250aDogKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShmaXJzdERheU9mTW9udGgsICdNTU0nKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSwgW2dyaWQsIHNlbGVjdGVkWWVhcl0pO1xuICAgIGNvbnN0IGlzSGFiaXRDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlU3RyZWFrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgbGV0IHN0cmVhayA9IDA7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgd2hpbGUgKGlzSGFiaXRDb21wbGV0ZWQoY3VycmVudERhdGUpICYmICEoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShjdXJyZW50RGF0ZSwgdG9kYXkpKSB7XG4gICAgICAgICAgICBzdHJlYWsrKztcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhaztcbiAgICB9LCBbaXNIYWJpdENvbXBsZXRlZF0pO1xuICAgIGNvbnN0IGhhbmRsZUxvZ1N1Ym1pdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIC8vIEZvciBoYWJpdHMgdGhhdCB0cmFjayBxdWFudGl0eSwgdXNlIHRoZSBxdWFudGl0eSB2YWx1ZVxuICAgICAgICBpZiAoaGFiaXQudHJhY2tRdWFudGl0eSkge1xuICAgICAgICAgICAgaWYgKHF1YW50aXR5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSwgTnVtYmVyKHF1YW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLXF1YW50aXR5IGhhYml0cywgYWx3YXlzIG1hcmsgYXMgY29tcGxldGVkXG4gICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgIHNldFF1YW50aXR5KCcnKTtcbiAgICAgICAgc2V0VXNlQ2hlY2tib3godHJ1ZSk7XG4gICAgfSwgW2hhYml0LnRyYWNrUXVhbnRpdHksIHNlbGVjdGVkRGF0ZSwgcXVhbnRpdHksIG9uVG9nZ2xlQ29tcGxldGlvbl0pO1xuICAgIGNvbnN0IGhhbmRsZURheUNsaWNrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXkpID0+IHtcbiAgICAgICAgaWYgKCgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGRheSwgbmV3IERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgYWxsb3cgbG9nZ2luZyBmdXR1cmUgZGF0ZXNcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF5KTtcbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBjYWxjdWxhdGVTdHJlYWsoKSwgW2NhbGN1bGF0ZVN0cmVha10pO1xuICAgIGNvbnN0IGlzRGF5Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIGNvbnN0IGhhbmRsZVByZXZZZWFyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRZZWFyKHByZXYgPT4gcHJldiAtIDEpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBoYW5kbGVOZXh0WWVhciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkWWVhcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlBhcGVyLCB7IGVsZXZhdGlvbjogMCwgc3g6IHtcbiAgICAgICAgICAgIHA6IDIsXG4gICAgICAgICAgICBwYjogMSxcbiAgICAgICAgICAgIG1iOiAyLFxuICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgID8gJzAgMnB4IDhweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgOiAnMCAycHggOHB4IHJnYmEoMCwwLDAsMC4wNSknLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgd2lkdGg6ICcxMDAlJywgbXg6ICdhdXRvJywgbWI6IDAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImg1XCIsIGFsaWduOiBcImNlbnRlclwiLCBub1dyYXA6IHRydWUsIHRpdGxlOiBoYWJpdC5uYW1lLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogNjAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmc6ICcwLjAxZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDFweCAycHggcmdiYSgwLDAsMCwwLjMpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDFweCAxcHggcmdiYSgwLDAsMCwwLjEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEuMnJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgMnB4IHNvbGlkICR7aGFiaXQuY29sb3J9MzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJy0ycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGhhYml0Lm5hbWUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBweDogMC41XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlUHJldlllYXIsIHN4OiB7IGNvbG9yOiAndGV4dC5wcmltYXJ5JywgcDogMC41IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQ2hldnJvbkxlZnQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXg6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5wcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC44cmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogc2VsZWN0ZWRZZWFyIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIG9uQ2xpY2s6IGhhbmRsZU5leHRZZWFyLCBkaXNhYmxlZDogc2VsZWN0ZWRZZWFyID49IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgc3g6IHsgY29sb3I6ICd0ZXh0LnByaW1hcnknLCBwOiAwLjUgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5DaGV2cm9uUmlnaHQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogMC41IH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IGBDdXJyZW50IHN0cmVhazogJHtzdHJlYWt9IGRheXNgLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjhyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbXCJcXHVEODNEXFx1REQyNSBcIiwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBzdHlsZTogeyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6ICcycHgnIH0sIGNoaWxkcmVuOiBzdHJlYWsgfSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHNpemU6IFwic21hbGxcIiwgc3RhcnRJY29uOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQWRkLCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSksIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHk6IDAuNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiAnNTBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC43NXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGAke2hhYml0LmNvbG9yfTk5YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBgJHtoYWJpdC5jb2xvcn1jY2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJMb2dcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkljb25CdXR0b24sIHsgc2l6ZTogXCJzbWFsbFwiLCBjb2xvcjogXCJlcnJvclwiLCBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4odHJ1ZSksIHN4OiB7IHA6IDAuNSB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkRlbGV0ZSwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1sOiBgJHtXRUVLREFZX0xBQkVMX1dJRFRIfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBgY2FsYygke2dyaWQubGVuZ3RoICogKENFTExfU0laRSArIENFTExfR0FQKX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBtb250aExhYmVscy5tYXAoKGxhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiB0byBjZW50ZXIgaXQgcHJlY2lzZWx5IGFib3ZlIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBsYWJlbC5jb2wgKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApICsgKENFTExfU0laRSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBgJHtwb3NpdGlvbn1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknLCAvLyBDZW50ZXIgdGhlIGxhYmVsIG9uIHRoZSBjZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMiAvLyBFbnN1cmUgbGFiZWxzIGRvbid0IGdldCBvdmVybGFwcGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBub1dyYXA6IHRydWUsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNjVyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwIDJweCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGxhYmVsLm1vbnRoIH0pIH0sIGlkeCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IGAke1dFRUtEQVlfTEFCRUxfV0lEVEh9cHggcmVwZWF0KCR7Z3JpZC5sZW5ndGh9LCAke0NFTExfU0laRX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiBDRUxMX0dBUCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGBjYWxjKCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weCArICR7Z3JpZC5sZW5ndGggKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApfXB4IC0gJHtDRUxMX0dBUH1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcycHgnIC8vIEFkZCBhIHNtYWxsIHBhZGRpbmcgdG8gYXZvaWQgY3V0LW9mZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1swLCAxLCAyLCAzLCA0LCA1LCA2XS5tYXAoKHdlZWtkYXkpID0+ICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHdlZWtkYXkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5U2VsZjogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByOiAwLjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBXRUVLREFZX0xBQkVMX1dJRFRIIC0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJ2JhY2tncm91bmQucGFwZXInIDogJ2JhY2tncm91bmQucGFwZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjZyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVt3ZWVrZGF5XSB9KSB9LCB3ZWVrZGF5KSkpLCBncmlkLm1hcCgod2Vla0NvbHVtbiwgY29sSWR4KSA9PiAod2Vla0NvbHVtbi5tYXAoKGRheSwgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRlIGZvciB0aGlzIGNlbGwgcG9zaXRpb24gZnJvbSBvdXIgZ3JpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtcHR5IGNlbGwgb3IgY2VsbCBvdXRzaWRlIGN1cnJlbnQgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2VsbERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sSWR4ICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3dJZHggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBDRUxMX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBgMXB4IHNvbGlkICR7bW9kZSA9PT0gJ2RhcmsnID8gJyMzMzMnIDogJyNmMGYwZjAnfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSwgYGVtcHR5LSR7Y29sSWR4fS0ke3Jvd0lkeH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2VsbCdzIGRhdGUgaXMgaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5DdXJyZW50WWVhciA9IGNlbGxEYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbW9udGggYW5kIGRldGVybWluZSBib3VuZGFyaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9udGggPSAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGRheSBvZiBhIG1vbnRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaXJzdERheU9mTW9udGggPSBjZWxsRGF0ZS5nZXREYXRlKCkgPT09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIG1vbnRoIGJvdW5kYXJpZXMgLSBsYXN0IGRheSBvZiB0aGUgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3REYXlPZk1vbnRoID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERheSA9IG5ldyBEYXRlKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dERheS5zZXREYXRlKGNlbGxEYXRlLmdldERhdGUoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGRhdGVfZm5zXzEuZ2V0TW9udGgpKG5leHREYXkpICE9PSAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDb21wbGV0ZWQgPSBpc0RheUNvbXBsZXRlZChjZWxsRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGdXR1cmUgPSAoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShjZWxsRGF0ZSwgbmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RGF5ID0gKDAsIGRhdGVfZm5zXzEuaXNUb2RheSkoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vbnRoIGJvdW5kYXJ5IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9udGhCb3JkZXJDb2xvciA9IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChpc0luQ3VycmVudFllYXIgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjUpJyA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMiknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChpc0luQ3VycmVudFllYXIgPyAncmdiYSgwLDAsMCwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuMiknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IGNvbElkeCArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3dJZHggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhhYml0LmNvbG9yICsgKG1vZGUgPT09ICdkYXJrJyA/ICdhYScgOiAnOTknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGlzSW5DdXJyZW50WWVhciA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDUpJyA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDIpJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXNJbkN1cnJlbnRZZWFyID8gJ3RyYW5zcGFyZW50JyA6ICdyZ2JhKDAsMCwwLDAuMDIpJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGlzQ3VycmVudERheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYDFweCBzb2xpZCAke2hhYml0LmNvbG9yfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAxcHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAnIzQ0NCcgOiAnI2UwZTBlMCd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtb250aCBib3VuZGFyeSBzdHlsaW5nIChvbmx5IGZvciBkYXRlcyBpbiBjdXJyZW50IHllYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oaXNJbkN1cnJlbnRZZWFyICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBpc0ZpcnN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmlnaHQ6IGlzTGFzdERheU9mTW9udGggPyBgMnB4IHNvbGlkICR7bW9udGhCb3JkZXJDb2xvcn1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclRvcDogcm93SWR4ID09PSAwICYmIGlzRmlyc3REYXlPZk1vbnRoID8gYDJweCBzb2xpZCAke21vbnRoQm9yZGVyQ29sb3J9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IHJvd0lkeCA9PT0gNiAmJiBpc0ZpcnN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzFweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6IChpc0Z1dHVyZSB8fCAhaXNJbkN1cnJlbnRZZWFyKSA/ICdkZWZhdWx0JyA6ICdwb2ludGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzRnV0dXJlID8gMC4zIDogKGlzSW5DdXJyZW50WWVhciA/IDEgOiAwLjMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2JhY2tncm91bmQtY29sb3IgMC4ycycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IGlzSW5DdXJyZW50WWVhciAmJiAhaXNGdXR1cmUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBoYWJpdC5jb2xvciArICdjYydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICcjZjVmNWY1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25DbGljazogKCkgPT4gaXNJbkN1cnJlbnRZZWFyICYmICFpc0Z1dHVyZSAmJiBoYW5kbGVEYXlDbGljayhjZWxsRGF0ZSkgfSwgY2VsbERhdGUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV0gfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2csIHsgb3BlbjogaXNMb2dEaWFsb2dPcGVuLCBvbkNsb3NlOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBtYXhXaWR0aDogXCJ4c1wiLCBmdWxsV2lkdGg6IHRydWUsIFBhcGVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC4xMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ1RpdGxlLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBiOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQoNDVkZWcsICR7aGFiaXQuY29sb3J9IDMwJSwgJHtoYWJpdC5jb2xvcn05OSA5MCUpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtcIkxvZyBcIiwgaGFiaXQubmFtZV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dDb250ZW50LCB7IHN4OiB7IGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgbXQ6IDIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJzdWJ0aXRsZTJcIiwgZ3V0dGVyQm90dG9tOiB0cnVlLCBjb2xvcjogXCJ0ZXh0LnByaW1hcnlcIiwgY2hpbGRyZW46IFtcIkRhdGU6IFwiLCAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ01NTU0gZCwgeXl5eScpXSB9KSwgIWhhYml0LnRyYWNrUXVhbnRpdHkgPyAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkZvcm1Db250cm9sTGFiZWwsIHsgY29udHJvbDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkNoZWNrYm94LCB7IGNoZWNrZWQ6IHVzZUNoZWNrYm94LCBvbkNoYW5nZTogKGUpID0+IHNldFVzZUNoZWNrYm94KGUudGFyZ2V0LmNoZWNrZWQpLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmLk11aS1jaGVja2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSwgbGFiZWw6ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogXCJNYXJrIGFzIGNvbXBsZXRlZFwiIH0pIH0pKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGhhYml0cyB0aGF0IHRyYWNrIHF1YW50aXR5LCBhbHdheXMgc2hvdyB0aGUgcXVhbnRpdHkgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRleHRGaWVsZCwgeyBmdWxsV2lkdGg6IHRydWUsIHR5cGU6IFwibnVtYmVyXCIsIGxhYmVsOiBgUXVhbnRpdHkke2hhYml0LnVuaXQgPyBgICgke2hhYml0LnVuaXR9KWAgOiAnJ31gLCB2YWx1ZTogcXVhbnRpdHksIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IChOdW1iZXIodmFsKSA+PSAwICYmIE51bWJlcih2YWwpIDw9IDEwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFF1YW50aXR5KHZhbCA9PT0gJycgPyAnJyA6IE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIC5NdWlPdXRsaW5lZElucHV0LXJvb3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmLk11aS1mb2N1c2VkIGZpZWxkc2V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgLk11aUlucHV0TGFiZWwtcm9vdC5NdWktZm9jdXNlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBpbnB1dFByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksIGlzRGF5Q29tcGxldGVkKHNlbGVjdGVkRGF0ZSkgJiYgKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgY29sb3I6IFwid2FybmluZ1wiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIlVuZG9cIiB9KSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlTG9nU3VibWl0LCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBkaXNhYmxlZDogaGFiaXQudHJhY2tRdWFudGl0eSAmJiBxdWFudGl0eSA9PT0gJycsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHtoYWJpdC5jb2xvcn0gMzAlLCAke2hhYml0LmNvbG9yfTk5IDkwJSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBgMCAzcHggNXB4IDJweCAke2hhYml0LmNvbG9yfTMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFwiU2F2ZVwiIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nLCB7IG9wZW46IGlzRGVsZXRlRGlhbG9nT3Blbiwgb25DbG9zZTogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgbWF4V2lkdGg6IFwieHNcIiwgZnVsbFdpZHRoOiB0cnVlLCBQYXBlclByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuNSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuMTIpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ1RpdGxlLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBiOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICcjM2EwNTA1JyA6ICcjZmZlYmVlJywgLy8gRGFyay9saWdodCByZWQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtb2RlID09PSAnZGFyaycgPyAnI2ZmNTI1MicgOiAnI2QzMmYyZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJEZWxldGUgSGFiaXRcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgc3g6IHsgbXQ6IDIsIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogW1wiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSBcXFwiXCIsIGhhYml0Lm5hbWUsIFwiXFxcIj8gVGhpcyBhY3Rpb24gY2Fubm90IGJlIHVuZG9uZS5cIl0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nQWN0aW9ucywgeyBzeDogeyBweDogMywgcHk6IDIsIGJvcmRlclRvcDogJzFweCBzb2xpZCcsIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIkNhbmNlbFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb2xvcjogXCJlcnJvclwiLCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiRGVsZXRlXCIgfSldIH0pXSB9KV0gfSkpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhhYml0Q2FyZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});