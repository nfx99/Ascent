"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    // Define constants first\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 20; // Smaller width for weekday labels\n    // Build a GitHub-style heatmap grid for the selected year\n    const daysOfYear = (0, react_1.useMemo)(() => {\n        const yearStart = new Date(selectedYear, 0, 1); // January 1st\n        const yearEnd = new Date(selectedYear, 11, 31); // December 31st\n        return (0, date_fns_1.eachDayOfInterval)({ start: yearStart, end: yearEnd });\n    }, [selectedYear]);\n    // First day of year adjusted to start on the correct first Sunday\n    const firstDayOfYear = (0, react_1.useMemo)(() => {\n        const jan1 = new Date(selectedYear, 0, 1);\n        // Go back to the previous Sunday (or stay on Sunday if it already is one)\n        const dayOfWeek = (0, date_fns_1.getDay)(jan1);\n        return (0, date_fns_1.addDays)(jan1, -dayOfWeek);\n    }, [selectedYear]);\n    // Calculate the number of weeks in the year correctly\n    const numWeeks = (0, react_1.useMemo)(() => {\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // First week starts with the first Sunday on or before Jan 1\n        const startDay = (0, date_fns_1.getDay)(jan1); // 0=Sunday, 6=Saturday\n        const firstSunday = (0, date_fns_1.addDays)(jan1, -startDay);\n        // Last week includes the last day of the year\n        const endDay = (0, date_fns_1.getDay)(dec31);\n        const lastSaturday = (0, date_fns_1.addDays)(dec31, 6 - endDay);\n        // Calculate weeks between first Sunday and last Saturday\n        return (0, date_fns_1.differenceInCalendarWeeks)(lastSaturday, firstSunday, { weekStartsOn: 0 }) + 1;\n    }, [selectedYear]);\n    const numRows = 7; // Sun-Sat\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        // Create a grid with all weeks of the year plus any extra weeks needed to show full months\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // Calculate the first date to display (the Sunday before or on Jan 1)\n        const firstSunday = (() => {\n            const day = new Date(jan1);\n            const dayOfWeek = (0, date_fns_1.getDay)(day);\n            return (0, date_fns_1.addDays)(day, -dayOfWeek);\n        })();\n        // Calculate the last date to display (the Saturday after or on Dec 31)\n        const lastSaturday = (() => {\n            const day = new Date(dec31);\n            const dayOfWeek = (0, date_fns_1.getDay)(day);\n            return (0, date_fns_1.addDays)(day, 6 - dayOfWeek);\n        })();\n        // Calculate total weeks\n        const totalWeeks = (0, date_fns_1.differenceInCalendarWeeks)(lastSaturday, firstSunday, { weekStartsOn: 0 }) + 1;\n        // Create a grid with all necessary weeks\n        const newGrid = Array.from({ length: totalWeeks }, () => Array(numRows).fill(null));\n        // Fill grid with dates\n        for (let week = 0; week < totalWeeks; week++) {\n            for (let dayOfWeek = 0; dayOfWeek < 7; dayOfWeek++) {\n                const date = (0, date_fns_1.addDays)(firstSunday, week * 7 + dayOfWeek);\n                newGrid[week][dayOfWeek] = date;\n            }\n        }\n        return newGrid;\n    }, [selectedYear]);\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Calculate the smallest possible cell size that fits all weeks without scroll\n        const availableWidth = Math.min(window.innerWidth - 80, 1200);\n        const weekdayLabelSpace = WEEKDAY_LABEL_WIDTH + 4;\n        // We need to fit all weeks (max 53) completely\n        const totalWeeks = 53;\n        // Calculate size to fill available width without scrolling\n        const cellSizeWithGap = (availableWidth - weekdayLabelSpace) / totalWeeks;\n        const cellSize = Math.max(Math.floor(cellSizeWithGap - CELL_GAP), 8);\n        return cellSize;\n    }, []);\n    // Calculate cell size once on component mount\n    const CELL_SIZE = (0, react_1.useMemo)(() => calculateCellSize(), [calculateCellSize]);\n    // Generate month labels based on actual cell dates\n    const monthLabels = (0, react_1.useMemo)(() => {\n        const labels = [];\n        // Find the first column (week) of each month in the grid\n        for (let month = 0; month < 12; month++) {\n            // First day of the month\n            const firstDayOfMonth = new Date(selectedYear, month, 1);\n            let foundColumn = -1;\n            // Find which column (week) contains the first day of this month\n            for (let colIdx = 0; colIdx < grid.length; colIdx++) {\n                for (let rowIdx = 0; rowIdx < 7; rowIdx++) {\n                    const day = grid[colIdx][rowIdx];\n                    // Check if this cell contains the first day of this month\n                    if (day &&\n                        day.getDate() === 1 &&\n                        (0, date_fns_1.getMonth)(day) === month &&\n                        (0, date_fns_1.getYear)(day) === selectedYear) {\n                        foundColumn = colIdx;\n                        break;\n                    }\n                }\n                if (foundColumn !== -1)\n                    break;\n            }\n            // If we found the first day of this month in the grid\n            if (foundColumn !== -1) {\n                labels.push({\n                    col: foundColumn,\n                    month: (0, date_fns_1.format)(firstDayOfMonth, 'MMM')\n                });\n            }\n        }\n        return labels;\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        // For habits that track quantity, use the quantity value\n        if (habit.trackQuantity) {\n            if (quantity !== '') {\n                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n            }\n        }\n        else {\n            // For non-quantity habits, always mark as completed\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [habit.trackQuantity, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2,\n            pb: 1,\n            mb: 2,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 2px 8px rgba(0,0,0,0.3)'\n                : '0 2px 8px rgba(0,0,0,0.05)',\n            width: '100%',\n            maxWidth: '100%',\n            overflowX: 'hidden'\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { width: '100%', mx: 'auto', mb: 0 }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0,\n                            mb: 1,\n                            width: '100%',\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.01em',\n                            textShadow: mode === 'dark'\n                                ? '0 1px 2px rgba(0,0,0,0.3)'\n                                : '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.2rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.5,\n                            position: 'relative',\n                            '&::after': {\n                                content: '\"\"',\n                                position: 'absolute',\n                                bottom: '-2px',\n                                left: 0,\n                                width: '100%',\n                                borderBottom: `2px solid ${habit.color}33`,\n                            }\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            display: 'flex',\n                            justifyContent: 'space-between',\n                            alignItems: 'center',\n                            mb: 0.5,\n                            px: 0.5\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary', p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: {\n                                                mx: 0.5,\n                                                fontWeight: 'bold',\n                                                color: 'text.primary',\n                                                fontSize: '0.8rem'\n                                            }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary', p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.5 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: {\n                                                display: 'flex',\n                                                alignItems: 'center',\n                                                fontSize: '0.8rem'\n                                            }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '2px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, { fontSize: \"small\" }), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.4,\n                                            px: 1,\n                                            minWidth: '50px',\n                                            fontSize: '0.75rem',\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), sx: { p: 0.5 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, { fontSize: \"small\" }) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            width: '100%',\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'flex-start',\n                            overflow: 'hidden',\n                            maxWidth: '100%'\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                    display: 'flex',\n                                    alignItems: 'center',\n                                    mb: 0.5,\n                                    ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                    width: `calc(${numWeeks * (CELL_SIZE + CELL_GAP)}px)`,\n                                    justifyContent: 'flex-start',\n                                    position: 'relative',\n                                    height: '16px',\n                                    overflow: 'visible'\n                                }, children: monthLabels.map((label, idx) => {\n                                    // Calculate position to center it precisely above the first cell of the month\n                                    const position = label.col * (CELL_SIZE + CELL_GAP) + (CELL_SIZE / 2);\n                                    return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            position: 'absolute',\n                                            left: `${position}px`,\n                                            transform: 'translateX(-50%)', // Center the label on the cell\n                                            textAlign: 'center',\n                                            zIndex: 2 // Ensure labels don't get overlapped\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", noWrap: true, sx: {\n                                                fontSize: '0.65rem',\n                                                color: 'text.secondary',\n                                                fontWeight: 'bold',\n                                                lineHeight: 1,\n                                                display: 'inline-block',\n                                                whiteSpace: 'nowrap',\n                                                padding: '0 2px'\n                                            }, children: label.month }) }, idx));\n                                }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    display: 'grid',\n                                    gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${numWeeks}, ${CELL_SIZE}px)`,\n                                    gap: CELL_GAP,\n                                    mb: 0,\n                                    width: `calc(${WEEKDAY_LABEL_WIDTH}px + ${numWeeks * (CELL_SIZE + CELL_GAP)}px - ${CELL_GAP}px)`,\n                                    maxWidth: '100%',\n                                    overflowX: 'hidden',\n                                    overflowY: 'hidden',\n                                    justifyContent: 'flex-start',\n                                    paddingBottom: '2px' // Add a small padding to avoid cut-off\n                                }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            gridColumn: 1,\n                                            gridRow: weekday + 1,\n                                            justifySelf: 'end',\n                                            pr: 0.3,\n                                            width: WEEKDAY_LABEL_WIDTH - 2,\n                                            bgcolor: mode === 'dark' ? 'background.paper' : 'background.paper'\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                fontSize: '0.6rem',\n                                                color: 'text.secondary',\n                                                lineHeight: 1\n                                            }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), Array.from({ length: numWeeks }).map((_, colIdx) => ([0, 1, 2, 3, 4, 5, 6].map((rowIdx) => {\n                                        // Get the date for this cell position from our grid\n                                        const cellDate = grid[colIdx][rowIdx];\n                                        // Empty cell or cell outside current year\n                                        if (!cellDate) {\n                                            return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    gridColumn: colIdx + 2,\n                                                    gridRow: rowIdx + 1,\n                                                    width: CELL_SIZE,\n                                                    height: CELL_SIZE,\n                                                    border: `1px solid ${mode === 'dark' ? '#333' : '#f0f0f0'}`,\n                                                    borderRadius: '2px',\n                                                    opacity: 0.2\n                                                } }, `empty-${colIdx}-${rowIdx}`));\n                                        }\n                                        // Check if this is the first day of a month\n                                        const isFirstDayOfMonth = cellDate.getDate() === 1;\n                                        // Check if this cell's date is in the current year\n                                        const isInCurrentYear = cellDate.getFullYear() === selectedYear;\n                                        // Determine month boundaries - last day of the month\n                                        const isLastDayOfMonth = (() => {\n                                            const nextDay = new Date(cellDate);\n                                            nextDay.setDate(cellDate.getDate() + 1);\n                                            return (0, date_fns_1.getMonth)(nextDay) !== (0, date_fns_1.getMonth)(cellDate);\n                                        })();\n                                        // Get month number for styling\n                                        const month = (0, date_fns_1.getMonth)(cellDate);\n                                        const isCompleted = isDayCompleted(cellDate);\n                                        const isFuture = (0, date_fns_1.isAfter)(cellDate, new Date());\n                                        const isCurrentDay = (0, date_fns_1.isToday)(cellDate);\n                                        // Month boundary color\n                                        const monthBorderColor = mode === 'dark'\n                                            ? 'rgba(255,255,255,0.5)'\n                                            : 'rgba(0,0,0,0.4)';\n                                        return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                gridColumn: colIdx + 2,\n                                                gridRow: rowIdx + 1,\n                                                width: CELL_SIZE,\n                                                height: CELL_SIZE,\n                                                bgcolor: isCompleted\n                                                    ? habit.color + (mode === 'dark' ? 'aa' : '99')\n                                                    : mode === 'dark' ? (isInCurrentYear ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)')\n                                                        : (isInCurrentYear ? 'transparent' : 'rgba(0,0,0,0.02)'),\n                                                border: isCurrentDay\n                                                    ? `1px solid ${habit.color}`\n                                                    : `1px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`,\n                                                // Add month boundary styling\n                                                borderLeft: isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                borderRight: isLastDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                borderTop: rowIdx === 0 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                borderBottom: rowIdx === 6 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                borderRadius: '1px',\n                                                cursor: isFuture ? 'not-allowed' : 'pointer',\n                                                opacity: isFuture ? 0.3 : (isInCurrentYear ? 1 : 0.5),\n                                                transition: 'background-color 0.2s',\n                                                '&:hover': {\n                                                    bgcolor: isCompleted\n                                                        ? habit.color + 'cc'\n                                                        : mode === 'dark' ? 'rgba(255,255,255,0.1)' : '#f5f5f5',\n                                                }\n                                            }, onClick: () => !isFuture && handleDayClick(cellDate) }, cellDate.toString()));\n                                    })))] })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                            color: '#fff',\n                        }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), !habit.trackQuantity ? ((0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                            color: habit.color,\n                                            '&.Mui-checked': {\n                                                color: habit.color,\n                                            }\n                                        } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) })) : (\n                                // For habits that track quantity, always show the quantity field\n                                (0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: {\n                                        mt: 1,\n                                        '& .MuiOutlinedInput-root': {\n                                            '&.Mui-focused fieldset': {\n                                                borderColor: habit.color,\n                                            },\n                                        },\n                                        '& .MuiInputLabel-root.Mui-focused': {\n                                            color: habit.color,\n                                        },\n                                    }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: habit.trackQuantity && quantity === '', sx: {\n                                    borderRadius: '20px',\n                                    px: 2,\n                                    background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                    boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                            color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                        }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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eUJBQXlCLGtDQUFrQyxzREFBc0QsTUFBTSw2QkFBNkIsc0RBQXNELE1BQU0sT0FBTyw4REFBOEQsNklBQTZJLGlGQUFpRix1REFBdUQ7QUFDMWlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBEQUEwRCxzREFBc0QsR0FBRztBQUM5SjtBQUNBLCtFQUErRSxtREFBbUQsa0JBQWtCLFdBQVcsUUFBUTtBQUN2SztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLEdBQUcsdURBQXVELE1BQU0sMkZBQTJGLHlEQUF5RCxnREFBZ0QsNkJBQTZCLHNCQUFzQixnRkFBZ0Y7QUFDbmI7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLDZCQUE2QixvQkFBb0IsZ0RBQWdEO0FBQzFJO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYSxPQUFPLFlBQVk7QUFDMUcsZ0VBQWdFLFlBQVk7QUFDNUUsaUNBQWlDLG9CQUFvQixJQUFJLElBQUksZ0RBQWdEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQThEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCLHNEQUFzRCxNQUFNLG9DQUFvQyw2REFBNkQsMEhBQTBILEdBQUcsdURBQXVELE1BQU0sMkZBQTJGLHlEQUF5RCxtREFBbUQsNkJBQTZCLHNCQUFzQiwrQ0FBK0M7QUFDcnJCO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQThDLDZCQUE2QixzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDOUk7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzY2VudC8uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzL0hhYml0Q2FyZC50c3g/NDNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IG1hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9tYXRlcmlhbFwiKTtcbmNvbnN0IGljb25zX21hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9pY29ucy1tYXRlcmlhbFwiKTtcbmNvbnN0IGRhdGVfZm5zXzEgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG5jb25zdCBUaGVtZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L1RoZW1lQ29udGV4dFwiKTtcbmNvbnN0IHN0eWxlc18xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWwvc3R5bGVzXCIpO1xuY29uc3QgSGFiaXRDYXJkID0gKHsgaGFiaXQsIG9uVG9nZ2xlQ29tcGxldGlvbiwgb25EZWxldGUgfSkgPT4ge1xuICAgIGNvbnN0IHsgbW9kZSB9ID0gKDAsIFRoZW1lQ29udGV4dF8xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IG11aVRoZW1lID0gKDAsIHN0eWxlc18xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IFtpc0xvZ0RpYWxvZ09wZW4sIHNldElzTG9nRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RlbGV0ZURpYWxvZ09wZW4sIHNldElzRGVsZXRlRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RlZERhdGUsIHNldFNlbGVjdGVkRGF0ZV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKSk7XG4gICAgY29uc3QgW3F1YW50aXR5LCBzZXRRdWFudGl0eV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoJycpO1xuICAgIGNvbnN0IFt1c2VDaGVja2JveCwgc2V0VXNlQ2hlY2tib3hdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHRydWUpO1xuICAgIGNvbnN0IFtzZWxlY3RlZFllYXIsIHNldFNlbGVjdGVkWWVhcl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTtcbiAgICAvLyBEZWZpbmUgY29uc3RhbnRzIGZpcnN0XG4gICAgY29uc3QgQ0VMTF9HQVAgPSAxOyAvLyBNaW5pbXVtIGdhcCBmb3IgY29tcGFjdCBsYXlvdXRcbiAgICBjb25zdCBXRUVLREFZX0xBQkVMX1dJRFRIID0gMjA7IC8vIFNtYWxsZXIgd2lkdGggZm9yIHdlZWtkYXkgbGFiZWxzXG4gICAgLy8gQnVpbGQgYSBHaXRIdWItc3R5bGUgaGVhdG1hcCBncmlkIGZvciB0aGUgc2VsZWN0ZWQgeWVhclxuICAgIGNvbnN0IGRheXNPZlllYXIgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHllYXJTdGFydCA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMSk7IC8vIEphbnVhcnkgMXN0XG4gICAgICAgIGNvbnN0IHllYXJFbmQgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDExLCAzMSk7IC8vIERlY2VtYmVyIDMxc3RcbiAgICAgICAgcmV0dXJuICgwLCBkYXRlX2Zuc18xLmVhY2hEYXlPZkludGVydmFsKSh7IHN0YXJ0OiB5ZWFyU3RhcnQsIGVuZDogeWVhckVuZCB9KTtcbiAgICB9LCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgLy8gRmlyc3QgZGF5IG9mIHllYXIgYWRqdXN0ZWQgdG8gc3RhcnQgb24gdGhlIGNvcnJlY3QgZmlyc3QgU3VuZGF5XG4gICAgY29uc3QgZmlyc3REYXlPZlllYXIgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGphbjEgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDAsIDEpO1xuICAgICAgICAvLyBHbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBTdW5kYXkgKG9yIHN0YXkgb24gU3VuZGF5IGlmIGl0IGFscmVhZHkgaXMgb25lKVxuICAgICAgICBjb25zdCBkYXlPZldlZWsgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGphbjEpO1xuICAgICAgICByZXR1cm4gKDAsIGRhdGVfZm5zXzEuYWRkRGF5cykoamFuMSwgLWRheU9mV2Vlayk7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIENhbGN1bGF0ZSB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoZSB5ZWFyIGNvcnJlY3RseVxuICAgIGNvbnN0IG51bVdlZWtzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCBqYW4xID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKTtcbiAgICAgICAgY29uc3QgZGVjMzEgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDExLCAzMSk7XG4gICAgICAgIC8vIEZpcnN0IHdlZWsgc3RhcnRzIHdpdGggdGhlIGZpcnN0IFN1bmRheSBvbiBvciBiZWZvcmUgSmFuIDFcbiAgICAgICAgY29uc3Qgc3RhcnREYXkgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGphbjEpOyAvLyAwPVN1bmRheSwgNj1TYXR1cmRheVxuICAgICAgICBjb25zdCBmaXJzdFN1bmRheSA9ICgwLCBkYXRlX2Zuc18xLmFkZERheXMpKGphbjEsIC1zdGFydERheSk7XG4gICAgICAgIC8vIExhc3Qgd2VlayBpbmNsdWRlcyB0aGUgbGFzdCBkYXkgb2YgdGhlIHllYXJcbiAgICAgICAgY29uc3QgZW5kRGF5ID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShkZWMzMSk7XG4gICAgICAgIGNvbnN0IGxhc3RTYXR1cmRheSA9ICgwLCBkYXRlX2Zuc18xLmFkZERheXMpKGRlYzMxLCA2IC0gZW5kRGF5KTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdlZWtzIGJldHdlZW4gZmlyc3QgU3VuZGF5IGFuZCBsYXN0IFNhdHVyZGF5XG4gICAgICAgIHJldHVybiAoMCwgZGF0ZV9mbnNfMS5kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzKShsYXN0U2F0dXJkYXksIGZpcnN0U3VuZGF5LCB7IHdlZWtTdGFydHNPbjogMCB9KSArIDE7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIGNvbnN0IG51bVJvd3MgPSA3OyAvLyBTdW4tU2F0XG4gICAgLy8gQnVpbGQgZ3JpZDogZ3JpZFtjb2xdW3Jvd10gPSBkYXRlIG9yIG51bGxcbiAgICAvLyBDb2wgPSB3ZWVrLCBSb3cgPSB3ZWVrZGF5XG4gICAgY29uc3QgZ3JpZCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZ3JpZCB3aXRoIGFsbCB3ZWVrcyBvZiB0aGUgeWVhciBwbHVzIGFueSBleHRyYSB3ZWVrcyBuZWVkZWQgdG8gc2hvdyBmdWxsIG1vbnRoc1xuICAgICAgICBjb25zdCBqYW4xID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKTtcbiAgICAgICAgY29uc3QgZGVjMzEgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDExLCAzMSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZmlyc3QgZGF0ZSB0byBkaXNwbGF5ICh0aGUgU3VuZGF5IGJlZm9yZSBvciBvbiBKYW4gMSlcbiAgICAgICAgY29uc3QgZmlyc3RTdW5kYXkgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5ID0gbmV3IERhdGUoamFuMSk7XG4gICAgICAgICAgICBjb25zdCBkYXlPZldlZWsgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGRheSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGRhdGVfZm5zXzEuYWRkRGF5cykoZGF5LCAtZGF5T2ZXZWVrKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsYXN0IGRhdGUgdG8gZGlzcGxheSAodGhlIFNhdHVyZGF5IGFmdGVyIG9yIG9uIERlYyAzMSlcbiAgICAgICAgY29uc3QgbGFzdFNhdHVyZGF5ID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRheSA9IG5ldyBEYXRlKGRlYzMxKTtcbiAgICAgICAgICAgIGNvbnN0IGRheU9mV2VlayA9ICgwLCBkYXRlX2Zuc18xLmdldERheSkoZGF5KTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZGF0ZV9mbnNfMS5hZGREYXlzKShkYXksIDYgLSBkYXlPZldlZWspO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdG90YWwgd2Vla3NcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9ICgwLCBkYXRlX2Zuc18xLmRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3MpKGxhc3RTYXR1cmRheSwgZmlyc3RTdW5kYXksIHsgd2Vla1N0YXJ0c09uOiAwIH0pICsgMTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgZ3JpZCB3aXRoIGFsbCBuZWNlc3Nhcnkgd2Vla3NcbiAgICAgICAgY29uc3QgbmV3R3JpZCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IHRvdGFsV2Vla3MgfSwgKCkgPT4gQXJyYXkobnVtUm93cykuZmlsbChudWxsKSk7XG4gICAgICAgIC8vIEZpbGwgZ3JpZCB3aXRoIGRhdGVzXG4gICAgICAgIGZvciAobGV0IHdlZWsgPSAwOyB3ZWVrIDwgdG90YWxXZWVrczsgd2VlaysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBkYXlPZldlZWsgPSAwOyBkYXlPZldlZWsgPCA3OyBkYXlPZldlZWsrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSAoMCwgZGF0ZV9mbnNfMS5hZGREYXlzKShmaXJzdFN1bmRheSwgd2VlayAqIDcgKyBkYXlPZldlZWspO1xuICAgICAgICAgICAgICAgIG5ld0dyaWRbd2Vla11bZGF5T2ZXZWVrXSA9IGRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0dyaWQ7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIERlZmluZSBkeW5hbWljIGNlbGwgc2l6ZSBiYXNlZCBvbiBhdmFpbGFibGUgd2lkdGhcbiAgICBjb25zdCBjYWxjdWxhdGVDZWxsU2l6ZSA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc21hbGxlc3QgcG9zc2libGUgY2VsbCBzaXplIHRoYXQgZml0cyBhbGwgd2Vla3Mgd2l0aG91dCBzY3JvbGxcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCAtIDgwLCAxMjAwKTtcbiAgICAgICAgY29uc3Qgd2Vla2RheUxhYmVsU3BhY2UgPSBXRUVLREFZX0xBQkVMX1dJRFRIICsgNDtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBmaXQgYWxsIHdlZWtzIChtYXggNTMpIGNvbXBsZXRlbHlcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IDUzO1xuICAgICAgICAvLyBDYWxjdWxhdGUgc2l6ZSB0byBmaWxsIGF2YWlsYWJsZSB3aWR0aCB3aXRob3V0IHNjcm9sbGluZ1xuICAgICAgICBjb25zdCBjZWxsU2l6ZVdpdGhHYXAgPSAoYXZhaWxhYmxlV2lkdGggLSB3ZWVrZGF5TGFiZWxTcGFjZSkgLyB0b3RhbFdlZWtzO1xuICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IE1hdGgubWF4KE1hdGguZmxvb3IoY2VsbFNpemVXaXRoR2FwIC0gQ0VMTF9HQVApLCA4KTtcbiAgICAgICAgcmV0dXJuIGNlbGxTaXplO1xuICAgIH0sIFtdKTtcbiAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIG9uY2Ugb24gY29tcG9uZW50IG1vdW50XG4gICAgY29uc3QgQ0VMTF9TSVpFID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gY2FsY3VsYXRlQ2VsbFNpemUoKSwgW2NhbGN1bGF0ZUNlbGxTaXplXSk7XG4gICAgLy8gR2VuZXJhdGUgbW9udGggbGFiZWxzIGJhc2VkIG9uIGFjdHVhbCBjZWxsIGRhdGVzXG4gICAgY29uc3QgbW9udGhMYWJlbHMgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBjb2x1bW4gKHdlZWspIG9mIGVhY2ggbW9udGggaW4gdGhlIGdyaWRcbiAgICAgICAgZm9yIChsZXQgbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG4gICAgICAgICAgICAvLyBGaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgICAgIGxldCBmb3VuZENvbHVtbiA9IC0xO1xuICAgICAgICAgICAgLy8gRmluZCB3aGljaCBjb2x1bW4gKHdlZWspIGNvbnRhaW5zIHRoZSBmaXJzdCBkYXkgb2YgdGhpcyBtb250aFxuICAgICAgICAgICAgZm9yIChsZXQgY29sSWR4ID0gMDsgY29sSWR4IDwgZ3JpZC5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93SWR4ID0gMDsgcm93SWR4IDwgNzsgcm93SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF5ID0gZ3JpZFtjb2xJZHhdW3Jvd0lkeF07XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2VsbCBjb250YWlucyB0aGUgZmlyc3QgZGF5IG9mIHRoaXMgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRheSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF5LmdldERhdGUoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGRhdGVfZm5zXzEuZ2V0TW9udGgpKGRheSkgPT09IG1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgZGF0ZV9mbnNfMS5nZXRZZWFyKShkYXkpID09PSBzZWxlY3RlZFllYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kQ29sdW1uID0gY29sSWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kQ29sdW1uICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCB0aGUgZmlyc3QgZGF5IG9mIHRoaXMgbW9udGggaW4gdGhlIGdyaWRcbiAgICAgICAgICAgIGlmIChmb3VuZENvbHVtbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbDogZm91bmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGZpcnN0RGF5T2ZNb250aCwgJ01NTScpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9LCBbZ3JpZCwgc2VsZWN0ZWRZZWFyXSk7XG4gICAgY29uc3QgaXNIYWJpdENvbXBsZXRlZCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gaGFiaXQuY29tcGxldGlvbnMuc29tZShjb21wbGV0aW9uID0+IGNvbXBsZXRpb24uZGF0ZSA9PT0gKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShkYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICBjb25zdCBjYWxjdWxhdGVTdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBsZXQgc3RyZWFrID0gMDtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB3aGlsZSAoaXNIYWJpdENvbXBsZXRlZChjdXJyZW50RGF0ZSkgJiYgISgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGN1cnJlbnREYXRlLCB0b2RheSkpIHtcbiAgICAgICAgICAgIHN0cmVhaysrO1xuICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFrO1xuICAgIH0sIFtpc0hhYml0Q29tcGxldGVkXSk7XG4gICAgY29uc3QgaGFuZGxlTG9nU3VibWl0ID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgLy8gRm9yIGhhYml0cyB0aGF0IHRyYWNrIHF1YW50aXR5LCB1c2UgdGhlIHF1YW50aXR5IHZhbHVlXG4gICAgICAgIGlmIChoYWJpdC50cmFja1F1YW50aXR5KSB7XG4gICAgICAgICAgICBpZiAocXVhbnRpdHkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpLCBOdW1iZXIocXVhbnRpdHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZvciBub24tcXVhbnRpdHkgaGFiaXRzLCBhbHdheXMgbWFyayBhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgc2V0UXVhbnRpdHkoJycpO1xuICAgICAgICBzZXRVc2VDaGVja2JveCh0cnVlKTtcbiAgICB9LCBbaGFiaXQudHJhY2tRdWFudGl0eSwgc2VsZWN0ZWREYXRlLCBxdWFudGl0eSwgb25Ub2dnbGVDb21wbGV0aW9uXSk7XG4gICAgY29uc3QgaGFuZGxlRGF5Q2xpY2sgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRheSkgPT4ge1xuICAgICAgICBpZiAoKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoZGF5LCBuZXcgRGF0ZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBhbGxvdyBsb2dnaW5nIGZ1dHVyZSBkYXRlc1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGVkRGF0ZShkYXkpO1xuICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHN0cmVhayA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IGNhbGN1bGF0ZVN0cmVhaygpLCBbY2FsY3VsYXRlU3RyZWFrXSk7XG4gICAgY29uc3QgaXNEYXlDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgaGFuZGxlUHJldlllYXIgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZFllYXIocHJldiA9PiBwcmV2IC0gMSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZU5leHRZZWFyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRZZWFyKHByZXYgPT4gcHJldiArIDEpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuUGFwZXIsIHsgZWxldmF0aW9uOiAwLCBzeDoge1xuICAgICAgICAgICAgcDogMixcbiAgICAgICAgICAgIHBiOiAxLFxuICAgICAgICAgICAgbWI6IDIsXG4gICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCcsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgIGJveFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgPyAnMCAycHggOHB4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICAgICAgICAgICAgICA6ICcwIDJweCA4cHggcmdiYSgwLDAsMCwwLjA1KScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbidcbiAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyB3aWR0aDogJzEwMCUnLCBteDogJ2F1dG8nLCBtYjogMCB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiaDVcIiwgYWxpZ246IFwiY2VudGVyXCIsIG5vV3JhcDogdHJ1ZSwgdGl0bGU6IGhhYml0Lm5hbWUsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogJzAuMDFlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMS4ycmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOjphZnRlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiAnLTJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke2hhYml0LmNvbG9yfTMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogaGFiaXQubmFtZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYjogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAwLjVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkljb25CdXR0b24sIHsgc2l6ZTogXCJzbWFsbFwiLCBvbkNsaWNrOiBoYW5kbGVQcmV2WWVhciwgc3g6IHsgY29sb3I6ICd0ZXh0LnByaW1hcnknLCBwOiAwLjUgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5DaGV2cm9uTGVmdCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImJvZHkyXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBteDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICd0ZXh0LnByaW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjhyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBzZWxlY3RlZFllYXIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlTmV4dFllYXIsIGRpc2FibGVkOiBzZWxlY3RlZFllYXIgPj0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBzeDogeyBjb2xvcjogJ3RleHQucHJpbWFyeScsIHA6IDAuNSB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25SaWdodCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZ2FwOiAwLjUgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVG9vbHRpcCwgeyB0aXRsZTogYEN1cnJlbnQgc3RyZWFrOiAke3N0cmVha30gZGF5c2AsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBjb2xvcjogXCJ0ZXh0LnNlY29uZGFyeVwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuOHJlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtcIlxcdUQ4M0RcXHVERDI1IFwiLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKFwic3BhblwiLCB7IHN0eWxlOiB7IGZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luTGVmdDogJzJweCcgfSwgY2hpbGRyZW46IHN0cmVhayB9KV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgdmFyaWFudDogXCJjb250YWluZWRcIiwgc2l6ZTogXCJzbWFsbFwiLCBzdGFydEljb246ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5BZGQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUobmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9nRGlhbG9nT3Blbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweTogMC40LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICc1MHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjc1cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogYCR7aGFiaXQuY29sb3J9OTlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGAke2hhYml0LmNvbG9yfWNjYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkxvZ1wiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIGNvbG9yOiBcImVycm9yXCIsIG9uQ2xpY2s6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3Blbih0cnVlKSwgc3g6IHsgcDogMC41IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuRGVsZXRlLCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSkgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnZmxleC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYjogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWw6IGAke1dFRUtEQVlfTEFCRUxfV0lEVEh9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGBjYWxjKCR7bnVtV2Vla3MgKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxNnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IG1vbnRoTGFiZWxzLm1hcCgobGFiZWwsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIHRvIGNlbnRlciBpdCBwcmVjaXNlbHkgYWJvdmUgdGhlIGZpcnN0IGNlbGwgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGxhYmVsLmNvbCAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCkgKyAoQ0VMTF9TSVpFIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGAke3Bvc2l0aW9ufXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsIC8vIENlbnRlciB0aGUgbGFiZWwgb24gdGhlIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyIC8vIEVuc3VyZSBsYWJlbHMgZG9uJ3QgZ2V0IG92ZXJsYXBwZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIG5vV3JhcDogdHJ1ZSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC42NXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQuc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzAgMnB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogbGFiZWwubW9udGggfSkgfSwgaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weCByZXBlYXQoJHtudW1XZWVrc30sICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IENFTExfR0FQLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYGNhbGMoJHtXRUVLREFZX0xBQkVMX1dJRFRIfXB4ICsgJHtudW1XZWVrcyAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCl9cHggLSAke0NFTExfR0FQfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WTogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogJzJweCcgLy8gQWRkIGEgc21hbGwgcGFkZGluZyB0byBhdm9pZCBjdXQtb2ZmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcCgod2Vla2RheSkgPT4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogd2Vla2RheSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlTZWxmOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHI6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IFdFRUtEQVlfTEFCRUxfV0lEVEggLSAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBtb2RlID09PSAnZGFyaycgPyAnYmFja2dyb3VuZC5wYXBlcicgOiAnYmFja2dyb3VuZC5wYXBlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNnJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQuc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddW3dlZWtkYXldIH0pIH0sIHdlZWtkYXkpKSksIEFycmF5LmZyb20oeyBsZW5ndGg6IG51bVdlZWtzIH0pLm1hcCgoXywgY29sSWR4KSA9PiAoWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcCgocm93SWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRlIGZvciB0aGlzIGNlbGwgcG9zaXRpb24gZnJvbSBvdXIgZ3JpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gZ3JpZFtjb2xJZHhdW3Jvd0lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1wdHkgY2VsbCBvciBjZWxsIG91dHNpZGUgY3VycmVudCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjZWxsRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkQ29sdW1uOiBjb2xJZHggKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHJvd0lkeCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGAxcHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAnIzMzMycgOiAnI2YwZjBmMCd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBgZW1wdHktJHtjb2xJZHh9LSR7cm93SWR4fWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZmlyc3QgZGF5IG9mIGEgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpcnN0RGF5T2ZNb250aCA9IGNlbGxEYXRlLmdldERhdGUoKSA9PT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNlbGwncyBkYXRlIGlzIGluIHRoZSBjdXJyZW50IHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0luQ3VycmVudFllYXIgPSBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIG1vbnRoIGJvdW5kYXJpZXMgLSBsYXN0IGRheSBvZiB0aGUgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0xhc3REYXlPZk1vbnRoID0gKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERheSA9IG5ldyBEYXRlKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dERheS5zZXREYXRlKGNlbGxEYXRlLmdldERhdGUoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGRhdGVfZm5zXzEuZ2V0TW9udGgpKG5leHREYXkpICE9PSAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG1vbnRoIG51bWJlciBmb3Igc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoID0gKDAsIGRhdGVfZm5zXzEuZ2V0TW9udGgpKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9IGlzRGF5Q29tcGxldGVkKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Z1dHVyZSA9ICgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGNlbGxEYXRlLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnREYXkgPSAoMCwgZGF0ZV9mbnNfMS5pc1RvZGF5KShjZWxsRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9udGggYm91bmRhcnkgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aEJvcmRlckNvbG9yID0gbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAncmdiYSgwLDAsMCwwLjQpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IGNvbElkeCArIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3dJZHggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhhYml0LmNvbG9yICsgKG1vZGUgPT09ICdkYXJrJyA/ICdhYScgOiAnOTknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZSA9PT0gJ2RhcmsnID8gKGlzSW5DdXJyZW50WWVhciA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDUpJyA6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDIpJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXNJbkN1cnJlbnRZZWFyID8gJ3RyYW5zcGFyZW50JyA6ICdyZ2JhKDAsMCwwLDAuMDIpJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGlzQ3VycmVudERheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYDFweCBzb2xpZCAke2hhYml0LmNvbG9yfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAxcHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAnIzQ0NCcgOiAnI2UwZTBlMCd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBtb250aCBib3VuZGFyeSBzdHlsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJMZWZ0OiBpc0ZpcnN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogaXNMYXN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJUb3A6IHJvd0lkeCA9PT0gMCAmJiBpc0ZpcnN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IHJvd0lkeCA9PT0gNiAmJiBpc0ZpcnN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBpc0Z1dHVyZSA/ICdub3QtYWxsb3dlZCcgOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0Z1dHVyZSA/IDAuMyA6IChpc0luQ3VycmVudFllYXIgPyAxIDogMC41KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBoYWJpdC5jb2xvciArICdjYydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICcjZjVmNWY1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25DbGljazogKCkgPT4gIWlzRnV0dXJlICYmIGhhbmRsZURheUNsaWNrKGNlbGxEYXRlKSB9LCBjZWxsRGF0ZS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpXSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0xvZ0RpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgUGFwZXJQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjUpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjEyKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHtoYWJpdC5jb2xvcn0gMzAlLCAke2hhYml0LmNvbG9yfTk5IDkwJSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1wiTG9nIFwiLCBoYWJpdC5uYW1lXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgc3g6IHsgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBtdDogMiB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcInN1YnRpdGxlMlwiLCBndXR0ZXJCb3R0b206IHRydWUsIGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogW1wiRGF0ZTogXCIsICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAnTU1NTSBkLCB5eXl5JyldIH0pLCAhaGFiaXQudHJhY2tRdWFudGl0eSA/ICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRm9ybUNvbnRyb2xMYWJlbCwgeyBjb250cm9sOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQ2hlY2tib3gsIHsgY2hlY2tlZDogdXNlQ2hlY2tib3gsIG9uQ2hhbmdlOiAoZSkgPT4gc2V0VXNlQ2hlY2tib3goZS50YXJnZXQuY2hlY2tlZCksIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYuTXVpLWNoZWNrZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBsYWJlbDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBcIk1hcmsgYXMgY29tcGxldGVkXCIgfSkgfSkpIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgaGFiaXRzIHRoYXQgdHJhY2sgcXVhbnRpdHksIGFsd2F5cyBzaG93IHRoZSBxdWFudGl0eSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVGV4dEZpZWxkLCB7IGZ1bGxXaWR0aDogdHJ1ZSwgdHlwZTogXCJudW1iZXJcIiwgbGFiZWw6IGBRdWFudGl0eSR7aGFiaXQudW5pdCA/IGAgKCR7aGFiaXQudW5pdH0pYCA6ICcnfWAsIHZhbHVlOiBxdWFudGl0eSwgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgKE51bWJlcih2YWwpID49IDAgJiYgTnVtYmVyKHZhbCkgPD0gMTAwMDAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UXVhbnRpdHkodmFsID09PSAnJyA/ICcnIDogTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgLk11aU91dGxpbmVkSW5wdXQtcm9vdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYuTXVpLWZvY3VzZWQgZmllbGRzZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiAuTXVpSW5wdXRMYWJlbC1yb290Lk11aS1mb2N1c2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlucHV0UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAxMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ0FjdGlvbnMsIHsgc3g6IHsgcHg6IDMsIHB5OiAyLCBib3JkZXJUb3A6ICcxcHggc29saWQnLCBib3JkZXJDb2xvcjogJ2RpdmlkZXInLCBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJDYW5jZWxcIiB9KSwgaXNEYXlDb21wbGV0ZWQoc2VsZWN0ZWREYXRlKSAmJiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBjb2xvcjogXCJ3YXJuaW5nXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiVW5kb1wiIH0pKSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiBoYW5kbGVMb2dTdWJtaXQsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIGRpc2FibGVkOiBoYWJpdC50cmFja1F1YW50aXR5ICYmIHF1YW50aXR5ID09PSAnJywgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAke2hhYml0LmNvbG9yfSAzMCUsICR7aGFiaXQuY29sb3J9OTkgOTAlKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IGAwIDNweCA1cHggMnB4ICR7aGFiaXQuY29sb3J9MzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJTYXZlXCIgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2csIHsgb3BlbjogaXNEZWxldGVEaWFsb2dPcGVuLCBvbkNsb3NlOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBtYXhXaWR0aDogXCJ4c1wiLCBmdWxsV2lkdGg6IHRydWUsIFBhcGVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC4xMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJyMzYTA1MDUnIDogJyNmZmViZWUnLCAvLyBEYXJrL2xpZ2h0IHJlZCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICcjZmY1MjUyJyA6ICcjZDMyZjJmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkRlbGV0ZSBIYWJpdFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nQ29udGVudCwgeyBzeDogeyBtdDogMiwgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBbXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIFxcXCJcIiwgaGFiaXQubmFtZSwgXCJcXFwiPyBUaGlzIGFjdGlvbiBjYW5ub3QgYmUgdW5kb25lLlwiXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbG9yOiBcImVycm9yXCIsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJEZWxldGVcIiB9KV0gfSldIH0pXSB9KSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFiaXRDYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});