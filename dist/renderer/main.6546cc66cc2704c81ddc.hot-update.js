"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const isSmallScreen = (0, material_1.useMediaQuery)(muiTheme.breakpoints.down('sm'));\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    const [hoveredDate, setHoveredDate] = (0, react_1.useState)(null);\n    // Define constants first\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 15; // Smaller width for weekday labels\n    // Debug function to log grid information\n    const debugGridInfo = (0, react_1.useCallback)((grid) => {\n        const totalWeeks = grid.length;\n        const daysInFullYear = new Date(selectedYear, 0, 0).getDate() === 366 ? 366 : 365;\n        const daysInCurrentYear = grid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        const jan1 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 0 && date.getDate() === 1);\n        const dec31 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        console.log(`Grid for ${selectedYear}: ${totalWeeks} weeks Ã— 7 days`);\n        console.log(`Days in year: ${daysInFullYear}, days displayed from year: ${daysInCurrentYear}`);\n        console.log(`Jan 1 present: ${!!jan1}, Dec 31 present: ${!!dec31}`);\n        // Check if the grid is 52 or 53 weeks (standard for a year)\n        const isStandardSize = totalWeeks >= 52 && totalWeeks <= 53;\n        console.log(`Grid size check: ${isStandardSize ? 'PASSED' : 'FAILED'} - ${totalWeeks} weeks (should be 52-53)`);\n        return {\n            size: totalWeeks,\n            daysInYear: daysInCurrentYear,\n            hasJan1: !!jan1,\n            hasDec31: !!dec31,\n            isCorrectSize: isStandardSize\n        };\n    }, [selectedYear]);\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        // Get the start and end dates for the year\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // Find the first Sunday before or on Jan 1\n        const firstDayOfGrid = new Date(jan1);\n        const firstDayOfWeek = (0, date_fns_1.getDay)(firstDayOfGrid);\n        firstDayOfGrid.setDate(firstDayOfGrid.getDate() - firstDayOfWeek);\n        // Find the last Saturday after or on Dec 31\n        const lastDayOfGrid = new Date(dec31);\n        const lastDayOfWeek = (0, date_fns_1.getDay)(lastDayOfGrid);\n        lastDayOfGrid.setDate(lastDayOfGrid.getDate() + (6 - lastDayOfWeek));\n        // Calculate the total number of weeks\n        const totalWeeks = Math.ceil((lastDayOfGrid.getTime() - firstDayOfGrid.getTime()) / (7 * 24 * 60 * 60 * 1000));\n        // Create the grid with the correct number of weeks\n        const newGrid = [];\n        // Start with the first day of the grid\n        let currentDate = new Date(firstDayOfGrid);\n        // Generate all weeks\n        for (let week = 0; week < totalWeeks; week++) {\n            const weekRow = [];\n            // Generate days for each week\n            for (let day = 0; day < 7; day++) {\n                weekRow.push(new Date(currentDate));\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            newGrid.push(weekRow);\n        }\n        // Check if December 31st is included in the grid\n        const hasDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        // If December 31st is missing, add additional weeks until we include it\n        if (!hasDec31) {\n            console.warn(`December 31st, ${selectedYear} is missing from the grid. Extending grid.`);\n            // Continue where we left off\n            let additionalDate = new Date(currentDate);\n            // Add up to 4 additional weeks (should be enough in all cases)\n            for (let week = 0; week < 4; week++) {\n                const weekRow = [];\n                for (let day = 0; day < 7; day++) {\n                    weekRow.push(new Date(additionalDate));\n                    additionalDate.setDate(additionalDate.getDate() + 1);\n                    // Check if we've now included December 31st\n                    if (additionalDate.getFullYear() === selectedYear + 1) {\n                        const hasDec31Now = newGrid.flat().concat(weekRow).some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                        if (hasDec31Now) {\n                            break;\n                        }\n                    }\n                }\n                newGrid.push(weekRow);\n                // Check if December 31st is now in the grid after adding this week\n                const containsDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                if (containsDec31) {\n                    console.log(`Grid extended. December 31st, ${selectedYear} is now included.`);\n                    break;\n                }\n            }\n        }\n        // Count days in the current year for debugging\n        const daysInYear = new Date(selectedYear, 1, 29).getDate() === 29 ? 366 : 365;\n        const daysInCurrentYear = newGrid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        // Log debug info\n        console.log(`Calendar grid for ${selectedYear}: ${newGrid.length} weeks (${newGrid.length}x7), ${daysInCurrentYear}/${daysInYear} days in year`);\n        console.log(`First date in grid: ${(0, date_fns_1.format)(newGrid[0][0], 'yyyy-MM-dd')}`);\n        console.log(`Last date in grid: ${(0, date_fns_1.format)(newGrid[newGrid.length - 1][6], 'yyyy-MM-dd')}`);\n        return newGrid;\n    }, [selectedYear]);\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Calculate available width, accounting for padding and labels\n        const isSmallScreen = window.innerWidth < 600;\n        const isMediumScreen = window.innerWidth >= 600 && window.innerWidth < 960;\n        // Reduce padding on smaller screens to maximize space for the grid\n        const containerPadding = isSmallScreen ? 20 : isMediumScreen ? 40 : 60;\n        const availableWidth = Math.min(window.innerWidth - containerPadding, 1100);\n        // Account for weekday labels\n        const effectiveWidth = availableWidth - WEEKDAY_LABEL_WIDTH;\n        // Calculate cell size based on available width and total weeks\n        // We need to fit all 53 weeks (max in a year) plus gaps\n        const totalWeeks = grid.length;\n        const totalGaps = totalWeeks - 1;\n        // Calculate cell size\n        const cellSize = (effectiveWidth - (totalGaps * CELL_GAP)) / totalWeeks;\n        // Clamp to reasonable size range\n        return Math.max(Math.min(Math.floor(cellSize * 10) / 10, 10), 2.8);\n    }, [grid]);\n    // Calculate cell size and update on window resize\n    const [CELL_SIZE, setCellSize] = (0, react_1.useState)(() => calculateCellSize());\n    (0, react_1.useEffect)(() => {\n        // Update cell size on window resize\n        const handleResize = () => {\n            setCellSize(calculateCellSize());\n        };\n        // Initial calculation\n        setCellSize(calculateCellSize());\n        // Debug grid information\n        debugGridInfo(grid);\n        // Add resize event listener\n        window.addEventListener('resize', handleResize);\n        // Cleanup\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        };\n    }, [calculateCellSize, grid, debugGridInfo]);\n    // Simple month labels positioned at exact 4-column intervals\n    const monthLabels = (0, react_1.useMemo)(() => {\n        // Define the month names\n        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n        // Find column positions for the first day of each month\n        const monthColumnPositions = [];\n        // Loop through each month of the selected year\n        for (let month = 0; month < 12; month++) {\n            const firstDayOfMonth = new Date(selectedYear, month, 1);\n            // Find this date in the grid to get its column\n            let columnFound = -1;\n            // Search through the grid to find the column containing this date\n            for (let colIdx = 0; colIdx < grid.length; colIdx++) {\n                for (let rowIdx = 0; rowIdx < grid[colIdx].length; rowIdx++) {\n                    const gridDate = grid[colIdx][rowIdx];\n                    if (gridDate.getFullYear() === firstDayOfMonth.getFullYear() &&\n                        gridDate.getMonth() === firstDayOfMonth.getMonth() &&\n                        gridDate.getDate() === firstDayOfMonth.getDate()) {\n                        columnFound = colIdx;\n                        break;\n                    }\n                }\n                if (columnFound !== -1)\n                    break;\n            }\n            // If found, add to our positions array\n            if (columnFound !== -1) {\n                monthColumnPositions.push({\n                    month: monthNames[month],\n                    col: columnFound\n                });\n            }\n        }\n        return monthColumnPositions;\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        // For habits that track quantity, use the quantity value\n        if (habit.trackQuantity) {\n            if (quantity !== '') {\n                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n            }\n        }\n        else {\n            // For non-quantity habits, always mark as completed\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [habit.trackQuantity, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    // Get completion for a specific date\n    const getCompletion = (0, react_1.useCallback)((date) => {\n        const dateStr = (0, date_fns_1.format)(date, 'yyyy-MM-dd');\n        return habit.completions.find(c => c.date === dateStr);\n    }, [habit.completions]);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: { xs: 1, sm: 1.5, md: 2 },\n            pb: 1.5,\n            mb: 3,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 3px 10px rgba(0,0,0,0.35)'\n                : '0 3px 10px rgba(0,0,0,0.08)',\n            width: '100%',\n            maxWidth: '100%',\n            position: 'relative',\n            overflow: 'hidden'\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                    width: '100%',\n                    mx: 'auto',\n                    mb: 1,\n                    position: 'relative',\n                    overflowX: 'hidden',\n                    overflowY: 'hidden'\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0.5,\n                            mb: 1.5,\n                            width: '100%',\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.01em',\n                            textShadow: mode === 'dark'\n                                ? '0 1px 2px rgba(0,0,0,0.3)'\n                                : '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.3rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.75,\n                            position: 'relative',\n                            '&::after': {\n                                content: '\"\"',\n                                position: 'absolute',\n                                bottom: '-2px',\n                                left: 0,\n                                width: '100%',\n                                borderBottom: `2px solid ${habit.color}33`,\n                            }\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            display: 'flex',\n                            justifyContent: 'space-between',\n                            alignItems: 'center',\n                            mb: 1,\n                            px: 1,\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: {\n                                                mx: 0.7,\n                                                fontWeight: 'bold',\n                                                color: 'text.primary',\n                                                fontSize: '0.9rem'\n                                            }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.7 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: {\n                                                display: 'flex',\n                                                alignItems: 'center',\n                                                fontSize: '0.9rem'\n                                            }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '3px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, { fontSize: \"small\" }), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.5,\n                                            px: 1.5,\n                                            minWidth: '55px',\n                                            fontSize: '0.8rem',\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), sx: { p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, { fontSize: \"small\" }) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            width: '100%',\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'center', // Center the calendar horizontally\n                            position: 'relative',\n                            mt: 0.5,\n                            mb: 0.5,\n                            transform: `scale(${grid.length > 53 ? 0.95 : 1})`, // Slight scale down if many weeks\n                            transformOrigin: 'center top'\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                    display: 'flex',\n                                    width: `calc(${grid.length * (CELL_SIZE + CELL_GAP)}px)`,\n                                    mb: 0.8,\n                                    ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                    position: 'relative',\n                                    height: '20px',\n                                    overflow: 'visible' // Allow labels to be visible if they extend beyond container\n                                }, children: monthLabels.map((label, idx) => ((0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                        position: 'absolute',\n                                        left: `${label.col * (CELL_SIZE + CELL_GAP)}px`,\n                                        display: 'flex',\n                                        flexDirection: 'column',\n                                        alignItems: 'center',\n                                        width: CELL_SIZE, // Match cell width exactly\n                                        transform: 'translateX(-50%)', // Center precisely over the column\n                                    }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                fontSize: '0.65rem',\n                                                color: 'text.primary',\n                                                fontWeight: '600',\n                                                bgcolor: mode === 'dark' ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.04)',\n                                                px: 1,\n                                                py: 0.3,\n                                                borderRadius: '10px',\n                                                border: '1px solid',\n                                                borderColor: mode === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)',\n                                                whiteSpace: 'nowrap', // Prevent text wrapping\n                                                position: 'relative', // For precise positioning\n                                                zIndex: 2 // Ensure label is above vertical line\n                                            }, children: label.month }), (0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                width: '1px',\n                                                height: CELL_SIZE * 7 + (CELL_GAP * 6),\n                                                bgcolor: mode === 'dark' ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.1)',\n                                                mt: 0.4\n                                            } })] }, idx))) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    display: 'grid',\n                                    gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${grid.length}, ${CELL_SIZE}px)`,\n                                    gridTemplateRows: `repeat(7, ${CELL_SIZE}px)`,\n                                    gap: CELL_GAP,\n                                    mb: 0,\n                                    maxWidth: '100%',\n                                    justifyContent: 'center', // Center the grid horizontally\n                                    paddingBottom: '1px'\n                                }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            gridColumn: 1,\n                                            gridRow: weekday + 1,\n                                            justifySelf: 'end',\n                                            pr: 0.3,\n                                            width: WEEKDAY_LABEL_WIDTH - 2,\n                                            height: CELL_SIZE,\n                                            display: 'flex',\n                                            alignItems: 'center',\n                                            justifyContent: 'flex-end',\n                                            bgcolor: mode === 'dark' ? 'background.paper' : 'background.paper'\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                fontSize: CELL_SIZE < 4 ? '0.5rem' : '0.55rem',\n                                                color: 'text.secondary',\n                                                lineHeight: 1\n                                            }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), grid.map((weekColumn, colIdx) => (weekColumn.map((day, rowIdx) => {\n                                        // Get the date for this cell position from our grid\n                                        const cellDate = day;\n                                        // Check if this cell's date is in the current year\n                                        const isInCurrentYear = cellDate.getFullYear() === selectedYear;\n                                        // Check if this is the first day of a month\n                                        const isFirstDayOfMonth = cellDate.getDate() === 1;\n                                        const isCompleted = isDayCompleted(cellDate);\n                                        const isFuture = (0, date_fns_1.isAfter)(cellDate, new Date());\n                                        const isCurrentDay = (0, date_fns_1.isToday)(cellDate);\n                                        // Get completion details for tooltip\n                                        const completion = getCompletion(cellDate);\n                                        // Format date for tooltip\n                                        const formattedDate = (0, date_fns_1.format)(cellDate, 'EEEE, MMMM d, yyyy');\n                                        // Tooltip content\n                                        const tooltipContent = isInCurrentYear\n                                            ? (isCompleted\n                                                ? `${formattedDate}${completion?.quantity ? ` â€¢ ${completion.quantity} ${habit.unit || 'units'}` : ' â€¢ Completed'}`\n                                                : formattedDate)\n                                            : '';\n                                        // Scale cell border based on cell size\n                                        const borderWidth = CELL_SIZE > 5 ? 1 : 0.5;\n                                        return ((0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: tooltipContent, placement: \"top\", enterDelay: 500, arrow: true, disableHoverListener: !isInCurrentYear, children: (0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    gridColumn: colIdx + 2, // +2 because first column is for weekday labels\n                                                    gridRow: rowIdx + 1,\n                                                    width: CELL_SIZE,\n                                                    height: CELL_SIZE,\n                                                    bgcolor: isCompleted && isInCurrentYear\n                                                        ? habit.color + (mode === 'dark' ? 'cc' : 'bb')\n                                                        : mode === 'dark'\n                                                            ? (isInCurrentYear ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0)')\n                                                            : (isInCurrentYear ? 'transparent' : 'rgba(0,0,0,0)'),\n                                                    border: isInCurrentYear\n                                                        ? `${borderWidth}px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`\n                                                        : 'none',\n                                                    borderRadius: CELL_SIZE > 5 ? '1px' : '0px',\n                                                    cursor: (isFuture || !isInCurrentYear) ? 'default' : 'pointer',\n                                                    opacity: isFuture ? 0.3 : (isInCurrentYear ? 1 : 0.2),\n                                                    transition: 'background-color 0.2s, transform 0.15s',\n                                                    // Highlight first day of each month with stronger border\n                                                    borderLeft: isFirstDayOfMonth && isInCurrentYear\n                                                        ? `${borderWidth + 0.5}px solid ${mode === 'dark' ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.4)'}`\n                                                        : undefined,\n                                                    // Highlight current day\n                                                    ...(isCurrentDay && {\n                                                        boxShadow: `0 0 0 ${borderWidth + 0.5}px ${habit.color}`\n                                                    }),\n                                                    // Hover effect for larger cells\n                                                    '&:hover': CELL_SIZE > 4 && isInCurrentYear && !isFuture ? {\n                                                        transform: 'scale(1.2)',\n                                                        zIndex: 10,\n                                                        boxShadow: `0 2px 4px rgba(0,0,0,0.2)`,\n                                                        bgcolor: isCompleted\n                                                            ? habit.color + 'ee'\n                                                            : mode === 'dark' ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.05)'\n                                                    } : {},\n                                                    position: 'relative',\n                                                }, onClick: () => isInCurrentYear && !isFuture && handleDayClick(cellDate), onMouseEnter: () => setHoveredDate(cellDate), onMouseLeave: () => setHoveredDate(null) }) }, `cell-${colIdx}-${rowIdx}`));\n                                    })))] })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                            color: '#fff',\n                        }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), !habit.trackQuantity ? ((0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                            color: habit.color,\n                                            '&.Mui-checked': {\n                                                color: habit.color,\n                                            }\n                                        } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) })) : (\n                                // For habits that track quantity, always show the quantity field\n                                (0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: {\n                                        mt: 1,\n                                        '& .MuiOutlinedInput-root': {\n                                            '&.Mui-focused fieldset': {\n                                                borderColor: habit.color,\n                                            },\n                                        },\n                                        '& .MuiInputLabel-root.Mui-focused': {\n                                            color: habit.color,\n                                        },\n                                    }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: habit.trackQuantity && quantity === '', sx: {\n                                    borderRadius: '20px',\n                                    px: 2,\n                                    background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                    boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                            color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                        }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTJGLHlEQUF5RCxnREFBZ0QsNkJBQTZCLHNCQUFzQixnRkFBZ0Y7QUFDbmI7QUFDQTtBQUNBLGlDQUFpQyxRQUFRLDZCQUE2QixvQkFBb0IsZ0RBQWdEO0FBQzFJO0FBQ0E7QUFDQSwwRUFBMEUsYUFBYSxPQUFPLFlBQVk7QUFDMUcsZ0VBQWdFLFlBQVk7QUFDNUUsaUNBQWlDLG9CQUFvQixJQUFJLElBQUksZ0RBQWdEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQThEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNEJBQTRCLHNEQUFzRCxNQUFNLG9DQUFvQyw2REFBNkQsMEhBQTBILEdBQUcsdURBQXVELE1BQU0sMkZBQTJGLHlEQUF5RCxtREFBbUQsNkJBQTZCLHNCQUFzQiwrQ0FBK0M7QUFDcnJCO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQThDLDZCQUE2QixzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDOUk7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzY2VudC8uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzL0hhYml0Q2FyZC50c3g/NDNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IG1hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9tYXRlcmlhbFwiKTtcbmNvbnN0IGljb25zX21hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9pY29ucy1tYXRlcmlhbFwiKTtcbmNvbnN0IGRhdGVfZm5zXzEgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG5jb25zdCBUaGVtZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L1RoZW1lQ29udGV4dFwiKTtcbmNvbnN0IHN0eWxlc18xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWwvc3R5bGVzXCIpO1xuY29uc3QgSGFiaXRDYXJkID0gKHsgaGFiaXQsIG9uVG9nZ2xlQ29tcGxldGlvbiwgb25EZWxldGUgfSkgPT4ge1xuICAgIGNvbnN0IHsgbW9kZSB9ID0gKDAsIFRoZW1lQ29udGV4dF8xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IG11aVRoZW1lID0gKDAsIHN0eWxlc18xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IGlzU21hbGxTY3JlZW4gPSAoMCwgbWF0ZXJpYWxfMS51c2VNZWRpYVF1ZXJ5KShtdWlUaGVtZS5icmVha3BvaW50cy5kb3duKCdzbScpKTtcbiAgICBjb25zdCBbaXNMb2dEaWFsb2dPcGVuLCBzZXRJc0xvZ0RpYWxvZ09wZW5dID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBbaXNEZWxldGVEaWFsb2dPcGVuLCBzZXRJc0RlbGV0ZURpYWxvZ09wZW5dID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKGZhbHNlKTtcbiAgICBjb25zdCBbc2VsZWN0ZWREYXRlLCBzZXRTZWxlY3RlZERhdGVdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG5ldyBEYXRlKCkpO1xuICAgIGNvbnN0IFtxdWFudGl0eSwgc2V0UXVhbnRpdHldID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCcnKTtcbiAgICBjb25zdCBbdXNlQ2hlY2tib3gsIHNldFVzZUNoZWNrYm94XSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh0cnVlKTtcbiAgICBjb25zdCBbc2VsZWN0ZWRZZWFyLCBzZXRTZWxlY3RlZFllYXJdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7XG4gICAgY29uc3QgW2hvdmVyZWREYXRlLCBzZXRIb3ZlcmVkRGF0ZV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobnVsbCk7XG4gICAgLy8gRGVmaW5lIGNvbnN0YW50cyBmaXJzdFxuICAgIGNvbnN0IENFTExfR0FQID0gMTsgLy8gTWluaW11bSBnYXAgZm9yIGNvbXBhY3QgbGF5b3V0XG4gICAgY29uc3QgV0VFS0RBWV9MQUJFTF9XSURUSCA9IDE1OyAvLyBTbWFsbGVyIHdpZHRoIGZvciB3ZWVrZGF5IGxhYmVsc1xuICAgIC8vIERlYnVnIGZ1bmN0aW9uIHRvIGxvZyBncmlkIGluZm9ybWF0aW9uXG4gICAgY29uc3QgZGVidWdHcmlkSW5mbyA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZ3JpZCkgPT4ge1xuICAgICAgICBjb25zdCB0b3RhbFdlZWtzID0gZ3JpZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRheXNJbkZ1bGxZZWFyID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAwKS5nZXREYXRlKCkgPT09IDM2NiA/IDM2NiA6IDM2NTtcbiAgICAgICAgY29uc3QgZGF5c0luQ3VycmVudFllYXIgPSBncmlkLmZsYXQoKS5maWx0ZXIoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhcikubGVuZ3RoO1xuICAgICAgICBjb25zdCBqYW4xID0gZ3JpZC5mbGF0KCkuZmluZChkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMCAmJiBkYXRlLmdldERhdGUoKSA9PT0gMSk7XG4gICAgICAgIGNvbnN0IGRlYzMxID0gZ3JpZC5mbGF0KCkuZmluZChkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMTEgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDMxKTtcbiAgICAgICAgY29uc29sZS5sb2coYEdyaWQgZm9yICR7c2VsZWN0ZWRZZWFyfTogJHt0b3RhbFdlZWtzfSB3ZWVrcyDDlyA3IGRheXNgKTtcbiAgICAgICAgY29uc29sZS5sb2coYERheXMgaW4geWVhcjogJHtkYXlzSW5GdWxsWWVhcn0sIGRheXMgZGlzcGxheWVkIGZyb20geWVhcjogJHtkYXlzSW5DdXJyZW50WWVhcn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYEphbiAxIHByZXNlbnQ6ICR7ISFqYW4xfSwgRGVjIDMxIHByZXNlbnQ6ICR7ISFkZWMzMX1gKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGdyaWQgaXMgNTIgb3IgNTMgd2Vla3MgKHN0YW5kYXJkIGZvciBhIHllYXIpXG4gICAgICAgIGNvbnN0IGlzU3RhbmRhcmRTaXplID0gdG90YWxXZWVrcyA+PSA1MiAmJiB0b3RhbFdlZWtzIDw9IDUzO1xuICAgICAgICBjb25zb2xlLmxvZyhgR3JpZCBzaXplIGNoZWNrOiAke2lzU3RhbmRhcmRTaXplID8gJ1BBU1NFRCcgOiAnRkFJTEVEJ30gLSAke3RvdGFsV2Vla3N9IHdlZWtzIChzaG91bGQgYmUgNTItNTMpYCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzaXplOiB0b3RhbFdlZWtzLFxuICAgICAgICAgICAgZGF5c0luWWVhcjogZGF5c0luQ3VycmVudFllYXIsXG4gICAgICAgICAgICBoYXNKYW4xOiAhIWphbjEsXG4gICAgICAgICAgICBoYXNEZWMzMTogISFkZWMzMSxcbiAgICAgICAgICAgIGlzQ29ycmVjdFNpemU6IGlzU3RhbmRhcmRTaXplXG4gICAgICAgIH07XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIEJ1aWxkIGdyaWQ6IGdyaWRbY29sXVtyb3ddID0gZGF0ZSBvciBudWxsXG4gICAgLy8gQ29sID0gd2VlaywgUm93ID0gd2Vla2RheVxuICAgIGNvbnN0IGdyaWQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIC8vIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBkYXRlcyBmb3IgdGhlIHllYXJcbiAgICAgICAgY29uc3QgamFuMSA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMSk7XG4gICAgICAgIGNvbnN0IGRlYzMxID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpO1xuICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBTdW5kYXkgYmVmb3JlIG9yIG9uIEphbiAxXG4gICAgICAgIGNvbnN0IGZpcnN0RGF5T2ZHcmlkID0gbmV3IERhdGUoamFuMSk7XG4gICAgICAgIGNvbnN0IGZpcnN0RGF5T2ZXZWVrID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShmaXJzdERheU9mR3JpZCk7XG4gICAgICAgIGZpcnN0RGF5T2ZHcmlkLnNldERhdGUoZmlyc3REYXlPZkdyaWQuZ2V0RGF0ZSgpIC0gZmlyc3REYXlPZldlZWspO1xuICAgICAgICAvLyBGaW5kIHRoZSBsYXN0IFNhdHVyZGF5IGFmdGVyIG9yIG9uIERlYyAzMVxuICAgICAgICBjb25zdCBsYXN0RGF5T2ZHcmlkID0gbmV3IERhdGUoZGVjMzEpO1xuICAgICAgICBjb25zdCBsYXN0RGF5T2ZXZWVrID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShsYXN0RGF5T2ZHcmlkKTtcbiAgICAgICAgbGFzdERheU9mR3JpZC5zZXREYXRlKGxhc3REYXlPZkdyaWQuZ2V0RGF0ZSgpICsgKDYgLSBsYXN0RGF5T2ZXZWVrKSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgbnVtYmVyIG9mIHdlZWtzXG4gICAgICAgIGNvbnN0IHRvdGFsV2Vla3MgPSBNYXRoLmNlaWwoKGxhc3REYXlPZkdyaWQuZ2V0VGltZSgpIC0gZmlyc3REYXlPZkdyaWQuZ2V0VGltZSgpKSAvICg3ICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGdyaWQgd2l0aCB0aGUgY29ycmVjdCBudW1iZXIgb2Ygd2Vla3NcbiAgICAgICAgY29uc3QgbmV3R3JpZCA9IFtdO1xuICAgICAgICAvLyBTdGFydCB3aXRoIHRoZSBmaXJzdCBkYXkgb2YgdGhlIGdyaWRcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoZmlyc3REYXlPZkdyaWQpO1xuICAgICAgICAvLyBHZW5lcmF0ZSBhbGwgd2Vla3NcbiAgICAgICAgZm9yIChsZXQgd2VlayA9IDA7IHdlZWsgPCB0b3RhbFdlZWtzOyB3ZWVrKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHdlZWtSb3cgPSBbXTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGRheXMgZm9yIGVhY2ggd2Vla1xuICAgICAgICAgICAgZm9yIChsZXQgZGF5ID0gMDsgZGF5IDwgNzsgZGF5KyspIHtcbiAgICAgICAgICAgICAgICB3ZWVrUm93LnB1c2gobmV3IERhdGUoY3VycmVudERhdGUpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3R3JpZC5wdXNoKHdlZWtSb3cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIERlY2VtYmVyIDMxc3QgaXMgaW5jbHVkZWQgaW4gdGhlIGdyaWRcbiAgICAgICAgY29uc3QgaGFzRGVjMzEgPSBuZXdHcmlkLmZsYXQoKS5zb21lKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSAxMSAmJiBkYXRlLmdldERhdGUoKSA9PT0gMzEpO1xuICAgICAgICAvLyBJZiBEZWNlbWJlciAzMXN0IGlzIG1pc3NpbmcsIGFkZCBhZGRpdGlvbmFsIHdlZWtzIHVudGlsIHdlIGluY2x1ZGUgaXRcbiAgICAgICAgaWYgKCFoYXNEZWMzMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBEZWNlbWJlciAzMXN0LCAke3NlbGVjdGVkWWVhcn0gaXMgbWlzc2luZyBmcm9tIHRoZSBncmlkLiBFeHRlbmRpbmcgZ3JpZC5gKTtcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgICAgICAgICBsZXQgYWRkaXRpb25hbERhdGUgPSBuZXcgRGF0ZShjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICAvLyBBZGQgdXAgdG8gNCBhZGRpdGlvbmFsIHdlZWtzIChzaG91bGQgYmUgZW5vdWdoIGluIGFsbCBjYXNlcylcbiAgICAgICAgICAgIGZvciAobGV0IHdlZWsgPSAwOyB3ZWVrIDwgNDsgd2VlaysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vla1JvdyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGRheSA9IDA7IGRheSA8IDc7IGRheSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtSb3cucHVzaChuZXcgRGF0ZShhZGRpdGlvbmFsRGF0ZSkpO1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsRGF0ZS5zZXREYXRlKGFkZGl0aW9uYWxEYXRlLmdldERhdGUoKSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSd2ZSBub3cgaW5jbHVkZWQgRGVjZW1iZXIgMzFzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25hbERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzRGVjMzFOb3cgPSBuZXdHcmlkLmZsYXQoKS5jb25jYXQod2Vla1Jvdykuc29tZShkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMTEgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDMxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNEZWMzMU5vdykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0dyaWQucHVzaCh3ZWVrUm93KTtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBEZWNlbWJlciAzMXN0IGlzIG5vdyBpbiB0aGUgZ3JpZCBhZnRlciBhZGRpbmcgdGhpcyB3ZWVrXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGFpbnNEZWMzMSA9IG5ld0dyaWQuZmxhdCgpLnNvbWUoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDExICYmIGRhdGUuZ2V0RGF0ZSgpID09PSAzMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zRGVjMzEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYEdyaWQgZXh0ZW5kZWQuIERlY2VtYmVyIDMxc3QsICR7c2VsZWN0ZWRZZWFyfSBpcyBub3cgaW5jbHVkZWQuYCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDb3VudCBkYXlzIGluIHRoZSBjdXJyZW50IHllYXIgZm9yIGRlYnVnZ2luZ1xuICAgICAgICBjb25zdCBkYXlzSW5ZZWFyID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxLCAyOSkuZ2V0RGF0ZSgpID09PSAyOSA/IDM2NiA6IDM2NTtcbiAgICAgICAgY29uc3QgZGF5c0luQ3VycmVudFllYXIgPSBuZXdHcmlkLmZsYXQoKS5maWx0ZXIoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhcikubGVuZ3RoO1xuICAgICAgICAvLyBMb2cgZGVidWcgaW5mb1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2FsZW5kYXIgZ3JpZCBmb3IgJHtzZWxlY3RlZFllYXJ9OiAke25ld0dyaWQubGVuZ3RofSB3ZWVrcyAoJHtuZXdHcmlkLmxlbmd0aH14NyksICR7ZGF5c0luQ3VycmVudFllYXJ9LyR7ZGF5c0luWWVhcn0gZGF5cyBpbiB5ZWFyYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBGaXJzdCBkYXRlIGluIGdyaWQ6ICR7KDAsIGRhdGVfZm5zXzEuZm9ybWF0KShuZXdHcmlkWzBdWzBdLCAneXl5eS1NTS1kZCcpfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgTGFzdCBkYXRlIGluIGdyaWQ6ICR7KDAsIGRhdGVfZm5zXzEuZm9ybWF0KShuZXdHcmlkW25ld0dyaWQubGVuZ3RoIC0gMV1bNl0sICd5eXl5LU1NLWRkJyl9YCk7XG4gICAgICAgIHJldHVybiBuZXdHcmlkO1xuICAgIH0sIFtzZWxlY3RlZFllYXJdKTtcbiAgICAvLyBEZWZpbmUgZHluYW1pYyBjZWxsIHNpemUgYmFzZWQgb24gYXZhaWxhYmxlIHdpZHRoXG4gICAgY29uc3QgY2FsY3VsYXRlQ2VsbFNpemUgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgYXZhaWxhYmxlIHdpZHRoLCBhY2NvdW50aW5nIGZvciBwYWRkaW5nIGFuZCBsYWJlbHNcbiAgICAgICAgY29uc3QgaXNTbWFsbFNjcmVlbiA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNjAwO1xuICAgICAgICBjb25zdCBpc01lZGl1bVNjcmVlbiA9IHdpbmRvdy5pbm5lcldpZHRoID49IDYwMCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA8IDk2MDtcbiAgICAgICAgLy8gUmVkdWNlIHBhZGRpbmcgb24gc21hbGxlciBzY3JlZW5zIHRvIG1heGltaXplIHNwYWNlIGZvciB0aGUgZ3JpZFxuICAgICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gaXNTbWFsbFNjcmVlbiA/IDIwIDogaXNNZWRpdW1TY3JlZW4gPyA0MCA6IDYwO1xuICAgICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IE1hdGgubWluKHdpbmRvdy5pbm5lcldpZHRoIC0gY29udGFpbmVyUGFkZGluZywgMTEwMCk7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHdlZWtkYXkgbGFiZWxzXG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVdpZHRoID0gYXZhaWxhYmxlV2lkdGggLSBXRUVLREFZX0xBQkVMX1dJRFRIO1xuICAgICAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIGJhc2VkIG9uIGF2YWlsYWJsZSB3aWR0aCBhbmQgdG90YWwgd2Vla3NcbiAgICAgICAgLy8gV2UgbmVlZCB0byBmaXQgYWxsIDUzIHdlZWtzIChtYXggaW4gYSB5ZWFyKSBwbHVzIGdhcHNcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IGdyaWQubGVuZ3RoO1xuICAgICAgICBjb25zdCB0b3RhbEdhcHMgPSB0b3RhbFdlZWtzIC0gMTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNlbGwgc2l6ZVxuICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IChlZmZlY3RpdmVXaWR0aCAtICh0b3RhbEdhcHMgKiBDRUxMX0dBUCkpIC8gdG90YWxXZWVrcztcbiAgICAgICAgLy8gQ2xhbXAgdG8gcmVhc29uYWJsZSBzaXplIHJhbmdlXG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihNYXRoLmZsb29yKGNlbGxTaXplICogMTApIC8gMTAsIDEwKSwgMi44KTtcbiAgICB9LCBbZ3JpZF0pO1xuICAgIC8vIENhbGN1bGF0ZSBjZWxsIHNpemUgYW5kIHVwZGF0ZSBvbiB3aW5kb3cgcmVzaXplXG4gICAgY29uc3QgW0NFTExfU0laRSwgc2V0Q2VsbFNpemVdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCgpID0+IGNhbGN1bGF0ZUNlbGxTaXplKCkpO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoKCkgPT4ge1xuICAgICAgICAvLyBVcGRhdGUgY2VsbCBzaXplIG9uIHdpbmRvdyByZXNpemVcbiAgICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q2VsbFNpemUoY2FsY3VsYXRlQ2VsbFNpemUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEluaXRpYWwgY2FsY3VsYXRpb25cbiAgICAgICAgc2V0Q2VsbFNpemUoY2FsY3VsYXRlQ2VsbFNpemUoKSk7XG4gICAgICAgIC8vIERlYnVnIGdyaWQgaW5mb3JtYXRpb25cbiAgICAgICAgZGVidWdHcmlkSW5mbyhncmlkKTtcbiAgICAgICAgLy8gQWRkIHJlc2l6ZSBldmVudCBsaXN0ZW5lclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGN1bGF0ZUNlbGxTaXplLCBncmlkLCBkZWJ1Z0dyaWRJbmZvXSk7XG4gICAgLy8gU2ltcGxlIG1vbnRoIGxhYmVscyBwb3NpdGlvbmVkIGF0IGV4YWN0IDQtY29sdW1uIGludGVydmFsc1xuICAgIGNvbnN0IG1vbnRoTGFiZWxzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICAvLyBEZWZpbmUgdGhlIG1vbnRoIG5hbWVzXG4gICAgICAgIGNvbnN0IG1vbnRoTmFtZXMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ107XG4gICAgICAgIC8vIEZpbmQgY29sdW1uIHBvc2l0aW9ucyBmb3IgdGhlIGZpcnN0IGRheSBvZiBlYWNoIG1vbnRoXG4gICAgICAgIGNvbnN0IG1vbnRoQ29sdW1uUG9zaXRpb25zID0gW107XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG1vbnRoIG9mIHRoZSBzZWxlY3RlZCB5ZWFyXG4gICAgICAgIGZvciAobGV0IG1vbnRoID0gMDsgbW9udGggPCAxMjsgbW9udGgrKykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCBtb250aCwgMSk7XG4gICAgICAgICAgICAvLyBGaW5kIHRoaXMgZGF0ZSBpbiB0aGUgZ3JpZCB0byBnZXQgaXRzIGNvbHVtblxuICAgICAgICAgICAgbGV0IGNvbHVtbkZvdW5kID0gLTE7XG4gICAgICAgICAgICAvLyBTZWFyY2ggdGhyb3VnaCB0aGUgZ3JpZCB0byBmaW5kIHRoZSBjb2x1bW4gY29udGFpbmluZyB0aGlzIGRhdGVcbiAgICAgICAgICAgIGZvciAobGV0IGNvbElkeCA9IDA7IGNvbElkeCA8IGdyaWQubGVuZ3RoOyBjb2xJZHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IGdyaWRbY29sSWR4XS5sZW5ndGg7IHJvd0lkeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyaWREYXRlID0gZ3JpZFtjb2xJZHhdW3Jvd0lkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChncmlkRGF0ZS5nZXRGdWxsWWVhcigpID09PSBmaXJzdERheU9mTW9udGguZ2V0RnVsbFllYXIoKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZERhdGUuZ2V0TW9udGgoKSA9PT0gZmlyc3REYXlPZk1vbnRoLmdldE1vbnRoKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWREYXRlLmdldERhdGUoKSA9PT0gZmlyc3REYXlPZk1vbnRoLmdldERhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uRm91bmQgPSBjb2xJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uRm91bmQgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGZvdW5kLCBhZGQgdG8gb3VyIHBvc2l0aW9ucyBhcnJheVxuICAgICAgICAgICAgaWYgKGNvbHVtbkZvdW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG1vbnRoQ29sdW1uUG9zaXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtb250aDogbW9udGhOYW1lc1ttb250aF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sdW1uRm91bmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9udGhDb2x1bW5Qb3NpdGlvbnM7XG4gICAgfSwgW2dyaWQsIHNlbGVjdGVkWWVhcl0pO1xuICAgIGNvbnN0IGlzSGFiaXRDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlU3RyZWFrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgbGV0IHN0cmVhayA9IDA7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgd2hpbGUgKGlzSGFiaXRDb21wbGV0ZWQoY3VycmVudERhdGUpICYmICEoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShjdXJyZW50RGF0ZSwgdG9kYXkpKSB7XG4gICAgICAgICAgICBzdHJlYWsrKztcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhaztcbiAgICB9LCBbaXNIYWJpdENvbXBsZXRlZF0pO1xuICAgIGNvbnN0IGhhbmRsZUxvZ1N1Ym1pdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIC8vIEZvciBoYWJpdHMgdGhhdCB0cmFjayBxdWFudGl0eSwgdXNlIHRoZSBxdWFudGl0eSB2YWx1ZVxuICAgICAgICBpZiAoaGFiaXQudHJhY2tRdWFudGl0eSkge1xuICAgICAgICAgICAgaWYgKHF1YW50aXR5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSwgTnVtYmVyKHF1YW50aXR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3Igbm9uLXF1YW50aXR5IGhhYml0cywgYWx3YXlzIG1hcmsgYXMgY29tcGxldGVkXG4gICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICB9XG4gICAgICAgIHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgIHNldFF1YW50aXR5KCcnKTtcbiAgICAgICAgc2V0VXNlQ2hlY2tib3godHJ1ZSk7XG4gICAgfSwgW2hhYml0LnRyYWNrUXVhbnRpdHksIHNlbGVjdGVkRGF0ZSwgcXVhbnRpdHksIG9uVG9nZ2xlQ29tcGxldGlvbl0pO1xuICAgIGNvbnN0IGhhbmRsZURheUNsaWNrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXkpID0+IHtcbiAgICAgICAgaWYgKCgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGRheSwgbmV3IERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgYWxsb3cgbG9nZ2luZyBmdXR1cmUgZGF0ZXNcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF5KTtcbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBjYWxjdWxhdGVTdHJlYWsoKSwgW2NhbGN1bGF0ZVN0cmVha10pO1xuICAgIGNvbnN0IGlzRGF5Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIGNvbnN0IGhhbmRsZVByZXZZZWFyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRZZWFyKHByZXYgPT4gcHJldiAtIDEpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBoYW5kbGVOZXh0WWVhciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkWWVhcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICB9LCBbXSk7XG4gICAgLy8gR2V0IGNvbXBsZXRpb24gZm9yIGEgc3BlY2lmaWMgZGF0ZVxuICAgIGNvbnN0IGdldENvbXBsZXRpb24gPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0ZVN0ciA9ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKTtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLmZpbmQoYyA9PiBjLmRhdGUgPT09IGRhdGVTdHIpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5QYXBlciwgeyBlbGV2YXRpb246IDAsIHN4OiB7XG4gICAgICAgICAgICBwOiB7IHhzOiAxLCBzbTogMS41LCBtZDogMiB9LFxuICAgICAgICAgICAgcGI6IDEuNSxcbiAgICAgICAgICAgIG1iOiAzLFxuICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgID8gJzAgM3B4IDEwcHggcmdiYSgwLDAsMCwwLjM1KSdcbiAgICAgICAgICAgICAgICA6ICcwIDNweCAxMHB4IHJnYmEoMCwwLDAsMC4wOCknLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIG14OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgIG1iOiAxLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dZOiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJoNVwiLCBhbGlnbjogXCJjZW50ZXJcIiwgbm9XcmFwOiB0cnVlLCB0aXRsZTogaGFiaXQubmFtZSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogJzAuMDFlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMS4zcmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMC43NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJy0ycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGhhYml0Lm5hbWUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlUHJldlllYXIsIHN4OiB7IGNvbG9yOiAndGV4dC5wcmltYXJ5JywgcDogMC43IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQ2hldnJvbkxlZnQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXg6IDAuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5wcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC45cmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogc2VsZWN0ZWRZZWFyIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIG9uQ2xpY2s6IGhhbmRsZU5leHRZZWFyLCBkaXNhYmxlZDogc2VsZWN0ZWRZZWFyID49IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgc3g6IHsgY29sb3I6ICd0ZXh0LnByaW1hcnknLCBwOiAwLjcgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5DaGV2cm9uUmlnaHQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogMC43IH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IGBDdXJyZW50IHN0cmVhazogJHtzdHJlYWt9IGRheXNgLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjlyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbXCJcXHVEODNEXFx1REQyNSBcIiwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBzdHlsZTogeyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6ICczcHgnIH0sIGNoaWxkcmVuOiBzdHJlYWsgfSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHNpemU6IFwic21hbGxcIiwgc3RhcnRJY29uOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQWRkLCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSksIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHk6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDEuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICc1NXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjhyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBgJHtoYWJpdC5jb2xvcn05OWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogYCR7aGFiaXQuY29sb3J9Y2NgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFwiTG9nXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgY29sb3I6IFwiZXJyb3JcIiwgb25DbGljazogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKHRydWUpLCBzeDogeyBwOiAwLjcgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5EZWxldGUsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLCAvLyBDZW50ZXIgdGhlIGNhbGVuZGFyIGhvcml6b250YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke2dyaWQubGVuZ3RoID4gNTMgPyAwLjk1IDogMX0pYCwgLy8gU2xpZ2h0IHNjYWxlIGRvd24gaWYgbWFueSB3ZWVrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogJ2NlbnRlciB0b3AnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBgY2FsYygke2dyaWQubGVuZ3RoICogKENFTExfU0laRSArIENFTExfR0FQKX1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1sOiBgJHtXRUVLREFZX0xBQkVMX1dJRFRIfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnIC8vIEFsbG93IGxhYmVscyB0byBiZSB2aXNpYmxlIGlmIHRoZXkgZXh0ZW5kIGJleW9uZCBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IG1vbnRoTGFiZWxzLm1hcCgobGFiZWwsIGlkeCkgPT4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7bGFiZWwuY29sICogKENFTExfU0laRSArIENFTExfR0FQKX1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBDRUxMX1NJWkUsIC8vIE1hdGNoIGNlbGwgd2lkdGggZXhhY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknLCAvLyBDZW50ZXIgcHJlY2lzZWx5IG92ZXIgdGhlIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC42NXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQucHJpbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnNjAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDgpJyA6ICdyZ2JhKDAsMCwwLDAuMDQpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHk6IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICdyZ2JhKDAsMCwwLDAuMDgpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLCAvLyBQcmV2ZW50IHRleHQgd3JhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLCAvLyBGb3IgcHJlY2lzZSBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyIC8vIEVuc3VyZSBsYWJlbCBpcyBhYm92ZSB2ZXJ0aWNhbCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBsYWJlbC5tb250aCB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUgKiA3ICsgKENFTExfR0FQICogNiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjE1KScgOiAncmdiYSgwLDAsMCwwLjEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAwLjRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KV0gfSwgaWR4KSkpIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weCByZXBlYXQoJHtncmlkLmxlbmd0aH0sICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkVGVtcGxhdGVSb3dzOiBgcmVwZWF0KDcsICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IENFTExfR0FQLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLCAvLyBDZW50ZXIgdGhlIGdyaWQgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnMXB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1swLCAxLCAyLCAzLCA0LCA1LCA2XS5tYXAoKHdlZWtkYXkpID0+ICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHdlZWtkYXkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5U2VsZjogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByOiAwLjMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBXRUVLREFZX0xBQkVMX1dJRFRIIC0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBtb2RlID09PSAnZGFyaycgPyAnYmFja2dyb3VuZC5wYXBlcicgOiAnYmFja2dyb3VuZC5wYXBlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogQ0VMTF9TSVpFIDwgNCA/ICcwLjVyZW0nIDogJzAuNTVyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXVt3ZWVrZGF5XSB9KSB9LCB3ZWVrZGF5KSkpLCBncmlkLm1hcCgod2Vla0NvbHVtbiwgY29sSWR4KSA9PiAod2Vla0NvbHVtbi5tYXAoKGRheSwgcm93SWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBkYXRlIGZvciB0aGlzIGNlbGwgcG9zaXRpb24gZnJvbSBvdXIgZ3JpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2VsbCdzIGRhdGUgaXMgaW4gdGhlIGN1cnJlbnQgeWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5DdXJyZW50WWVhciA9IGNlbGxEYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBmaXJzdCBkYXkgb2YgYSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRmlyc3REYXlPZk1vbnRoID0gY2VsbERhdGUuZ2V0RGF0ZSgpID09PSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29tcGxldGVkID0gaXNEYXlDb21wbGV0ZWQoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnV0dXJlID0gKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoY2VsbERhdGUsIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudERheSA9ICgwLCBkYXRlX2Zuc18xLmlzVG9kYXkpKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY29tcGxldGlvbiBkZXRhaWxzIGZvciB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IGdldENvbXBsZXRpb24oY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBkYXRlIGZvciB0b29sdGlwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRGF0ZSA9ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoY2VsbERhdGUsICdFRUVFLCBNTU1NIGQsIHl5eXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sdGlwQ29udGVudCA9IGlzSW5DdXJyZW50WWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChpc0NvbXBsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtmb3JtYXR0ZWREYXRlfSR7Y29tcGxldGlvbj8ucXVhbnRpdHkgPyBgIOKAoiAke2NvbXBsZXRpb24ucXVhbnRpdHl9ICR7aGFiaXQudW5pdCB8fCAndW5pdHMnfWAgOiAnIOKAoiBDb21wbGV0ZWQnfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZm9ybWF0dGVkRGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSBjZWxsIGJvcmRlciBiYXNlZCBvbiBjZWxsIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IENFTExfU0laRSA+IDUgPyAxIDogMC41O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IHRvb2x0aXBDb250ZW50LCBwbGFjZW1lbnQ6IFwidG9wXCIsIGVudGVyRGVsYXk6IDUwMCwgYXJyb3c6IHRydWUsIGRpc2FibGVIb3Zlckxpc3RlbmVyOiAhaXNJbkN1cnJlbnRZZWFyLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IGNvbElkeCArIDIsIC8vICsyIGJlY2F1c2UgZmlyc3QgY29sdW1uIGlzIGZvciB3ZWVrZGF5IGxhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHJvd0lkeCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBpc0NvbXBsZXRlZCAmJiBpc0luQ3VycmVudFllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBoYWJpdC5jb2xvciArIChtb2RlID09PSAnZGFyaycgPyAnY2MnIDogJ2JiJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGlzSW5DdXJyZW50WWVhciA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDUpJyA6ICdyZ2JhKDAsMCwwLDApJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGlzSW5DdXJyZW50WWVhciA/ICd0cmFuc3BhcmVudCcgOiAncmdiYSgwLDAsMCwwKScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogaXNJbkN1cnJlbnRZZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7Ym9yZGVyV2lkdGh9cHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAnIzQ0NCcgOiAnI2UwZTBlMCd9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IENFTExfU0laRSA+IDUgPyAnMXB4JyA6ICcwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogKGlzRnV0dXJlIHx8ICFpc0luQ3VycmVudFllYXIpID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzRnV0dXJlID8gMC4zIDogKGlzSW5DdXJyZW50WWVhciA/IDEgOiAwLjIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMnMsIHRyYW5zZm9ybSAwLjE1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGZpcnN0IGRheSBvZiBlYWNoIG1vbnRoIHdpdGggc3Ryb25nZXIgYm9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyTGVmdDogaXNGaXJzdERheU9mTW9udGggJiYgaXNJbkN1cnJlbnRZZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7Ym9yZGVyV2lkdGggKyAwLjV9cHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuNCknfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGlnaGxpZ2h0IGN1cnJlbnQgZGF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGlzQ3VycmVudERheSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogYDAgMCAwICR7Ym9yZGVyV2lkdGggKyAwLjV9cHggJHtoYWJpdC5jb2xvcn1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG92ZXIgZWZmZWN0IGZvciBsYXJnZXIgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IENFTExfU0laRSA+IDQgJiYgaXNJbkN1cnJlbnRZZWFyICYmICFpc0Z1dHVyZSA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMS4yKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogYDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMilgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBpc0NvbXBsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBoYWJpdC5jb2xvciArICdlZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZSA9PT0gJ2RhcmsnID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4xNSknIDogJ3JnYmEoMCwwLDAsMC4wNSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25DbGljazogKCkgPT4gaXNJbkN1cnJlbnRZZWFyICYmICFpc0Z1dHVyZSAmJiBoYW5kbGVEYXlDbGljayhjZWxsRGF0ZSksIG9uTW91c2VFbnRlcjogKCkgPT4gc2V0SG92ZXJlZERhdGUoY2VsbERhdGUpLCBvbk1vdXNlTGVhdmU6ICgpID0+IHNldEhvdmVyZWREYXRlKG51bGwpIH0pIH0sIGBjZWxsLSR7Y29sSWR4fS0ke3Jvd0lkeH1gKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpXSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0xvZ0RpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgUGFwZXJQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjUpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjEyKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHtoYWJpdC5jb2xvcn0gMzAlLCAke2hhYml0LmNvbG9yfTk5IDkwJSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1wiTG9nIFwiLCBoYWJpdC5uYW1lXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgc3g6IHsgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBtdDogMiB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcInN1YnRpdGxlMlwiLCBndXR0ZXJCb3R0b206IHRydWUsIGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogW1wiRGF0ZTogXCIsICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAnTU1NTSBkLCB5eXl5JyldIH0pLCAhaGFiaXQudHJhY2tRdWFudGl0eSA/ICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRm9ybUNvbnRyb2xMYWJlbCwgeyBjb250cm9sOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQ2hlY2tib3gsIHsgY2hlY2tlZDogdXNlQ2hlY2tib3gsIG9uQ2hhbmdlOiAoZSkgPT4gc2V0VXNlQ2hlY2tib3goZS50YXJnZXQuY2hlY2tlZCksIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYuTXVpLWNoZWNrZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBsYWJlbDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBcIk1hcmsgYXMgY29tcGxldGVkXCIgfSkgfSkpIDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgaGFiaXRzIHRoYXQgdHJhY2sgcXVhbnRpdHksIGFsd2F5cyBzaG93IHRoZSBxdWFudGl0eSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVGV4dEZpZWxkLCB7IGZ1bGxXaWR0aDogdHJ1ZSwgdHlwZTogXCJudW1iZXJcIiwgbGFiZWw6IGBRdWFudGl0eSR7aGFiaXQudW5pdCA/IGAgKCR7aGFiaXQudW5pdH0pYCA6ICcnfWAsIHZhbHVlOiBxdWFudGl0eSwgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgKE51bWJlcih2YWwpID49IDAgJiYgTnVtYmVyKHZhbCkgPD0gMTAwMDAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UXVhbnRpdHkodmFsID09PSAnJyA/ICcnIDogTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgLk11aU91dGxpbmVkSW5wdXQtcm9vdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYuTXVpLWZvY3VzZWQgZmllbGRzZXQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiAuTXVpSW5wdXRMYWJlbC1yb290Lk11aS1mb2N1c2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGlucHV0UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAxMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ0FjdGlvbnMsIHsgc3g6IHsgcHg6IDMsIHB5OiAyLCBib3JkZXJUb3A6ICcxcHggc29saWQnLCBib3JkZXJDb2xvcjogJ2RpdmlkZXInLCBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJDYW5jZWxcIiB9KSwgaXNEYXlDb21wbGV0ZWQoc2VsZWN0ZWREYXRlKSAmJiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBjb2xvcjogXCJ3YXJuaW5nXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiVW5kb1wiIH0pKSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiBoYW5kbGVMb2dTdWJtaXQsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIGRpc2FibGVkOiBoYWJpdC50cmFja1F1YW50aXR5ICYmIHF1YW50aXR5ID09PSAnJywgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAke2hhYml0LmNvbG9yfSAzMCUsICR7aGFiaXQuY29sb3J9OTkgOTAlKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IGAwIDNweCA1cHggMnB4ICR7aGFiaXQuY29sb3J9MzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJTYXZlXCIgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2csIHsgb3BlbjogaXNEZWxldGVEaWFsb2dPcGVuLCBvbkNsb3NlOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBtYXhXaWR0aDogXCJ4c1wiLCBmdWxsV2lkdGg6IHRydWUsIFBhcGVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC4xMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJyMzYTA1MDUnIDogJyNmZmViZWUnLCAvLyBEYXJrL2xpZ2h0IHJlZCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICcjZmY1MjUyJyA6ICcjZDMyZjJmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkRlbGV0ZSBIYWJpdFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nQ29udGVudCwgeyBzeDogeyBtdDogMiwgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBbXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIFxcXCJcIiwgaGFiaXQubmFtZSwgXCJcXFwiPyBUaGlzIGFjdGlvbiBjYW5ub3QgYmUgdW5kb25lLlwiXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbG9yOiBcImVycm9yXCIsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJEZWxldGVcIiB9KV0gfSldIH0pXSB9KSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFiaXRDYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});