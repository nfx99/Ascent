"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const isSmallScreen = (0, material_1.useMediaQuery)(muiTheme.breakpoints.down('sm'));\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    const [hoveredDate, setHoveredDate] = (0, react_1.useState)(null);\n    // Define constants first\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 15; // Smaller width for weekday labels\n    // Debug function to log grid information\n    const debugGridInfo = (0, react_1.useCallback)((grid) => {\n        const totalWeeks = grid.length;\n        const daysInFullYear = new Date(selectedYear, 0, 0).getDate() === 366 ? 366 : 365;\n        const daysInCurrentYear = grid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        const jan1 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 0 && date.getDate() === 1);\n        const dec31 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        console.log(`Grid for ${selectedYear}: ${totalWeeks} weeks Ã— 7 days`);\n        console.log(`Days in year: ${daysInFullYear}, days displayed from year: ${daysInCurrentYear}`);\n        console.log(`Jan 1 present: ${!!jan1}, Dec 31 present: ${!!dec31}`);\n        // Check if the grid is 52 or 53 weeks (standard for a year)\n        const isStandardSize = totalWeeks >= 52 && totalWeeks <= 53;\n        console.log(`Grid size check: ${isStandardSize ? 'PASSED' : 'FAILED'} - ${totalWeeks} weeks (should be 52-53)`);\n        return {\n            size: totalWeeks,\n            daysInYear: daysInCurrentYear,\n            hasJan1: !!jan1,\n            hasDec31: !!dec31,\n            isCorrectSize: isStandardSize\n        };\n    }, [selectedYear]);\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        // Get the start and end dates for the year\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // Find the first Sunday before or on Jan 1\n        const firstDayOfGrid = new Date(jan1);\n        const firstDayOfWeek = (0, date_fns_1.getDay)(firstDayOfGrid);\n        firstDayOfGrid.setDate(firstDayOfGrid.getDate() - firstDayOfWeek);\n        // Find the last Saturday after or on Dec 31\n        const lastDayOfGrid = new Date(dec31);\n        const lastDayOfWeek = (0, date_fns_1.getDay)(lastDayOfGrid);\n        lastDayOfGrid.setDate(lastDayOfGrid.getDate() + (6 - lastDayOfWeek));\n        // Calculate the total number of weeks\n        const totalWeeks = Math.ceil((lastDayOfGrid.getTime() - firstDayOfGrid.getTime()) / (7 * 24 * 60 * 60 * 1000));\n        // Create the grid with the correct number of weeks\n        const newGrid = [];\n        // Start with the first day of the grid\n        let currentDate = new Date(firstDayOfGrid);\n        // Generate all weeks\n        for (let week = 0; week < totalWeeks; week++) {\n            const weekRow = [];\n            // Generate days for each week\n            for (let day = 0; day < 7; day++) {\n                weekRow.push(new Date(currentDate));\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            newGrid.push(weekRow);\n        }\n        // Check if December 31st is included in the grid\n        const hasDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        // If December 31st is missing, add additional weeks until we include it\n        if (!hasDec31) {\n            console.warn(`December 31st, ${selectedYear} is missing from the grid. Extending grid.`);\n            // Continue where we left off\n            let additionalDate = new Date(currentDate);\n            // Add up to 4 additional weeks (should be enough in all cases)\n            for (let week = 0; week < 4; week++) {\n                const weekRow = [];\n                for (let day = 0; day < 7; day++) {\n                    weekRow.push(new Date(additionalDate));\n                    additionalDate.setDate(additionalDate.getDate() + 1);\n                    // Check if we've now included December 31st\n                    if (additionalDate.getFullYear() === selectedYear + 1) {\n                        const hasDec31Now = newGrid.flat().concat(weekRow).some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                        if (hasDec31Now) {\n                            break;\n                        }\n                    }\n                }\n                newGrid.push(weekRow);\n                // Check if December 31st is now in the grid after adding this week\n                const containsDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                if (containsDec31) {\n                    console.log(`Grid extended. December 31st, ${selectedYear} is now included.`);\n                    break;\n                }\n            }\n        }\n        // Count days in the current year for debugging\n        const daysInYear = new Date(selectedYear, 1, 29).getDate() === 29 ? 366 : 365;\n        const daysInCurrentYear = newGrid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        // Log debug info\n        console.log(`Calendar grid for ${selectedYear}: ${newGrid.length} weeks (${newGrid.length}x7), ${daysInCurrentYear}/${daysInYear} days in year`);\n        console.log(`First date in grid: ${(0, date_fns_1.format)(newGrid[0][0], 'yyyy-MM-dd')}`);\n        console.log(`Last date in grid: ${(0, date_fns_1.format)(newGrid[newGrid.length - 1][6], 'yyyy-MM-dd')}`);\n        return newGrid;\n    }, [selectedYear]);\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Calculate the smallest possible cell size that fits all weeks without scrolling\n        const availableWidth = Math.min(window.innerWidth - 50, 1200);\n        const weekdayLabelSpace = WEEKDAY_LABEL_WIDTH + 2;\n        // Calculate total weeks to display (should be 52 or 53)\n        const totalWeeks = grid.length;\n        // Calculate minimum cell size that would fill the available width\n        // Account for gaps between cells\n        const totalGapWidth = CELL_GAP * (totalWeeks - 1);\n        const widthForCells = availableWidth - weekdayLabelSpace - totalGapWidth;\n        const cellSize = Math.floor(widthForCells / totalWeeks);\n        // Use minimum size that ensures visibility but allows all cells to fit\n        const size = Math.max(cellSize, 3);\n        console.log(`Cell size calculation: ${totalWeeks} weeks, ${size}px per cell, available width: ${availableWidth}px`);\n        return size;\n    }, [grid]);\n    // Calculate cell size and update on window resize\n    const [CELL_SIZE, setCellSize] = (0, react_1.useState)(() => calculateCellSize());\n    (0, react_1.useEffect)(() => {\n        // Update cell size on window resize\n        const handleResize = () => {\n            setCellSize(calculateCellSize());\n        };\n        // Initial calculation\n        setCellSize(calculateCellSize());\n        // Debug grid information\n        debugGridInfo(grid);\n        // Add resize event listener\n        window.addEventListener('resize', handleResize);\n        // Cleanup\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        };\n    }, [calculateCellSize, grid, debugGridInfo]);\n    // Generate month labels based on actual cell dates\n    const monthLabels = (0, react_1.useMemo)(() => {\n        const labels = [];\n        // First, collect all month boundaries in the grid\n        for (let month = 0; month < 12; month++) {\n            // Find first day of each month in the selected year\n            const firstDayOfMonth = new Date(selectedYear, month, 1);\n            let firstCol = -1;\n            // Find columns for first day of this month\n            for (let colIdx = 0; colIdx < grid.length; colIdx++) {\n                for (let rowIdx = 0; rowIdx < 7; rowIdx++) {\n                    const cellDate = grid[colIdx][rowIdx];\n                    // Check for first day of month\n                    if (cellDate.getFullYear() === selectedYear &&\n                        cellDate.getMonth() === month &&\n                        cellDate.getDate() === 1) {\n                        firstCol = colIdx;\n                        break;\n                    }\n                }\n                if (firstCol !== -1)\n                    break;\n            }\n            // If we found the column for the first day of the month\n            if (firstCol !== -1) {\n                // Create label for the first day of the month\n                const monthAbbr = (0, date_fns_1.format)(firstDayOfMonth, 'MMM');\n                // Create the label object\n                labels.push({\n                    col: firstCol,\n                    month: monthAbbr,\n                    isStart: true,\n                    isEnd: false\n                });\n            }\n        }\n        // Check if we're missing any months\n        const monthsFound = labels.length;\n        if (monthsFound < 12) {\n            console.warn(`Only found ${monthsFound} months out of 12 in the grid.`);\n        }\n        // Sort labels by column\n        return labels.sort((a, b) => a.col - b.col);\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        // For habits that track quantity, use the quantity value\n        if (habit.trackQuantity) {\n            if (quantity !== '') {\n                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n            }\n        }\n        else {\n            // For non-quantity habits, always mark as completed\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [habit.trackQuantity, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    // Get completion for a specific date\n    const getCompletion = (0, react_1.useCallback)((date) => {\n        const dateStr = (0, date_fns_1.format)(date, 'yyyy-MM-dd');\n        return habit.completions.find(c => c.date === dateStr);\n    }, [habit.completions]);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2.5,\n            pb: 1.5,\n            mb: 3,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 3px 10px rgba(0,0,0,0.35)'\n                : '0 3px 10px rgba(0,0,0,0.08)',\n            width: '100%',\n            maxWidth: '100%',\n            overflowX: 'hidden'\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                    width: '100%',\n                    mx: 'auto',\n                    mb: 1,\n                    overflow: 'hidden'\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0.5,\n                            mb: 1.5,\n                            width: '100%',\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.01em',\n                            textShadow: mode === 'dark'\n                                ? '0 1px 2px rgba(0,0,0,0.3)'\n                                : '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.3rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.75,\n                            position: 'relative',\n                            '&::after': {\n                                content: '\"\"',\n                                position: 'absolute',\n                                bottom: '-2px',\n                                left: 0,\n                                width: '100%',\n                                borderBottom: `2px solid ${habit.color}33`,\n                            }\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            display: 'flex',\n                            justifyContent: 'space-between',\n                            alignItems: 'center',\n                            mb: 1,\n                            px: 1,\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: {\n                                                mx: 0.7,\n                                                fontWeight: 'bold',\n                                                color: 'text.primary',\n                                                fontSize: '0.9rem'\n                                            }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.7 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: {\n                                                display: 'flex',\n                                                alignItems: 'center',\n                                                fontSize: '0.9rem'\n                                            }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '3px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, { fontSize: \"small\" }), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.5,\n                                            px: 1.5,\n                                            minWidth: '55px',\n                                            fontSize: '0.8rem',\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), sx: { p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, { fontSize: \"small\" }) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            width: '100%',\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'flex-start',\n                            overflow: 'hidden',\n                            maxWidth: '100%',\n                            position: 'relative',\n                            mt: 0.5,\n                            mb: 0.5,\n                        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"caption\", sx: {\n                                    position: 'absolute',\n                                    top: 0,\n                                    right: 0,\n                                    fontSize: '0.6rem',\n                                    color: 'text.secondary',\n                                    opacity: 0.7\n                                }, children: [grid.length, \" wk \\u00D7 7 d\"] }), (0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                    display: 'flex',\n                                    alignItems: 'center',\n                                    mb: 0.3,\n                                    ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                    width: `calc(${grid.length * (CELL_SIZE + CELL_GAP)}px)`,\n                                    justifyContent: 'flex-start',\n                                    position: 'relative',\n                                    height: '16px', // Slightly taller height for labels\n                                    overflow: 'visible'\n                                }, children: monthLabels.map((label, idx) => {\n                                    // Calculate position to center it precisely above the first cell of the month\n                                    const position = label.col * (CELL_SIZE + CELL_GAP);\n                                    // Calculate available space before next label\n                                    const nextLabelCol = idx < monthLabels.length - 1 ? monthLabels[idx + 1].col : grid.length;\n                                    const availableWidth = (nextLabelCol - label.col) * (CELL_SIZE + CELL_GAP);\n                                    // Determine if we should center or left-align based on available space\n                                    const shouldCenter = availableWidth >= 40; // Only center if there's enough space\n                                    return ((0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                            position: 'absolute',\n                                            left: `${position}px`,\n                                            transform: shouldCenter ? 'translateX(0)' : 'translateX(0)', // Align to start of column\n                                            textAlign: shouldCenter ? 'center' : 'left',\n                                            zIndex: 2, // Ensure labels don't get overlapped\n                                            maxWidth: `${availableWidth}px`, // Limit width to available space\n                                            whiteSpace: 'nowrap',\n                                            overflow: 'hidden',\n                                            textOverflow: 'ellipsis'\n                                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    position: 'absolute',\n                                                    top: '14px',\n                                                    left: 0,\n                                                    width: '1px',\n                                                    height: CELL_SIZE * 7 + CELL_GAP * 6,\n                                                    bgcolor: mode === 'dark' ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)',\n                                                    display: CELL_SIZE >= 5 ? 'block' : 'none' // Only show for larger cells\n                                                } }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", noWrap: true, sx: {\n                                                    fontSize: '0.65rem', // Slightly larger font size\n                                                    color: 'text.secondary',\n                                                    fontWeight: 'bold',\n                                                    lineHeight: 1,\n                                                    display: 'inline-block',\n                                                    whiteSpace: 'nowrap',\n                                                    textOverflow: 'ellipsis',\n                                                    overflow: 'hidden',\n                                                    maxWidth: `${availableWidth}px`,\n                                                    pl: 0.5, // Add slight padding\n                                                }, children: label.month })] }, idx));\n                                }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    display: 'grid',\n                                    gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${grid.length}, ${CELL_SIZE}px)`,\n                                    gridTemplateRows: `repeat(7, ${CELL_SIZE}px)`,\n                                    gap: CELL_GAP,\n                                    mb: 0,\n                                    width: `${WEEKDAY_LABEL_WIDTH + (grid.length * (CELL_SIZE + CELL_GAP)) - CELL_GAP}px`,\n                                    maxWidth: '100%',\n                                    overflowX: 'hidden',\n                                    overflowY: 'hidden',\n                                    justifyContent: 'flex-start',\n                                    paddingBottom: '1px',\n                                    transform: 'scale(0.99)', // Slight scale down to ensure everything fits\n                                    transformOrigin: 'left top'\n                                }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            gridColumn: 1,\n                                            gridRow: weekday + 1,\n                                            justifySelf: 'end',\n                                            pr: 0.3,\n                                            width: WEEKDAY_LABEL_WIDTH - 2,\n                                            height: CELL_SIZE,\n                                            display: 'flex',\n                                            alignItems: 'center',\n                                            justifyContent: 'flex-end',\n                                            bgcolor: mode === 'dark' ? 'background.paper' : 'background.paper'\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                fontSize: '0.55rem',\n                                                color: 'text.secondary',\n                                                lineHeight: 1\n                                            }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), grid.map((weekColumn, colIdx) => (weekColumn.map((day, rowIdx) => {\n                                        // Get the date for this cell position from our grid\n                                        const cellDate = day;\n                                        // Check if this cell's date is in the current year\n                                        const isInCurrentYear = cellDate.getFullYear() === selectedYear;\n                                        // Check if this is the first day of a month\n                                        const isFirstDayOfMonth = cellDate.getDate() === 1;\n                                        // Determine month boundaries - last day of the month\n                                        const isLastDayOfMonth = (() => {\n                                            const nextDay = new Date(cellDate);\n                                            nextDay.setDate(cellDate.getDate() + 1);\n                                            return (0, date_fns_1.getMonth)(nextDay) !== (0, date_fns_1.getMonth)(cellDate);\n                                        })();\n                                        const isCompleted = isDayCompleted(cellDate);\n                                        const isFuture = (0, date_fns_1.isAfter)(cellDate, new Date());\n                                        const isCurrentDay = (0, date_fns_1.isToday)(cellDate);\n                                        // Get completion details for tooltip\n                                        const completion = getCompletion(cellDate);\n                                        // Format date for tooltip\n                                        const formattedDate = (0, date_fns_1.format)(cellDate, 'EEEE, MMMM d, yyyy');\n                                        // Tooltip content\n                                        const tooltipContent = isInCurrentYear\n                                            ? (isCompleted\n                                                ? `${formattedDate}${completion?.quantity ? ` â€¢ ${completion.quantity} ${habit.unit || 'units'}` : ' â€¢ Completed'}`\n                                                : formattedDate)\n                                            : '';\n                                        // Month boundary color\n                                        const monthBorderColor = mode === 'dark'\n                                            ? (isInCurrentYear ? 'rgba(255,255,255,0.5)' : 'rgba(255,255,255,0.2)')\n                                            : (isInCurrentYear ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.2)');\n                                        return ((0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: tooltipContent, placement: \"top\", enterDelay: 500, arrow: true, disableHoverListener: !isInCurrentYear || CELL_SIZE < 4, children: (0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    gridColumn: colIdx + 2, // +2 because first column is for weekday labels\n                                                    gridRow: rowIdx + 1,\n                                                    width: CELL_SIZE,\n                                                    height: CELL_SIZE,\n                                                    bgcolor: isCompleted && isInCurrentYear\n                                                        ? habit.color + (mode === 'dark' ? 'aa' : '99')\n                                                        : mode === 'dark'\n                                                            ? (isInCurrentYear ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)')\n                                                            : (isInCurrentYear ? 'transparent' : 'rgba(0,0,0,0.02)'),\n                                                    border: isCurrentDay\n                                                        ? `1px solid ${habit.color}`\n                                                        : `1px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`,\n                                                    // Simplified border styling for small cells\n                                                    ...(CELL_SIZE < 6 ? {} : (isInCurrentYear && {\n                                                        borderLeft: isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                        borderRight: isLastDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                        borderTop: rowIdx === 0 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                        borderBottom: rowIdx === 6 && isFirstDayOfMonth ? `2px solid ${monthBorderColor}` : undefined,\n                                                    })),\n                                                    borderRadius: CELL_SIZE < 6 ? '0px' : '1px',\n                                                    cursor: (isFuture || !isInCurrentYear) ? 'default' : 'pointer',\n                                                    opacity: isFuture ? 0.3 : (isInCurrentYear ? 1 : 0.3),\n                                                    transition: 'background-color 0.2s, transform 0.1s',\n                                                    '&:hover': isInCurrentYear && !isFuture ? {\n                                                        bgcolor: isCompleted\n                                                            ? habit.color + 'cc'\n                                                            : mode === 'dark' ? 'rgba(255,255,255,0.1)' : '#f5f5f5',\n                                                        transform: CELL_SIZE >= 6 ? 'scale(1.15)' : 'none', // Only scale up larger cells\n                                                        zIndex: 5,\n                                                    } : {},\n                                                    position: 'relative',\n                                                }, onClick: () => isInCurrentYear && !isFuture && handleDayClick(cellDate), onMouseEnter: () => setHoveredDate(cellDate), onMouseLeave: () => setHoveredDate(null) }) }, `cell-${colIdx}-${rowIdx}`));\n                                    })))] })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                            color: '#fff',\n                        }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), !habit.trackQuantity ? ((0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                            color: habit.color,\n                                            '&.Mui-checked': {\n                                                color: habit.color,\n                                            }\n                                        } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) })) : (\n                                // For habits that track quantity, always show the quantity field\n                                (0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: {\n                                        mt: 1,\n                                        '& .MuiOutlinedInput-root': {\n                                            '&.Mui-focused fieldset': {\n                                                borderColor: habit.color,\n                                            },\n                                        },\n                                        '& .MuiInputLabel-root.Mui-focused': {\n                                            color: habit.color,\n                                        },\n                                    }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: habit.trackQuantity && quantity === '', sx: {\n                                    borderRadius: '20px',\n                                    px: 2,\n                                    background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                    boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                            color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                        }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTSxPQUFPLDhEQUE4RCw2SUFBNkksaUZBQWlGLHVEQUF1RDtBQUMxaUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMERBQTBELHNEQUFzRCxHQUFHO0FBQzlKO0FBQ0EsK0VBQStFLG1EQUFtRCxrQkFBa0IsV0FBVyxRQUFRO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsdUNBQXVDLEtBQUssR0FBRyx1REFBdUQsTUFBTSwyRkFBMkYseURBQXlELGdEQUFnRCw2QkFBNkIsc0JBQXNCLGdGQUFnRjtBQUNuYjtBQUNBO0FBQ0EsaUNBQWlDLFFBQVEsNkJBQTZCLG9CQUFvQixnREFBZ0Q7QUFDMUk7QUFDQTtBQUNBLDBFQUEwRSxhQUFhLE9BQU8sWUFBWTtBQUMxRyxnRUFBZ0UsWUFBWTtBQUM1RSxpQ0FBaUMsb0JBQW9CLElBQUksSUFBSSxnREFBZ0Q7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4REFBOEQ7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEIsc0RBQXNELE1BQU0sb0NBQW9DLDZEQUE2RCwwSEFBMEgsR0FBRyx1REFBdUQsTUFBTSwyRkFBMkYseURBQXlELG1EQUFtRCw2QkFBNkIsc0JBQXNCLCtDQUErQztBQUNyckI7QUFDQTtBQUNBLGlDQUFpQyw4Q0FBOEMsNkJBQTZCLHNCQUFzQixJQUFJLElBQUksSUFBSTtBQUM5STtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYXNjZW50Ly4vc3JjL3JlbmRlcmVyL2NvbXBvbmVudHMvSGFiaXRDYXJkLnRzeD80M2UyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICAgICAgICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIHZhciBhciA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspKSBhclthci5sZW5ndGhdID0gaztcbiAgICAgICAgICAgIHJldHVybiBhcjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG93bktleXMobyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gICAgICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgbWF0ZXJpYWxfMSA9IHJlcXVpcmUoXCJAbXVpL21hdGVyaWFsXCIpO1xuY29uc3QgaWNvbnNfbWF0ZXJpYWxfMSA9IHJlcXVpcmUoXCJAbXVpL2ljb25zLW1hdGVyaWFsXCIpO1xuY29uc3QgZGF0ZV9mbnNfMSA9IHJlcXVpcmUoXCJkYXRlLWZuc1wiKTtcbmNvbnN0IFRoZW1lQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL2NvbnRleHQvVGhlbWVDb250ZXh0XCIpO1xuY29uc3Qgc3R5bGVzXzEgPSByZXF1aXJlKFwiQG11aS9tYXRlcmlhbC9zdHlsZXNcIik7XG5jb25zdCBIYWJpdENhcmQgPSAoeyBoYWJpdCwgb25Ub2dnbGVDb21wbGV0aW9uLCBvbkRlbGV0ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBtb2RlIH0gPSAoMCwgVGhlbWVDb250ZXh0XzEudXNlVGhlbWUpKCk7XG4gICAgY29uc3QgbXVpVGhlbWUgPSAoMCwgc3R5bGVzXzEudXNlVGhlbWUpKCk7XG4gICAgY29uc3QgaXNTbWFsbFNjcmVlbiA9ICgwLCBtYXRlcmlhbF8xLnVzZU1lZGlhUXVlcnkpKG11aVRoZW1lLmJyZWFrcG9pbnRzLmRvd24oJ3NtJykpO1xuICAgIGNvbnN0IFtpc0xvZ0RpYWxvZ09wZW4sIHNldElzTG9nRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RlbGV0ZURpYWxvZ09wZW4sIHNldElzRGVsZXRlRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RlZERhdGUsIHNldFNlbGVjdGVkRGF0ZV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKSk7XG4gICAgY29uc3QgW3F1YW50aXR5LCBzZXRRdWFudGl0eV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoJycpO1xuICAgIGNvbnN0IFt1c2VDaGVja2JveCwgc2V0VXNlQ2hlY2tib3hdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHRydWUpO1xuICAgIGNvbnN0IFtzZWxlY3RlZFllYXIsIHNldFNlbGVjdGVkWWVhcl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTtcbiAgICBjb25zdCBbaG92ZXJlZERhdGUsIHNldEhvdmVyZWREYXRlXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShudWxsKTtcbiAgICAvLyBEZWZpbmUgY29uc3RhbnRzIGZpcnN0XG4gICAgY29uc3QgQ0VMTF9HQVAgPSAxOyAvLyBNaW5pbXVtIGdhcCBmb3IgY29tcGFjdCBsYXlvdXRcbiAgICBjb25zdCBXRUVLREFZX0xBQkVMX1dJRFRIID0gMTU7IC8vIFNtYWxsZXIgd2lkdGggZm9yIHdlZWtkYXkgbGFiZWxzXG4gICAgLy8gRGVidWcgZnVuY3Rpb24gdG8gbG9nIGdyaWQgaW5mb3JtYXRpb25cbiAgICBjb25zdCBkZWJ1Z0dyaWRJbmZvID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChncmlkKSA9PiB7XG4gICAgICAgIGNvbnN0IHRvdGFsV2Vla3MgPSBncmlkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgZGF5c0luRnVsbFllYXIgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDAsIDApLmdldERhdGUoKSA9PT0gMzY2ID8gMzY2IDogMzY1O1xuICAgICAgICBjb25zdCBkYXlzSW5DdXJyZW50WWVhciA9IGdyaWQuZmxhdCgpLmZpbHRlcihkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGphbjEgPSBncmlkLmZsYXQoKS5maW5kKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSAwICYmIGRhdGUuZ2V0RGF0ZSgpID09PSAxKTtcbiAgICAgICAgY29uc3QgZGVjMzEgPSBncmlkLmZsYXQoKS5maW5kKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSAxMSAmJiBkYXRlLmdldERhdGUoKSA9PT0gMzEpO1xuICAgICAgICBjb25zb2xlLmxvZyhgR3JpZCBmb3IgJHtzZWxlY3RlZFllYXJ9OiAke3RvdGFsV2Vla3N9IHdlZWtzIMOXIDcgZGF5c2ApO1xuICAgICAgICBjb25zb2xlLmxvZyhgRGF5cyBpbiB5ZWFyOiAke2RheXNJbkZ1bGxZZWFyfSwgZGF5cyBkaXNwbGF5ZWQgZnJvbSB5ZWFyOiAke2RheXNJbkN1cnJlbnRZZWFyfWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgSmFuIDEgcHJlc2VudDogJHshIWphbjF9LCBEZWMgMzEgcHJlc2VudDogJHshIWRlYzMxfWApO1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgZ3JpZCBpcyA1MiBvciA1MyB3ZWVrcyAoc3RhbmRhcmQgZm9yIGEgeWVhcilcbiAgICAgICAgY29uc3QgaXNTdGFuZGFyZFNpemUgPSB0b3RhbFdlZWtzID49IDUyICYmIHRvdGFsV2Vla3MgPD0gNTM7XG4gICAgICAgIGNvbnNvbGUubG9nKGBHcmlkIHNpemUgY2hlY2s6ICR7aXNTdGFuZGFyZFNpemUgPyAnUEFTU0VEJyA6ICdGQUlMRUQnfSAtICR7dG90YWxXZWVrc30gd2Vla3MgKHNob3VsZCBiZSA1Mi01MylgKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemU6IHRvdGFsV2Vla3MsXG4gICAgICAgICAgICBkYXlzSW5ZZWFyOiBkYXlzSW5DdXJyZW50WWVhcixcbiAgICAgICAgICAgIGhhc0phbjE6ICEhamFuMSxcbiAgICAgICAgICAgIGhhc0RlYzMxOiAhIWRlYzMxLFxuICAgICAgICAgICAgaXNDb3JyZWN0U2l6ZTogaXNTdGFuZGFyZFNpemVcbiAgICAgICAgfTtcbiAgICB9LCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgLy8gQnVpbGQgZ3JpZDogZ3JpZFtjb2xdW3Jvd10gPSBkYXRlIG9yIG51bGxcbiAgICAvLyBDb2wgPSB3ZWVrLCBSb3cgPSB3ZWVrZGF5XG4gICAgY29uc3QgZ3JpZCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgLy8gR2V0IHRoZSBzdGFydCBhbmQgZW5kIGRhdGVzIGZvciB0aGUgeWVhclxuICAgICAgICBjb25zdCBqYW4xID0gbmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKTtcbiAgICAgICAgY29uc3QgZGVjMzEgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDExLCAzMSk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGZpcnN0IFN1bmRheSBiZWZvcmUgb3Igb24gSmFuIDFcbiAgICAgICAgY29uc3QgZmlyc3REYXlPZkdyaWQgPSBuZXcgRGF0ZShqYW4xKTtcbiAgICAgICAgY29uc3QgZmlyc3REYXlPZldlZWsgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGZpcnN0RGF5T2ZHcmlkKTtcbiAgICAgICAgZmlyc3REYXlPZkdyaWQuc2V0RGF0ZShmaXJzdERheU9mR3JpZC5nZXREYXRlKCkgLSBmaXJzdERheU9mV2Vlayk7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgU2F0dXJkYXkgYWZ0ZXIgb3Igb24gRGVjIDMxXG4gICAgICAgIGNvbnN0IGxhc3REYXlPZkdyaWQgPSBuZXcgRGF0ZShkZWMzMSk7XG4gICAgICAgIGNvbnN0IGxhc3REYXlPZldlZWsgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGxhc3REYXlPZkdyaWQpO1xuICAgICAgICBsYXN0RGF5T2ZHcmlkLnNldERhdGUobGFzdERheU9mR3JpZC5nZXREYXRlKCkgKyAoNiAtIGxhc3REYXlPZldlZWspKTtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygd2Vla3NcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IE1hdGguY2VpbCgobGFzdERheU9mR3JpZC5nZXRUaW1lKCkgLSBmaXJzdERheU9mR3JpZC5nZXRUaW1lKCkpIC8gKDcgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgZ3JpZCB3aXRoIHRoZSBjb3JyZWN0IG51bWJlciBvZiB3ZWVrc1xuICAgICAgICBjb25zdCBuZXdHcmlkID0gW107XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggdGhlIGZpcnN0IGRheSBvZiB0aGUgZ3JpZFxuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mR3JpZCk7XG4gICAgICAgIC8vIEdlbmVyYXRlIGFsbCB3ZWVrc1xuICAgICAgICBmb3IgKGxldCB3ZWVrID0gMDsgd2VlayA8IHRvdGFsV2Vla3M7IHdlZWsrKykge1xuICAgICAgICAgICAgY29uc3Qgd2Vla1JvdyA9IFtdO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgZGF5cyBmb3IgZWFjaCB3ZWVrXG4gICAgICAgICAgICBmb3IgKGxldCBkYXkgPSAwOyBkYXkgPCA3OyBkYXkrKykge1xuICAgICAgICAgICAgICAgIHdlZWtSb3cucHVzaChuZXcgRGF0ZShjdXJyZW50RGF0ZSkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdHcmlkLnB1c2god2Vla1Jvdyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgRGVjZW1iZXIgMzFzdCBpcyBpbmNsdWRlZCBpbiB0aGUgZ3JpZFxuICAgICAgICBjb25zdCBoYXNEZWMzMSA9IG5ld0dyaWQuZmxhdCgpLnNvbWUoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDExICYmIGRhdGUuZ2V0RGF0ZSgpID09PSAzMSk7XG4gICAgICAgIC8vIElmIERlY2VtYmVyIDMxc3QgaXMgbWlzc2luZywgYWRkIGFkZGl0aW9uYWwgd2Vla3MgdW50aWwgd2UgaW5jbHVkZSBpdFxuICAgICAgICBpZiAoIWhhc0RlYzMxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYERlY2VtYmVyIDMxc3QsICR7c2VsZWN0ZWRZZWFyfSBpcyBtaXNzaW5nIGZyb20gdGhlIGdyaWQuIEV4dGVuZGluZyBncmlkLmApO1xuICAgICAgICAgICAgLy8gQ29udGludWUgd2hlcmUgd2UgbGVmdCBvZmZcbiAgICAgICAgICAgIGxldCBhZGRpdGlvbmFsRGF0ZSA9IG5ldyBEYXRlKGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIC8vIEFkZCB1cCB0byA0IGFkZGl0aW9uYWwgd2Vla3MgKHNob3VsZCBiZSBlbm91Z2ggaW4gYWxsIGNhc2VzKVxuICAgICAgICAgICAgZm9yIChsZXQgd2VlayA9IDA7IHdlZWsgPCA0OyB3ZWVrKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWVrUm93ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZGF5ID0gMDsgZGF5IDwgNzsgZGF5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla1Jvdy5wdXNoKG5ldyBEYXRlKGFkZGl0aW9uYWxEYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxEYXRlLnNldERhdGUoYWRkaXRpb25hbERhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlJ3ZlIG5vdyBpbmNsdWRlZCBEZWNlbWJlciAzMXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbmFsRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNEZWMzMU5vdyA9IG5ld0dyaWQuZmxhdCgpLmNvbmNhdCh3ZWVrUm93KS5zb21lKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSAxMSAmJiBkYXRlLmdldERhdGUoKSA9PT0gMzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0RlYzMxTm93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3R3JpZC5wdXNoKHdlZWtSb3cpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIERlY2VtYmVyIDMxc3QgaXMgbm93IGluIHRoZSBncmlkIGFmdGVyIGFkZGluZyB0aGlzIHdlZWtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluc0RlYzMxID0gbmV3R3JpZC5mbGF0KCkuc29tZShkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMTEgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDMxKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNEZWMzMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgR3JpZCBleHRlbmRlZC4gRGVjZW1iZXIgMzFzdCwgJHtzZWxlY3RlZFllYXJ9IGlzIG5vdyBpbmNsdWRlZC5gKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENvdW50IGRheXMgaW4gdGhlIGN1cnJlbnQgeWVhciBmb3IgZGVidWdnaW5nXG4gICAgICAgIGNvbnN0IGRheXNJblllYXIgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDEsIDI5KS5nZXREYXRlKCkgPT09IDI5ID8gMzY2IDogMzY1O1xuICAgICAgICBjb25zdCBkYXlzSW5DdXJyZW50WWVhciA9IG5ld0dyaWQuZmxhdCgpLmZpbHRlcihkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyKS5sZW5ndGg7XG4gICAgICAgIC8vIExvZyBkZWJ1ZyBpbmZvXG4gICAgICAgIGNvbnNvbGUubG9nKGBDYWxlbmRhciBncmlkIGZvciAke3NlbGVjdGVkWWVhcn06ICR7bmV3R3JpZC5sZW5ndGh9IHdlZWtzICgke25ld0dyaWQubGVuZ3RofXg3KSwgJHtkYXlzSW5DdXJyZW50WWVhcn0vJHtkYXlzSW5ZZWFyfSBkYXlzIGluIHllYXJgKTtcbiAgICAgICAgY29uc29sZS5sb2coYEZpcnN0IGRhdGUgaW4gZ3JpZDogJHsoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKG5ld0dyaWRbMF1bMF0sICd5eXl5LU1NLWRkJyl9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYXN0IGRhdGUgaW4gZ3JpZDogJHsoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKG5ld0dyaWRbbmV3R3JpZC5sZW5ndGggLSAxXVs2XSwgJ3l5eXktTU0tZGQnKX1gKTtcbiAgICAgICAgcmV0dXJuIG5ld0dyaWQ7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIC8vIERlZmluZSBkeW5hbWljIGNlbGwgc2l6ZSBiYXNlZCBvbiBhdmFpbGFibGUgd2lkdGhcbiAgICBjb25zdCBjYWxjdWxhdGVDZWxsU2l6ZSA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc21hbGxlc3QgcG9zc2libGUgY2VsbCBzaXplIHRoYXQgZml0cyBhbGwgd2Vla3Mgd2l0aG91dCBzY3JvbGxpbmdcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCAtIDUwLCAxMjAwKTtcbiAgICAgICAgY29uc3Qgd2Vla2RheUxhYmVsU3BhY2UgPSBXRUVLREFZX0xBQkVMX1dJRFRIICsgMjtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRvdGFsIHdlZWtzIHRvIGRpc3BsYXkgKHNob3VsZCBiZSA1MiBvciA1MylcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IGdyaWQubGVuZ3RoO1xuICAgICAgICAvLyBDYWxjdWxhdGUgbWluaW11bSBjZWxsIHNpemUgdGhhdCB3b3VsZCBmaWxsIHRoZSBhdmFpbGFibGUgd2lkdGhcbiAgICAgICAgLy8gQWNjb3VudCBmb3IgZ2FwcyBiZXR3ZWVuIGNlbGxzXG4gICAgICAgIGNvbnN0IHRvdGFsR2FwV2lkdGggPSBDRUxMX0dBUCAqICh0b3RhbFdlZWtzIC0gMSk7XG4gICAgICAgIGNvbnN0IHdpZHRoRm9yQ2VsbHMgPSBhdmFpbGFibGVXaWR0aCAtIHdlZWtkYXlMYWJlbFNwYWNlIC0gdG90YWxHYXBXaWR0aDtcbiAgICAgICAgY29uc3QgY2VsbFNpemUgPSBNYXRoLmZsb29yKHdpZHRoRm9yQ2VsbHMgLyB0b3RhbFdlZWtzKTtcbiAgICAgICAgLy8gVXNlIG1pbmltdW0gc2l6ZSB0aGF0IGVuc3VyZXMgdmlzaWJpbGl0eSBidXQgYWxsb3dzIGFsbCBjZWxscyB0byBmaXRcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KGNlbGxTaXplLCAzKTtcbiAgICAgICAgY29uc29sZS5sb2coYENlbGwgc2l6ZSBjYWxjdWxhdGlvbjogJHt0b3RhbFdlZWtzfSB3ZWVrcywgJHtzaXplfXB4IHBlciBjZWxsLCBhdmFpbGFibGUgd2lkdGg6ICR7YXZhaWxhYmxlV2lkdGh9cHhgKTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfSwgW2dyaWRdKTtcbiAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIGFuZCB1cGRhdGUgb24gd2luZG93IHJlc2l6ZVxuICAgIGNvbnN0IFtDRUxMX1NJWkUsIHNldENlbGxTaXplXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgoKSA9PiBjYWxjdWxhdGVDZWxsU2l6ZSgpKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgLy8gVXBkYXRlIGNlbGwgc2l6ZSBvbiB3aW5kb3cgcmVzaXplXG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNldENlbGxTaXplKGNhbGN1bGF0ZUNlbGxTaXplKCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsIGNhbGN1bGF0aW9uXG4gICAgICAgIHNldENlbGxTaXplKGNhbGN1bGF0ZUNlbGxTaXplKCkpO1xuICAgICAgICAvLyBEZWJ1ZyBncmlkIGluZm9ybWF0aW9uXG4gICAgICAgIGRlYnVnR3JpZEluZm8oZ3JpZCk7XG4gICAgICAgIC8vIEFkZCByZXNpemUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxjdWxhdGVDZWxsU2l6ZSwgZ3JpZCwgZGVidWdHcmlkSW5mb10pO1xuICAgIC8vIEdlbmVyYXRlIG1vbnRoIGxhYmVscyBiYXNlZCBvbiBhY3R1YWwgY2VsbCBkYXRlc1xuICAgIGNvbnN0IG1vbnRoTGFiZWxzID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbHMgPSBbXTtcbiAgICAgICAgLy8gRmlyc3QsIGNvbGxlY3QgYWxsIG1vbnRoIGJvdW5kYXJpZXMgaW4gdGhlIGdyaWRcbiAgICAgICAgZm9yIChsZXQgbW9udGggPSAwOyBtb250aCA8IDEyOyBtb250aCsrKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGZpcnN0IGRheSBvZiBlYWNoIG1vbnRoIGluIHRoZSBzZWxlY3RlZCB5ZWFyXG4gICAgICAgICAgICBjb25zdCBmaXJzdERheU9mTW9udGggPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgICAgIGxldCBmaXJzdENvbCA9IC0xO1xuICAgICAgICAgICAgLy8gRmluZCBjb2x1bW5zIGZvciBmaXJzdCBkYXkgb2YgdGhpcyBtb250aFxuICAgICAgICAgICAgZm9yIChsZXQgY29sSWR4ID0gMDsgY29sSWR4IDwgZ3JpZC5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcm93SWR4ID0gMDsgcm93SWR4IDwgNzsgcm93SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbERhdGUgPSBncmlkW2NvbElkeF1bcm93SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGZpcnN0IGRheSBvZiBtb250aFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0ZS5nZXRNb250aCgpID09PSBtb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGUuZ2V0RGF0ZSgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENvbCA9IGNvbElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmaXJzdENvbCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgdGhlIGNvbHVtbiBmb3IgdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGhcbiAgICAgICAgICAgIGlmIChmaXJzdENvbCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbGFiZWwgZm9yIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICAgICAgY29uc3QgbW9udGhBYmJyID0gKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShmaXJzdERheU9mTW9udGgsICdNTU0nKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIGxhYmVsIG9iamVjdFxuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29sOiBmaXJzdENvbCxcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IG1vbnRoQWJicixcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgbWlzc2luZyBhbnkgbW9udGhzXG4gICAgICAgIGNvbnN0IG1vbnRoc0ZvdW5kID0gbGFiZWxzLmxlbmd0aDtcbiAgICAgICAgaWYgKG1vbnRoc0ZvdW5kIDwgMTIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgT25seSBmb3VuZCAke21vbnRoc0ZvdW5kfSBtb250aHMgb3V0IG9mIDEyIGluIHRoZSBncmlkLmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvcnQgbGFiZWxzIGJ5IGNvbHVtblxuICAgICAgICByZXR1cm4gbGFiZWxzLnNvcnQoKGEsIGIpID0+IGEuY29sIC0gYi5jb2wpO1xuICAgIH0sIFtncmlkLCBzZWxlY3RlZFllYXJdKTtcbiAgICBjb25zdCBpc0hhYml0Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVN0cmVhayA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIGxldCBzdHJlYWsgPSAwO1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHdoaWxlIChpc0hhYml0Q29tcGxldGVkKGN1cnJlbnREYXRlKSAmJiAhKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoY3VycmVudERhdGUsIHRvZGF5KSkge1xuICAgICAgICAgICAgc3RyZWFrKys7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYWs7XG4gICAgfSwgW2lzSGFiaXRDb21wbGV0ZWRdKTtcbiAgICBjb25zdCBoYW5kbGVMb2dTdWJtaXQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICAvLyBGb3IgaGFiaXRzIHRoYXQgdHJhY2sgcXVhbnRpdHksIHVzZSB0aGUgcXVhbnRpdHkgdmFsdWVcbiAgICAgICAgaWYgKGhhYml0LnRyYWNrUXVhbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChxdWFudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJyksIE51bWJlcihxdWFudGl0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1xdWFudGl0eSBoYWJpdHMsIGFsd2F5cyBtYXJrIGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICBzZXRRdWFudGl0eSgnJyk7XG4gICAgICAgIHNldFVzZUNoZWNrYm94KHRydWUpO1xuICAgIH0sIFtoYWJpdC50cmFja1F1YW50aXR5LCBzZWxlY3RlZERhdGUsIHF1YW50aXR5LCBvblRvZ2dsZUNvbXBsZXRpb25dKTtcbiAgICBjb25zdCBoYW5kbGVEYXlDbGljayA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF5KSA9PiB7XG4gICAgICAgIGlmICgoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShkYXksIG5ldyBEYXRlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IGFsbG93IGxvZ2dpbmcgZnV0dXJlIGRhdGVzXG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0ZWREYXRlKGRheSk7XG4gICAgICAgIHNldElzTG9nRGlhbG9nT3Blbih0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc3RyZWFrID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gY2FsY3VsYXRlU3RyZWFrKCksIFtjYWxjdWxhdGVTdHJlYWtdKTtcbiAgICBjb25zdCBpc0RheUNvbXBsZXRlZCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gaGFiaXQuY29tcGxldGlvbnMuc29tZShjb21wbGV0aW9uID0+IGNvbXBsZXRpb24uZGF0ZSA9PT0gKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShkYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICBjb25zdCBoYW5kbGVQcmV2WWVhciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkWWVhcihwcmV2ID0+IHByZXYgLSAxKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaGFuZGxlTmV4dFllYXIgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZFllYXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgfSwgW10pO1xuICAgIC8vIEdldCBjb21wbGV0aW9uIGZvciBhIHNwZWNpZmljIGRhdGVcbiAgICBjb25zdCBnZXRDb21wbGV0aW9uID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGVTdHIgPSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJyk7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5maW5kKGMgPT4gYy5kYXRlID09PSBkYXRlU3RyKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuUGFwZXIsIHsgZWxldmF0aW9uOiAwLCBzeDoge1xuICAgICAgICAgICAgcDogMi41LFxuICAgICAgICAgICAgcGI6IDEuNSxcbiAgICAgICAgICAgIG1iOiAzLFxuICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgID8gJzAgM3B4IDEwcHggcmdiYSgwLDAsMCwwLjM1KSdcbiAgICAgICAgICAgICAgICA6ICcwIDNweCAxMHB4IHJnYmEoMCwwLDAsMC4wOCknLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgbXg6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJoNVwiLCBhbGlnbjogXCJjZW50ZXJcIiwgbm9XcmFwOiB0cnVlLCB0aXRsZTogaGFiaXQubmFtZSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiAnZWxsaXBzaXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogJzAuMDFlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgMXB4IDFweCByZ2JhKDAsMCwwLDAuMSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMS4zcmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogMC43NSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJy0ycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGhhYml0Lm5hbWUgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlUHJldlllYXIsIHN4OiB7IGNvbG9yOiAndGV4dC5wcmltYXJ5JywgcDogMC43IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQ2hldnJvbkxlZnQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXg6IDAuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5wcmltYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC45cmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogc2VsZWN0ZWRZZWFyIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIG9uQ2xpY2s6IGhhbmRsZU5leHRZZWFyLCBkaXNhYmxlZDogc2VsZWN0ZWRZZWFyID49IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSwgc3g6IHsgY29sb3I6ICd0ZXh0LnByaW1hcnknLCBwOiAwLjcgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5DaGV2cm9uUmlnaHQsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicsIGdhcDogMC43IH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IGBDdXJyZW50IHN0cmVhazogJHtzdHJlYWt9IGRheXNgLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjlyZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbXCJcXHVEODNEXFx1REQyNSBcIiwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShcInNwYW5cIiwgeyBzdHlsZTogeyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6ICczcHgnIH0sIGNoaWxkcmVuOiBzdHJlYWsgfSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHNpemU6IFwic21hbGxcIiwgc3RhcnRJY29uOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuQWRkLCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSksIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHk6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDEuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6ICc1NXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjhyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBgJHtoYWJpdC5jb2xvcn05OWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogYCR7aGFiaXQuY29sb3J9Y2NgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFwiTG9nXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgY29sb3I6IFwiZXJyb3JcIiwgb25DbGljazogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKHRydWUpLCBzeDogeyBwOiAwLjcgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5EZWxldGUsIHsgZm9udFNpemU6IFwic21hbGxcIiB9KSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNnJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQuc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW2dyaWQubGVuZ3RoLCBcIiB3ayBcXHUwMEQ3IDcgZFwiXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYjogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWw6IGAke1dFRUtEQVlfTEFCRUxfV0lEVEh9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGBjYWxjKCR7Z3JpZC5sZW5ndGggKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxNnB4JywgLy8gU2xpZ2h0bHkgdGFsbGVyIGhlaWdodCBmb3IgbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBtb250aExhYmVscy5tYXAoKGxhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiB0byBjZW50ZXIgaXQgcHJlY2lzZWx5IGFib3ZlIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBsYWJlbC5jb2wgKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGF2YWlsYWJsZSBzcGFjZSBiZWZvcmUgbmV4dCBsYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dExhYmVsQ29sID0gaWR4IDwgbW9udGhMYWJlbHMubGVuZ3RoIC0gMSA/IG1vbnRoTGFiZWxzW2lkeCArIDFdLmNvbCA6IGdyaWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSAobmV4dExhYmVsQ29sIC0gbGFiZWwuY29sKSAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIGNlbnRlciBvciBsZWZ0LWFsaWduIGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkQ2VudGVyID0gYXZhaWxhYmxlV2lkdGggPj0gNDA7IC8vIE9ubHkgY2VudGVyIGlmIHRoZXJlJ3MgZW5vdWdoIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBgJHtwb3NpdGlvbn1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogc2hvdWxkQ2VudGVyID8gJ3RyYW5zbGF0ZVgoMCknIDogJ3RyYW5zbGF0ZVgoMCknLCAvLyBBbGlnbiB0byBzdGFydCBvZiBjb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiBzaG91bGRDZW50ZXIgPyAnY2VudGVyJyA6ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyLCAvLyBFbnN1cmUgbGFiZWxzIGRvbid0IGdldCBvdmVybGFwcGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBgJHthdmFpbGFibGVXaWR0aH1weGAsIC8vIExpbWl0IHdpZHRoIHRvIGF2YWlsYWJsZSBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IENFTExfU0laRSAqIDcgKyBDRUxMX0dBUCAqIDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKScgOiAncmdiYSgwLDAsMCwwLjEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBDRUxMX1NJWkUgPj0gNSA/ICdibG9jaycgOiAnbm9uZScgLy8gT25seSBzaG93IGZvciBsYXJnZXIgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBub1dyYXA6IHRydWUsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjY1cmVtJywgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvbnQgc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6IGAke2F2YWlsYWJsZVdpZHRofXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbDogMC41LCAvLyBBZGQgc2xpZ2h0IHBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBsYWJlbC5tb250aCB9KV0gfSwgaWR4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weCByZXBlYXQoJHtncmlkLmxlbmd0aH0sICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkVGVtcGxhdGVSb3dzOiBgcmVwZWF0KDcsICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXA6IENFTExfR0FQLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYCR7V0VFS0RBWV9MQUJFTF9XSURUSCArIChncmlkLmxlbmd0aCAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCkpIC0gQ0VMTF9HQVB9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93WDogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGUoMC45OSknLCAvLyBTbGlnaHQgc2NhbGUgZG93biB0byBlbnN1cmUgZXZlcnl0aGluZyBmaXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdsZWZ0IHRvcCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtbMCwgMSwgMiwgMywgNCwgNSwgNl0ubWFwKCh3ZWVrZGF5KSA9PiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkQ29sdW1uOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiB3ZWVrZGF5ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeVNlbGY6ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcjogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogV0VFS0RBWV9MQUJFTF9XSURUSCAtIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJ2JhY2tncm91bmQucGFwZXInIDogJ2JhY2tncm91bmQucGFwZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjU1cmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ11bd2Vla2RheV0gfSkgfSwgd2Vla2RheSkpKSwgZ3JpZC5tYXAoKHdlZWtDb2x1bW4sIGNvbElkeCkgPT4gKHdlZWtDb2x1bW4ubWFwKChkYXksIHJvd0lkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0ZSBmb3IgdGhpcyBjZWxsIHBvc2l0aW9uIGZyb20gb3VyIGdyaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsRGF0ZSA9IGRheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNlbGwncyBkYXRlIGlzIGluIHRoZSBjdXJyZW50IHllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0luQ3VycmVudFllYXIgPSBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyB0aGUgZmlyc3QgZGF5IG9mIGEgbW9udGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpcnN0RGF5T2ZNb250aCA9IGNlbGxEYXRlLmdldERhdGUoKSA9PT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgbW9udGggYm91bmRhcmllcyAtIGxhc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdERheU9mTW9udGggPSAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGF5ID0gbmV3IERhdGUoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0RGF5LnNldERhdGUoY2VsbERhdGUuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkobmV4dERheSkgIT09ICgwLCBkYXRlX2Zuc18xLmdldE1vbnRoKShjZWxsRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9IGlzRGF5Q29tcGxldGVkKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Z1dHVyZSA9ICgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGNlbGxEYXRlLCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnREYXkgPSAoMCwgZGF0ZV9mbnNfMS5pc1RvZGF5KShjZWxsRGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbXBsZXRpb24gZGV0YWlscyBmb3IgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSBnZXRDb21wbGV0aW9uKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXQgZGF0ZSBmb3IgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGNlbGxEYXRlLCAnRUVFRSwgTU1NTSBkLCB5eXl5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vbHRpcCBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbHRpcENvbnRlbnQgPSBpc0luQ3VycmVudFllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7Zm9ybWF0dGVkRGF0ZX0ke2NvbXBsZXRpb24/LnF1YW50aXR5ID8gYCDigKIgJHtjb21wbGV0aW9uLnF1YW50aXR5fSAke2hhYml0LnVuaXQgfHwgJ3VuaXRzJ31gIDogJyDigKIgQ29tcGxldGVkJ31gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZvcm1hdHRlZERhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW9udGggYm91bmRhcnkgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb250aEJvcmRlckNvbG9yID0gbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGlzSW5DdXJyZW50WWVhciA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNSknIDogJ3JnYmEoMjU1LDI1NSwyNTUsMC4yKScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGlzSW5DdXJyZW50WWVhciA/ICdyZ2JhKDAsMCwwLDAuNCknIDogJ3JnYmEoMCwwLDAsMC4yKScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IHRvb2x0aXBDb250ZW50LCBwbGFjZW1lbnQ6IFwidG9wXCIsIGVudGVyRGVsYXk6IDUwMCwgYXJyb3c6IHRydWUsIGRpc2FibGVIb3Zlckxpc3RlbmVyOiAhaXNJbkN1cnJlbnRZZWFyIHx8IENFTExfU0laRSA8IDQsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sSWR4ICsgMiwgLy8gKzIgYmVjYXVzZSBmaXJzdCBjb2x1bW4gaXMgZm9yIHdlZWtkYXkgbGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogcm93SWR4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGlzQ29tcGxldGVkICYmIGlzSW5DdXJyZW50WWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhhYml0LmNvbG9yICsgKG1vZGUgPT09ICdkYXJrJyA/ICdhYScgOiAnOTknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaXNJbkN1cnJlbnRZZWFyID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wNSknIDogJ3JnYmEoMjU1LDI1NSwyNTUsMC4wMiknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoaXNJbkN1cnJlbnRZZWFyID8gJ3RyYW5zcGFyZW50JyA6ICdyZ2JhKDAsMCwwLDAuMDIpJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpc0N1cnJlbnREYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgMXB4IHNvbGlkICR7aGFiaXQuY29sb3J9YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAxcHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAnIzQ0NCcgOiAnI2UwZTBlMCd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbGlmaWVkIGJvcmRlciBzdHlsaW5nIGZvciBzbWFsbCBjZWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihDRUxMX1NJWkUgPCA2ID8ge30gOiAoaXNJbkN1cnJlbnRZZWFyICYmIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyTGVmdDogaXNGaXJzdERheU9mTW9udGggPyBgMnB4IHNvbGlkICR7bW9udGhCb3JkZXJDb2xvcn1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSaWdodDogaXNMYXN0RGF5T2ZNb250aCA/IGAycHggc29saWQgJHttb250aEJvcmRlckNvbG9yfWAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclRvcDogcm93SWR4ID09PSAwICYmIGlzRmlyc3REYXlPZk1vbnRoID8gYDJweCBzb2xpZCAke21vbnRoQm9yZGVyQ29sb3J9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiByb3dJZHggPT09IDYgJiYgaXNGaXJzdERheU9mTW9udGggPyBgMnB4IHNvbGlkICR7bW9udGhCb3JkZXJDb2xvcn1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IENFTExfU0laRSA8IDYgPyAnMHB4JyA6ICcxcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogKGlzRnV0dXJlIHx8ICFpc0luQ3VycmVudFllYXIpID8gJ2RlZmF1bHQnIDogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzRnV0dXJlID8gMC4zIDogKGlzSW5DdXJyZW50WWVhciA/IDEgOiAwLjMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMnMsIHRyYW5zZm9ybSAwLjFzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IGlzSW5DdXJyZW50WWVhciAmJiAhaXNGdXR1cmUgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGlzQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGhhYml0LmNvbG9yICsgJ2NjJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICcjZjVmNWY1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBDRUxMX1NJWkUgPj0gNiA/ICdzY2FsZSgxLjE1KScgOiAnbm9uZScsIC8vIE9ubHkgc2NhbGUgdXAgbGFyZ2VyIGNlbGxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBvbkNsaWNrOiAoKSA9PiBpc0luQ3VycmVudFllYXIgJiYgIWlzRnV0dXJlICYmIGhhbmRsZURheUNsaWNrKGNlbGxEYXRlKSwgb25Nb3VzZUVudGVyOiAoKSA9PiBzZXRIb3ZlcmVkRGF0ZShjZWxsRGF0ZSksIG9uTW91c2VMZWF2ZTogKCkgPT4gc2V0SG92ZXJlZERhdGUobnVsbCkgfSkgfSwgYGNlbGwtJHtjb2xJZHh9LSR7cm93SWR4fWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSldIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nLCB7IG9wZW46IGlzTG9nRGlhbG9nT3Blbiwgb25DbG9zZTogKCkgPT4gc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKSwgbWF4V2lkdGg6IFwieHNcIiwgZnVsbFdpZHRoOiB0cnVlLCBQYXBlclByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuNSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuMTIpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dUaXRsZSwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYjogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAke2hhYml0LmNvbG9yfSAzMCUsICR7aGFiaXQuY29sb3J9OTkgOTAlKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbXCJMb2cgXCIsIGhhYml0Lm5hbWVdIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nQ29udGVudCwgeyBzeDogeyBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IG10OiAyIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwic3VidGl0bGUyXCIsIGd1dHRlckJvdHRvbTogdHJ1ZSwgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBbXCJEYXRlOiBcIiwgKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICdNTU1NIGQsIHl5eXknKV0gfSksICFoYWJpdC50cmFja1F1YW50aXR5ID8gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Gb3JtQ29udHJvbExhYmVsLCB7IGNvbnRyb2w6ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5DaGVja2JveCwgeyBjaGVja2VkOiB1c2VDaGVja2JveCwgb25DaGFuZ2U6IChlKSA9PiBzZXRVc2VDaGVja2JveChlLnRhcmdldC5jaGVja2VkKSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJi5NdWktY2hlY2tlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSksIGxhYmVsOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyBjb2xvcjogXCJ0ZXh0LnByaW1hcnlcIiwgY2hpbGRyZW46IFwiTWFyayBhcyBjb21wbGV0ZWRcIiB9KSB9KSkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBoYWJpdHMgdGhhdCB0cmFjayBxdWFudGl0eSwgYWx3YXlzIHNob3cgdGhlIHF1YW50aXR5IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UZXh0RmllbGQsIHsgZnVsbFdpZHRoOiB0cnVlLCB0eXBlOiBcIm51bWJlclwiLCBsYWJlbDogYFF1YW50aXR5JHtoYWJpdC51bml0ID8gYCAoJHtoYWJpdC51bml0fSlgIDogJyd9YCwgdmFsdWU6IHF1YW50aXR5LCBvbkNoYW5nZTogKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsID09PSAnJyB8fCAoTnVtYmVyKHZhbCkgPj0gMCAmJiBOdW1iZXIodmFsKSA8PSAxMDAwMDAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRRdWFudGl0eSh2YWwgPT09ICcnID8gJycgOiBOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJiAuTXVpT3V0bGluZWRJbnB1dC1yb290Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJi5NdWktZm9jdXNlZCBmaWVsZHNldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIC5NdWlJbnB1dExhYmVsLXJvb3QuTXVpLWZvY3VzZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgaW5wdXRQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IDEwMDAwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pKV0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nQWN0aW9ucywgeyBzeDogeyBweDogMywgcHk6IDIsIGJvcmRlclRvcDogJzFweCBzb2xpZCcsIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4gc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIkNhbmNlbFwiIH0pLCBpc0RheUNvbXBsZXRlZChzZWxlY3RlZERhdGUpICYmICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IGNvbG9yOiBcIndhcm5pbmdcIiwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJVbmRvXCIgfSkpLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUxvZ1N1Ym1pdCwgdmFyaWFudDogXCJjb250YWluZWRcIiwgZGlzYWJsZWQ6IGhhYml0LnRyYWNrUXVhbnRpdHkgJiYgcXVhbnRpdHkgPT09ICcnLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweDogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQoNDVkZWcsICR7aGFiaXQuY29sb3J9IDMwJSwgJHtoYWJpdC5jb2xvcn05OSA5MCUpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogYDAgM3B4IDVweCAycHggJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIlNhdmVcIiB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0RlbGV0ZURpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgUGFwZXJQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjUpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjEyKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dUaXRsZSwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogJzFweCBzb2xpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYjogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBtb2RlID09PSAnZGFyaycgPyAnIzNhMDUwNScgOiAnI2ZmZWJlZScsIC8vIERhcmsvbGlnaHQgcmVkIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJyNmZjUyNTInIDogJyNkMzJmMmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFwiRGVsZXRlIEhhYml0XCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dDb250ZW50LCB7IHN4OiB7IG10OiAyLCBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyBjb2xvcjogXCJ0ZXh0LnByaW1hcnlcIiwgY2hpbGRyZW46IFtcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgXFxcIlwiLCBoYWJpdC5uYW1lLCBcIlxcXCI/IFRoaXMgYWN0aW9uIGNhbm5vdCBiZSB1bmRvbmUuXCJdIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ0FjdGlvbnMsIHsgc3g6IHsgcHg6IDMsIHB5OiAyLCBib3JkZXJUb3A6ICcxcHggc29saWQnLCBib3JkZXJDb2xvcjogJ2RpdmlkZXInLCBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSksIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJDYW5jZWxcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29sb3I6IFwiZXJyb3JcIiwgdmFyaWFudDogXCJjb250YWluZWRcIiwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIkRlbGV0ZVwiIH0pXSB9KV0gfSldIH0pKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBIYWJpdENhcmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});