"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    // Build a GitHub-style heatmap grid for the selected year\n    const daysOfYear = (0, react_1.useMemo)(() => {\n        const yearStart = (0, date_fns_1.startOfYear)(new Date(selectedYear, 0, 1));\n        const yearEnd = (0, date_fns_1.endOfYear)(new Date(selectedYear, 11, 31));\n        return (0, date_fns_1.eachDayOfInterval)({ start: yearStart, end: yearEnd });\n    }, [selectedYear]);\n    const firstDayOfYear = (0, react_1.useMemo)(() => (0, date_fns_1.startOfYear)(new Date(selectedYear, 0, 1)), [selectedYear]);\n    const numWeeks = (0, react_1.useMemo)(() => (0, date_fns_1.differenceInCalendarWeeks)((0, date_fns_1.endOfYear)(new Date(selectedYear, 11, 31)), firstDayOfYear, { weekStartsOn: 0 }) + 1, [selectedYear, firstDayOfYear]);\n    const numRows = 7; // Sun-Sat\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        const newGrid = Array.from({ length: numWeeks }, () => Array(numRows).fill(null));\n        daysOfYear.forEach(day => {\n            const week = (0, date_fns_1.differenceInCalendarWeeks)(day, firstDayOfYear, { weekStartsOn: 0 });\n            const weekday = (0, date_fns_1.getDay)(day); // 0=Sun, 6=Sat\n            if (week >= 0 && week < numWeeks) { // Only include days in this year\n                newGrid[week][weekday] = day;\n            }\n        });\n        return newGrid;\n    }, [daysOfYear, firstDayOfYear, numWeeks, numRows]);\n    // For month labels: map colIdx to month if the first day in the column is in a new month\n    const monthLabels = (0, react_1.useMemo)(() => {\n        const labels = [];\n        let lastMonth = -1;\n        grid.forEach((col, colIdx) => {\n            // Find first day in the column\n            const firstDayInCol = col.find(day => day !== null);\n            if (firstDayInCol) {\n                const m = (0, date_fns_1.getMonth)(firstDayInCol);\n                if (m !== lastMonth) {\n                    labels.push({ col: colIdx, month: (0, date_fns_1.format)(firstDayInCol, 'MMM') });\n                    lastMonth = m;\n                }\n            }\n        });\n        return labels;\n    }, [grid]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        if (useCheckbox) {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        else if (quantity !== '') {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [useCheckbox, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2,\n            pb: 1,\n            mb: 2,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: '0 2px 8px rgba(0,0,0,0.05)',\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { width: 'fit-content', mx: 'auto', mb: 0 }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0,\n                            mb: 1,\n                            maxWidth: `calc(${grid.length * 14 + 32}px)`,\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.02em',\n                            textShadow: '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.3rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.5,\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: { mx: 0.5, fontWeight: 'bold' }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: { display: 'flex', alignItems: 'center' }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '2px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, {}), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.6,\n                                            px: 1.5,\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, {}) })] })] }), (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', mb: 0.5, ml: '32px' }, children: grid.map((col, colIdx) => {\n                            const label = monthLabels.find(m => m.col === colIdx);\n                            return label ? ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: { width: 14, textAlign: 'center' }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: { fontSize: '0.7rem', color: 'text.secondary', lineHeight: 1 }, children: label.month }) }, colIdx)) : (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { width: 14 } }, colIdx);\n                        }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'grid', gridTemplateColumns: `32px repeat(${grid.length}, 14px)`, gap: 0.25, mb: 0 }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: 1, gridRow: weekday + 1, justifySelf: 'end', pr: 0.5 }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: { fontSize: '0.7rem', color: 'text.secondary', lineHeight: 1 }, children: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][weekday].substring(0, 1) }) }, weekday))), grid.map((col, colIdx) => ([0, 1, 2, 3, 4, 5, 6].map((rowIdx) => {\n                                const day = col[rowIdx];\n                                if (!day)\n                                    return (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: colIdx + 2, gridRow: rowIdx + 1, width: 14, height: 14 } }, `empty-${colIdx}-${rowIdx}`);\n                                const isCompleted = isDayCompleted(day);\n                                const isFuture = (0, date_fns_1.isAfter)(day, new Date());\n                                const isCurrentDay = (0, date_fns_1.isToday)(day);\n                                return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                        gridColumn: colIdx + 2,\n                                        gridRow: rowIdx + 1,\n                                        width: 14,\n                                        height: 14,\n                                        bgcolor: isCompleted ? habit.color + '99' : 'transparent',\n                                        border: isCurrentDay ? `1px solid ${habit.color}` : '1px solid #e0e0e0',\n                                        borderRadius: '2px',\n                                        cursor: isFuture ? 'not-allowed' : 'pointer',\n                                        opacity: isFuture ? 0.3 : 1,\n                                        transition: 'background-color 0.2s',\n                                        '&:hover': {\n                                            bgcolor: isCompleted ? habit.color + 'cc' : '#f5f5f5',\n                                        }\n                                    }, onClick: () => !isFuture && handleDayClick(day) }, day.toString()));\n                            })))] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), (0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked) }), label: \"Mark as completed\" }), !useCheckbox && ((0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: { mt: 2 }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: !useCheckbox && quantity === '', children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFxRCxZQUFZLDRCQUE0Qiw4RkFBOEYsTUFBTSxrRUFBa0UsNERBQTRELDBCQUEwQiw0REFBNEQsd0ZBQXdGLEdBQUc7QUFDL2pCO0FBQ0E7QUFDQSxvRkFBb0YsTUFBTSxzRUFBc0UsV0FBVyxPQUFPLEdBQUcsT0FBTztBQUM1TDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1EQUFtRDtBQUN4Riw2QkFBNkIsTUFBTSxJQUFJLGdEQUFnRCwrSkFBK0osZ0NBQWdDLHNEQUFzRCxvREFBb0QsTUFBTSxPQUFPLDhEQUE4RCxzSEFBc0gseURBQXlELHVEQUF1RCx5RUFBeUUsK0JBQStCLG1FQUFtRSxtREFBbUQsa0JBQWtCLFdBQVcsUUFBUTtBQUNwN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUSxPQUFPO0FBQ3BEO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSyxHQUFHLHVEQUF1RCx1REFBdUQsOERBQThELGdGQUFnRjtBQUMzUztBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQixnREFBZ0QsNkdBQTZHLElBQUksSUFBSSxnREFBZ0Qsb0tBQW9LLDBCQUEwQixzREFBc0QsMkRBQTJELG1HQUFtRyxHQUFHLHVEQUF1RCx1REFBdUQsaUVBQWlFLCtDQUErQztBQUM3M0I7QUFDQTtBQUNBLGlDQUFpQyw0REFBNEQsSUFBSSxJQUFJLElBQUk7QUFDekc7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzY2VudC8uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzL0hhYml0Q2FyZC50c3g/NDNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IG1hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9tYXRlcmlhbFwiKTtcbmNvbnN0IGljb25zX21hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9pY29ucy1tYXRlcmlhbFwiKTtcbmNvbnN0IGRhdGVfZm5zXzEgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG5jb25zdCBIYWJpdENhcmQgPSAoeyBoYWJpdCwgb25Ub2dnbGVDb21wbGV0aW9uLCBvbkRlbGV0ZSB9KSA9PiB7XG4gICAgY29uc3QgW2lzTG9nRGlhbG9nT3Blbiwgc2V0SXNMb2dEaWFsb2dPcGVuXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW2lzRGVsZXRlRGlhbG9nT3Blbiwgc2V0SXNEZWxldGVEaWFsb2dPcGVuXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3NlbGVjdGVkRGF0ZSwgc2V0U2VsZWN0ZWREYXRlXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShuZXcgRGF0ZSgpKTtcbiAgICBjb25zdCBbcXVhbnRpdHksIHNldFF1YW50aXR5XSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgnJyk7XG4gICAgY29uc3QgW3VzZUNoZWNrYm94LCBzZXRVc2VDaGVja2JveF0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkodHJ1ZSk7XG4gICAgY29uc3QgW3NlbGVjdGVkWWVhciwgc2V0U2VsZWN0ZWRZZWFyXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuICAgIC8vIEJ1aWxkIGEgR2l0SHViLXN0eWxlIGhlYXRtYXAgZ3JpZCBmb3IgdGhlIHNlbGVjdGVkIHllYXJcbiAgICBjb25zdCBkYXlzT2ZZZWFyID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCB5ZWFyU3RhcnQgPSAoMCwgZGF0ZV9mbnNfMS5zdGFydE9mWWVhcikobmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKSk7XG4gICAgICAgIGNvbnN0IHllYXJFbmQgPSAoMCwgZGF0ZV9mbnNfMS5lbmRPZlllYXIpKG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMTEsIDMxKSk7XG4gICAgICAgIHJldHVybiAoMCwgZGF0ZV9mbnNfMS5lYWNoRGF5T2ZJbnRlcnZhbCkoeyBzdGFydDogeWVhclN0YXJ0LCBlbmQ6IHllYXJFbmQgfSk7XG4gICAgfSwgW3NlbGVjdGVkWWVhcl0pO1xuICAgIGNvbnN0IGZpcnN0RGF5T2ZZZWFyID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gKDAsIGRhdGVfZm5zXzEuc3RhcnRPZlllYXIpKG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMSkpLCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgY29uc3QgbnVtV2Vla3MgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoMCwgZGF0ZV9mbnNfMS5kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzKSgoMCwgZGF0ZV9mbnNfMS5lbmRPZlllYXIpKG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMTEsIDMxKSksIGZpcnN0RGF5T2ZZZWFyLCB7IHdlZWtTdGFydHNPbjogMCB9KSArIDEsIFtzZWxlY3RlZFllYXIsIGZpcnN0RGF5T2ZZZWFyXSk7XG4gICAgY29uc3QgbnVtUm93cyA9IDc7IC8vIFN1bi1TYXRcbiAgICAvLyBCdWlsZCBncmlkOiBncmlkW2NvbF1bcm93XSA9IGRhdGUgb3IgbnVsbFxuICAgIC8vIENvbCA9IHdlZWssIFJvdyA9IHdlZWtkYXlcbiAgICBjb25zdCBncmlkID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdHcmlkID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbnVtV2Vla3MgfSwgKCkgPT4gQXJyYXkobnVtUm93cykuZmlsbChudWxsKSk7XG4gICAgICAgIGRheXNPZlllYXIuZm9yRWFjaChkYXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VlayA9ICgwLCBkYXRlX2Zuc18xLmRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3MpKGRheSwgZmlyc3REYXlPZlllYXIsIHsgd2Vla1N0YXJ0c09uOiAwIH0pO1xuICAgICAgICAgICAgY29uc3Qgd2Vla2RheSA9ICgwLCBkYXRlX2Zuc18xLmdldERheSkoZGF5KTsgLy8gMD1TdW4sIDY9U2F0XG4gICAgICAgICAgICBpZiAod2VlayA+PSAwICYmIHdlZWsgPCBudW1XZWVrcykgeyAvLyBPbmx5IGluY2x1ZGUgZGF5cyBpbiB0aGlzIHllYXJcbiAgICAgICAgICAgICAgICBuZXdHcmlkW3dlZWtdW3dlZWtkYXldID0gZGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld0dyaWQ7XG4gICAgfSwgW2RheXNPZlllYXIsIGZpcnN0RGF5T2ZZZWFyLCBudW1XZWVrcywgbnVtUm93c10pO1xuICAgIC8vIEZvciBtb250aCBsYWJlbHM6IG1hcCBjb2xJZHggdG8gbW9udGggaWYgdGhlIGZpcnN0IGRheSBpbiB0aGUgY29sdW1uIGlzIGluIGEgbmV3IG1vbnRoXG4gICAgY29uc3QgbW9udGhMYWJlbHMgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IFtdO1xuICAgICAgICBsZXQgbGFzdE1vbnRoID0gLTE7XG4gICAgICAgIGdyaWQuZm9yRWFjaCgoY29sLCBjb2xJZHgpID0+IHtcbiAgICAgICAgICAgIC8vIEZpbmQgZmlyc3QgZGF5IGluIHRoZSBjb2x1bW5cbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGF5SW5Db2wgPSBjb2wuZmluZChkYXkgPT4gZGF5ICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmIChmaXJzdERheUluQ29sKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9ICgwLCBkYXRlX2Zuc18xLmdldE1vbnRoKShmaXJzdERheUluQ29sKTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPT0gbGFzdE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHsgY29sOiBjb2xJZHgsIG1vbnRoOiAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGZpcnN0RGF5SW5Db2wsICdNTU0nKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE1vbnRoID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sIFtncmlkXSk7XG4gICAgY29uc3QgaXNIYWJpdENvbXBsZXRlZCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gaGFiaXQuY29tcGxldGlvbnMuc29tZShjb21wbGV0aW9uID0+IGNvbXBsZXRpb24uZGF0ZSA9PT0gKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShkYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICBjb25zdCBjYWxjdWxhdGVTdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBsZXQgc3RyZWFrID0gMDtcbiAgICAgICAgY29uc3QgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB3aGlsZSAoaXNIYWJpdENvbXBsZXRlZChjdXJyZW50RGF0ZSkgJiYgISgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGN1cnJlbnREYXRlLCB0b2RheSkpIHtcbiAgICAgICAgICAgIHN0cmVhaysrO1xuICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFrO1xuICAgIH0sIFtpc0hhYml0Q29tcGxldGVkXSk7XG4gICAgY29uc3QgaGFuZGxlTG9nU3VibWl0ID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgaWYgKHVzZUNoZWNrYm94KSB7XG4gICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1YW50aXR5ICE9PSAnJykge1xuICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpLCBOdW1iZXIocXVhbnRpdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICBzZXRRdWFudGl0eSgnJyk7XG4gICAgICAgIHNldFVzZUNoZWNrYm94KHRydWUpO1xuICAgIH0sIFt1c2VDaGVja2JveCwgc2VsZWN0ZWREYXRlLCBxdWFudGl0eSwgb25Ub2dnbGVDb21wbGV0aW9uXSk7XG4gICAgY29uc3QgaGFuZGxlRGF5Q2xpY2sgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRheSkgPT4ge1xuICAgICAgICBpZiAoKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoZGF5LCBuZXcgRGF0ZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBhbGxvdyBsb2dnaW5nIGZ1dHVyZSBkYXRlc1xuICAgICAgICB9XG4gICAgICAgIHNldFNlbGVjdGVkRGF0ZShkYXkpO1xuICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHN0cmVhayA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IGNhbGN1bGF0ZVN0cmVhaygpLCBbY2FsY3VsYXRlU3RyZWFrXSk7XG4gICAgY29uc3QgaXNEYXlDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgaGFuZGxlUHJldlllYXIgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZFllYXIocHJldiA9PiBwcmV2IC0gMSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGhhbmRsZU5leHRZZWFyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRZZWFyKHByZXYgPT4gcHJldiArIDEpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuUGFwZXIsIHsgZWxldmF0aW9uOiAwLCBzeDoge1xuICAgICAgICAgICAgcDogMixcbiAgICAgICAgICAgIHBiOiAxLFxuICAgICAgICAgICAgbWI6IDIsXG4gICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCcsXG4gICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMnB4IDhweCByZ2JhKDAsMCwwLDAuMDUpJyxcbiAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyB3aWR0aDogJ2ZpdC1jb250ZW50JywgbXg6ICdhdXRvJywgbWI6IDAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImg1XCIsIGFsaWduOiBcImNlbnRlclwiLCBub1dyYXA6IHRydWUsIHRpdGxlOiBoYWJpdC5uYW1lLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiBgY2FsYygke2dyaWQubGVuZ3RoICogMTQgKyAzMn1weClgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAnMC4wMmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4xKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxLjNyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke2hhYml0LmNvbG9yfTMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogaGFiaXQubmFtZSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgbWI6IDEgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIG9uQ2xpY2s6IGhhbmRsZVByZXZZZWFyLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25MZWZ0LCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgc3g6IHsgbXg6IDAuNSwgZm9udFdlaWdodDogJ2JvbGQnIH0sIGNoaWxkcmVuOiBzZWxlY3RlZFllYXIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlTmV4dFllYXIsIGRpc2FibGVkOiBzZWxlY3RlZFllYXIgPj0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25SaWdodCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZ2FwOiAxIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IGBDdXJyZW50IHN0cmVhazogJHtzdHJlYWt9IGRheXNgLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiwgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogW1wiXFx1RDgzRFxcdUREMjUgXCIsICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgc3R5bGU6IHsgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAnMnB4JyB9LCBjaGlsZHJlbjogc3RyZWFrIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBzaXplOiBcInNtYWxsXCIsIHN0YXJ0SWNvbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkFkZCwge30pLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5OiAwLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGAke2hhYml0LmNvbG9yfTk5YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBgJHtoYWJpdC5jb2xvcn1jY2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJMb2dcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkljb25CdXR0b24sIHsgc2l6ZTogXCJzbWFsbFwiLCBjb2xvcjogXCJlcnJvclwiLCBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4odHJ1ZSksIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuRGVsZXRlLCB7fSkgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBtYjogMC41LCBtbDogJzMycHgnIH0sIGNoaWxkcmVuOiBncmlkLm1hcCgoY29sLCBjb2xJZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IG1vbnRoTGFiZWxzLmZpbmQobSA9PiBtLmNvbCA9PT0gY29sSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWwgPyAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyB3aWR0aDogMTQsIHRleHRBbGlnbjogJ2NlbnRlcicgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBzeDogeyBmb250U2l6ZTogJzAuN3JlbScsIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLCBsaW5lSGVpZ2h0OiAxIH0sIGNoaWxkcmVuOiBsYWJlbC5tb250aCB9KSB9LCBjb2xJZHgpKSA6ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgd2lkdGg6IDE0IH0gfSwgY29sSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZ3JpZCcsIGdyaWRUZW1wbGF0ZUNvbHVtbnM6IGAzMnB4IHJlcGVhdCgke2dyaWQubGVuZ3RofSwgMTRweClgLCBnYXA6IDAuMjUsIG1iOiAwIH0sIGNoaWxkcmVuOiBbWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcCgod2Vla2RheSkgPT4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZ3JpZENvbHVtbjogMSwgZ3JpZFJvdzogd2Vla2RheSArIDEsIGp1c3RpZnlTZWxmOiAnZW5kJywgcHI6IDAuNSB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIHN4OiB7IGZvbnRTaXplOiAnMC43cmVtJywgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScsIGxpbmVIZWlnaHQ6IDEgfSwgY2hpbGRyZW46IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J11bd2Vla2RheV0uc3Vic3RyaW5nKDAsIDEpIH0pIH0sIHdlZWtkYXkpKSksIGdyaWQubWFwKChjb2wsIGNvbElkeCkgPT4gKFswLCAxLCAyLCAzLCA0LCA1LCA2XS5tYXAoKHJvd0lkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXkgPSBjb2xbcm93SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBncmlkQ29sdW1uOiBjb2xJZHggKyAyLCBncmlkUm93OiByb3dJZHggKyAxLCB3aWR0aDogMTQsIGhlaWdodDogMTQgfSB9LCBgZW1wdHktJHtjb2xJZHh9LSR7cm93SWR4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9IGlzRGF5Q29tcGxldGVkKGRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnV0dXJlID0gKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoZGF5LCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RGF5ID0gKDAsIGRhdGVfZm5zXzEuaXNUb2RheSkoZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sSWR4ICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3dJZHggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGlzQ29tcGxldGVkID8gaGFiaXQuY29sb3IgKyAnOTknIDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IGlzQ3VycmVudERheSA/IGAxcHggc29saWQgJHtoYWJpdC5jb2xvcn1gIDogJzFweCBzb2xpZCAjZTBlMGUwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogaXNGdXR1cmUgPyAnbm90LWFsbG93ZWQnIDogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzRnV0dXJlID8gMC4zIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciAwLjJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWQgPyBoYWJpdC5jb2xvciArICdjYycgOiAnI2Y1ZjVmNScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgb25DbGljazogKCkgPT4gIWlzRnV0dXJlICYmIGhhbmRsZURheUNsaWNrKGRheSkgfSwgZGF5LnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nLCB7IG9wZW46IGlzTG9nRGlhbG9nT3Blbiwgb25DbG9zZTogKCkgPT4gc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKSwgbWF4V2lkdGg6IFwieHNcIiwgZnVsbFdpZHRoOiB0cnVlLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgY2hpbGRyZW46IFtcIkxvZyBcIiwgaGFiaXQubmFtZV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dDb250ZW50LCB7IGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBtdDogMiB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcInN1YnRpdGxlMlwiLCBndXR0ZXJCb3R0b206IHRydWUsIGNoaWxkcmVuOiBbXCJEYXRlOiBcIiwgKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICdNTU1NIGQsIHl5eXknKV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Gb3JtQ29udHJvbExhYmVsLCB7IGNvbnRyb2w6ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5DaGVja2JveCwgeyBjaGVja2VkOiB1c2VDaGVja2JveCwgb25DaGFuZ2U6IChlKSA9PiBzZXRVc2VDaGVja2JveChlLnRhcmdldC5jaGVja2VkKSB9KSwgbGFiZWw6IFwiTWFyayBhcyBjb21wbGV0ZWRcIiB9KSwgIXVzZUNoZWNrYm94ICYmICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVGV4dEZpZWxkLCB7IGZ1bGxXaWR0aDogdHJ1ZSwgdHlwZTogXCJudW1iZXJcIiwgbGFiZWw6IGBRdWFudGl0eSR7aGFiaXQudW5pdCA/IGAgKCR7aGFiaXQudW5pdH0pYCA6ICcnfWAsIHZhbHVlOiBxdWFudGl0eSwgb25DaGFuZ2U6IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgKE51bWJlcih2YWwpID49IDAgJiYgTnVtYmVyKHZhbCkgPD0gMTAwMDAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UXVhbnRpdHkodmFsID09PSAnJyA/ICcnIDogTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7IG10OiAyIH0sIGlucHV0UHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiAxMDAwMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSldIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ0FjdGlvbnMsIHsgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIGNoaWxkcmVuOiBcIkNhbmNlbFwiIH0pLCBpc0RheUNvbXBsZXRlZChzZWxlY3RlZERhdGUpICYmICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IGNvbG9yOiBcIndhcm5pbmdcIiwgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIlVuZG9cIiB9KSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlTG9nU3VibWl0LCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBkaXNhYmxlZDogIXVzZUNoZWNrYm94ICYmIHF1YW50aXR5ID09PSAnJywgY2hpbGRyZW46IFwiU2F2ZVwiIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nLCB7IG9wZW46IGlzRGVsZXRlRGlhbG9nT3Blbiwgb25DbG9zZTogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgbWF4V2lkdGg6IFwieHNcIiwgZnVsbFdpZHRoOiB0cnVlLCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dUaXRsZSwgeyBjaGlsZHJlbjogXCJEZWxldGUgSGFiaXRcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyBjaGlsZHJlbjogW1wiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSBcXFwiXCIsIGhhYml0Lm5hbWUsIFwiXFxcIj8gVGhpcyBhY3Rpb24gY2Fubm90IGJlIHVuZG9uZS5cIl0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nQWN0aW9ucywgeyBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbG9yOiBcImVycm9yXCIsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIGNoaWxkcmVuOiBcIkRlbGV0ZVwiIH0pXSB9KV0gfSldIH0pKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBIYWJpdENhcmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});