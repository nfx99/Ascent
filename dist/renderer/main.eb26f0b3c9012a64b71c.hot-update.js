"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const isSmallScreen = (0, material_1.useMediaQuery)(muiTheme.breakpoints.down('sm'));\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    const [hoveredDate, setHoveredDate] = (0, react_1.useState)(null);\n    // Define constants first\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 15; // Smaller width for weekday labels\n    // Debug function to log grid information\n    const debugGridInfo = (0, react_1.useCallback)((grid) => {\n        const totalWeeks = grid.length;\n        const daysInFullYear = new Date(selectedYear, 0, 0).getDate() === 366 ? 366 : 365;\n        const daysInCurrentYear = grid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        const jan1 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 0 && date.getDate() === 1);\n        const dec31 = grid.flat().find(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        console.log(`Grid for ${selectedYear}: ${totalWeeks} weeks Ã— 7 days`);\n        console.log(`Days in year: ${daysInFullYear}, days displayed from year: ${daysInCurrentYear}`);\n        console.log(`Jan 1 present: ${!!jan1}, Dec 31 present: ${!!dec31}`);\n        // Check if the grid is 52 or 53 weeks (standard for a year)\n        const isStandardSize = totalWeeks >= 52 && totalWeeks <= 53;\n        console.log(`Grid size check: ${isStandardSize ? 'PASSED' : 'FAILED'} - ${totalWeeks} weeks (should be 52-53)`);\n        return {\n            size: totalWeeks,\n            daysInYear: daysInCurrentYear,\n            hasJan1: !!jan1,\n            hasDec31: !!dec31,\n            isCorrectSize: isStandardSize\n        };\n    }, [selectedYear]);\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        // Get the start and end dates for the year\n        const jan1 = new Date(selectedYear, 0, 1);\n        const dec31 = new Date(selectedYear, 11, 31);\n        // Find the first Sunday before or on Jan 1\n        const firstDayOfGrid = new Date(jan1);\n        const firstDayOfWeek = (0, date_fns_1.getDay)(firstDayOfGrid);\n        firstDayOfGrid.setDate(firstDayOfGrid.getDate() - firstDayOfWeek);\n        // Find the last Saturday after or on Dec 31\n        const lastDayOfGrid = new Date(dec31);\n        const lastDayOfWeek = (0, date_fns_1.getDay)(lastDayOfGrid);\n        lastDayOfGrid.setDate(lastDayOfGrid.getDate() + (6 - lastDayOfWeek));\n        // Calculate the total number of weeks\n        const totalWeeks = Math.ceil((lastDayOfGrid.getTime() - firstDayOfGrid.getTime()) / (7 * 24 * 60 * 60 * 1000));\n        // Create the grid with the correct number of weeks\n        const newGrid = [];\n        // Start with the first day of the grid\n        let currentDate = new Date(firstDayOfGrid);\n        // Generate all weeks\n        for (let week = 0; week < totalWeeks; week++) {\n            const weekRow = [];\n            // Generate days for each week\n            for (let day = 0; day < 7; day++) {\n                weekRow.push(new Date(currentDate));\n                currentDate.setDate(currentDate.getDate() + 1);\n            }\n            newGrid.push(weekRow);\n        }\n        // Check if December 31st is included in the grid\n        const hasDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n        // If December 31st is missing, add additional weeks until we include it\n        if (!hasDec31) {\n            console.warn(`December 31st, ${selectedYear} is missing from the grid. Extending grid.`);\n            // Continue where we left off\n            let additionalDate = new Date(currentDate);\n            // Add up to 4 additional weeks (should be enough in all cases)\n            for (let week = 0; week < 4; week++) {\n                const weekRow = [];\n                for (let day = 0; day < 7; day++) {\n                    weekRow.push(new Date(additionalDate));\n                    additionalDate.setDate(additionalDate.getDate() + 1);\n                    // Check if we've now included December 31st\n                    if (additionalDate.getFullYear() === selectedYear + 1) {\n                        const hasDec31Now = newGrid.flat().concat(weekRow).some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                        if (hasDec31Now) {\n                            break;\n                        }\n                    }\n                }\n                newGrid.push(weekRow);\n                // Check if December 31st is now in the grid after adding this week\n                const containsDec31 = newGrid.flat().some(date => date.getFullYear() === selectedYear && date.getMonth() === 11 && date.getDate() === 31);\n                if (containsDec31) {\n                    console.log(`Grid extended. December 31st, ${selectedYear} is now included.`);\n                    break;\n                }\n            }\n        }\n        // Count days in the current year for debugging\n        const daysInYear = new Date(selectedYear, 1, 29).getDate() === 29 ? 366 : 365;\n        const daysInCurrentYear = newGrid.flat().filter(date => date.getFullYear() === selectedYear).length;\n        // Log debug info\n        console.log(`Calendar grid for ${selectedYear}: ${newGrid.length} weeks (${newGrid.length}x7), ${daysInCurrentYear}/${daysInYear} days in year`);\n        console.log(`First date in grid: ${(0, date_fns_1.format)(newGrid[0][0], 'yyyy-MM-dd')}`);\n        console.log(`Last date in grid: ${(0, date_fns_1.format)(newGrid[newGrid.length - 1][6], 'yyyy-MM-dd')}`);\n        return newGrid;\n    }, [selectedYear]);\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Calculate available width, accounting for padding and labels\n        const isSmallScreen = window.innerWidth < 600;\n        const isMediumScreen = window.innerWidth >= 600 && window.innerWidth < 960;\n        // Reduce padding on smaller screens to maximize space for the grid\n        const containerPadding = isSmallScreen ? 20 : isMediumScreen ? 40 : 60;\n        const availableWidth = Math.min(window.innerWidth - containerPadding, 1100);\n        // Account for weekday labels\n        const effectiveWidth = availableWidth - WEEKDAY_LABEL_WIDTH;\n        // Calculate cell size based on available width and total weeks\n        // We need to fit all 53 weeks (max in a year) plus gaps\n        const totalWeeks = grid.length;\n        const totalGaps = totalWeeks - 1;\n        // Calculate cell size\n        const cellSize = (effectiveWidth - (totalGaps * CELL_GAP)) / totalWeeks;\n        // Clamp to reasonable size range\n        return Math.max(Math.min(Math.floor(cellSize * 10) / 10, 10), 2.8);\n    }, [grid]);\n    // Calculate cell size and update on window resize\n    const [CELL_SIZE, setCellSize] = (0, react_1.useState)(() => calculateCellSize());\n    (0, react_1.useEffect)(() => {\n        // Update cell size on window resize\n        const handleResize = () => {\n            setCellSize(calculateCellSize());\n        };\n        // Initial calculation\n        setCellSize(calculateCellSize());\n        // Debug grid information\n        debugGridInfo(grid);\n        // Add resize event listener\n        window.addEventListener('resize', handleResize);\n        // Cleanup\n        return () => {\n            window.removeEventListener('resize', handleResize);\n        };\n    }, [calculateCellSize, grid, debugGridInfo]);\n    // Simple month labels positioned at exact 4-column intervals\n    const monthLabels = (0, react_1.useMemo)(() => {\n        // Define the month names\n        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n        // Find column positions for the first day of each month\n        const monthColumnPositions = [];\n        // Loop through each month of the selected year\n        for (let month = 0; month < 12; month++) {\n            const firstDayOfMonth = new Date(selectedYear, month, 1);\n            // Find this date in the grid to get its column\n            let columnFound = -1;\n            // Search through the grid to find the column containing this date\n            for (let colIdx = 0; colIdx < grid.length; colIdx++) {\n                for (let rowIdx = 0; rowIdx < grid[colIdx].length; rowIdx++) {\n                    const gridDate = grid[colIdx][rowIdx];\n                    if (gridDate.getFullYear() === firstDayOfMonth.getFullYear() &&\n                        gridDate.getMonth() === firstDayOfMonth.getMonth() &&\n                        gridDate.getDate() === firstDayOfMonth.getDate()) {\n                        columnFound = colIdx;\n                        break;\n                    }\n                }\n                if (columnFound !== -1)\n                    break;\n            }\n            // If found, add to our positions array\n            if (columnFound !== -1) {\n                monthColumnPositions.push({\n                    month: monthNames[month],\n                    col: columnFound\n                });\n            }\n        }\n        return monthColumnPositions;\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        // For habits that track quantity, use the quantity value\n        if (habit.trackQuantity) {\n            if (quantity !== '') {\n                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n            }\n        }\n        else {\n            // For non-quantity habits, always mark as completed\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [habit.trackQuantity, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    // Get completion for a specific date\n    const getCompletion = (0, react_1.useCallback)((date) => {\n        const dateStr = (0, date_fns_1.format)(date, 'yyyy-MM-dd');\n        return habit.completions.find(c => c.date === dateStr);\n    }, [habit.completions]);\n    return ((0, jsx_runtime_1.jsx)(material_1.Paper, { elevation: 0, sx: {\n            p: { xs: 1, sm: 1.5, md: 2 },\n            pb: 1.5,\n            mb: 3,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 3px 10px rgba(0,0,0,0.35)'\n                : '0 3px 10px rgba(0,0,0,0.08)',\n            width: '100%',\n            maxWidth: '100%',\n            position: 'relative',\n            overflow: 'hidden'\n        }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                width: '100%',\n                mx: 'auto',\n                mb: 1,\n                position: 'relative',\n                overflowX: 'hidden',\n                overflowY: 'hidden'\n            }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                        mt: 0.5,\n                        mb: 1.5,\n                        width: '100%',\n                        overflow: 'hidden',\n                        textOverflow: 'ellipsis',\n                        color: habit.color,\n                        fontWeight: 600,\n                        letterSpacing: '0.01em',\n                        textShadow: mode === 'dark'\n                            ? '0 1px 2px rgba(0,0,0,0.3)'\n                            : '0 1px 1px rgba(0,0,0,0.1)',\n                        fontSize: '1.3rem',\n                        borderBottom: `2px solid ${habit.color}33`,\n                        paddingBottom: 0.75,\n                        position: 'relative',\n                        '&::after': {\n                            content: '\"\"',\n                            position: 'absolute',\n                            bottom: '-2px',\n                            left: 0,\n                            width: '100%',\n                            borderBottom: `2px solid ${habit.color}33`,\n                        }\n                    }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                        display: 'flex',\n                        justifyContent: 'space-between',\n                        alignItems: 'center',\n                        mb: 1,\n                        px: 1,\n                    }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: {\n                                            mx: 0.7,\n                                            fontWeight: 'bold',\n                                            color: 'text.primary',\n                                            fontSize: '0.9rem'\n                                        }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary', p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 0.7 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: {\n                                            display: 'flex',\n                                            alignItems: 'center',\n                                            fontSize: '0.9rem'\n                                        }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '3px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, { fontSize: \"small\" }), onClick: () => {\n                                        setSelectedDate(new Date());\n                                        setIsLogDialogOpen(true);\n                                    }, sx: {\n                                        py: 0.5,\n                                        px: 1.5,\n                                        minWidth: '55px',\n                                        fontSize: '0.8rem',\n                                        bgcolor: `${habit.color}99`,\n                                        '&:hover': {\n                                            bgcolor: `${habit.color}cc`,\n                                        }\n                                    }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), sx: { p: 0.7 }, children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, { fontSize: \"small\" }) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                        width: '100%',\n                        display: 'flex',\n                        flexDirection: 'column',\n                        alignItems: 'center', // Center the calendar horizontally\n                        position: 'relative',\n                        mt: 0.5,\n                        mb: 0.5,\n                        transform: `scale(${grid.length > 53 ? 0.95 : 1})`, // Slight scale down if many weeks\n                        transformOrigin: 'center top'\n                    }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                display: 'flex',\n                                width: `calc(${grid.length * (CELL_SIZE + CELL_GAP)}px)`,\n                                mb: 0.8,\n                                ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                position: 'relative',\n                                height: '20px',\n                                overflow: 'visible' // Allow labels to be visible if they extend beyond container\n                            }, children: monthLabels.map((label, idx) => ((0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    position: 'absolute',\n                                    left: `${label.col * (CELL_SIZE + CELL_GAP)}px`,\n                                    display: 'flex',\n                                    flexDirection: 'column',\n                                    alignItems: 'center',\n                                    width: CELL_SIZE, // Match cell width exactly\n                                    transform: 'translateX(-50%)', // Center precisely over the column\n                                }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                            fontSize: '0.65rem',\n                                            color: 'text.primary',\n                                            fontWeight: '600',\n                                            bgcolor: mode === 'dark' ? 'rgba(255,255,255,0.08)' : 'rgba(0,0,0,0.04)',\n                                            px: 1,\n                                            py: 0.3,\n                                            borderRadius: '10px',\n                                            border: '1px solid',\n                                            borderColor: mode === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.08)',\n                                            whiteSpace: 'nowrap', // Prevent text wrapping\n                                            position: 'relative', // For precise positioning\n                                            zIndex: 2 // Ensure label is above vertical line\n                                        }, children: label.month }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                            display: 'grid',\n                                            gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${grid.length}, ${CELL_SIZE}px)`,\n                                            gridTemplateRows: `repeat(7, ${CELL_SIZE}px)`,\n                                            gap: CELL_GAP,\n                                            mb: 0,\n                                            maxWidth: '100%',\n                                            justifyContent: 'center', // Center the grid horizontally\n                                            paddingBottom: '1px'\n                                        }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                    gridColumn: 1,\n                                                    gridRow: weekday + 1,\n                                                    justifySelf: 'end',\n                                                    pr: 0.3,\n                                                    width: WEEKDAY_LABEL_WIDTH - 2,\n                                                    height: CELL_SIZE,\n                                                    display: 'flex',\n                                                    alignItems: 'center',\n                                                    justifyContent: 'flex-end',\n                                                    bgcolor: mode === 'dark' ? 'background.paper' : 'background.paper'\n                                                }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: {\n                                                        fontSize: CELL_SIZE < 4 ? '0.5rem' : '0.55rem',\n                                                        color: 'text.secondary',\n                                                        lineHeight: 1\n                                                    }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), grid.map((weekColumn, colIdx) => (weekColumn.map((day, rowIdx) => {\n                                                // Get the date for this cell position from our grid\n                                                const cellDate = day;\n                                                // Check if this cell's date is in the current year\n                                                const isInCurrentYear = cellDate.getFullYear() === selectedYear;\n                                                // Check if this is the first day of a month\n                                                const isFirstDayOfMonth = cellDate.getDate() === 1;\n                                                const isCompleted = isDayCompleted(cellDate);\n                                                const isFuture = (0, date_fns_1.isAfter)(cellDate, new Date());\n                                                const isCurrentDay = (0, date_fns_1.isToday)(cellDate);\n                                                // Get completion details for tooltip\n                                                const completion = getCompletion(cellDate);\n                                                // Format date for tooltip\n                                                const formattedDate = (0, date_fns_1.format)(cellDate, 'EEEE, MMMM d, yyyy');\n                                                // Tooltip content\n                                                const tooltipContent = isInCurrentYear\n                                                    ? (isCompleted\n                                                        ? `${formattedDate}${completion?.quantity ? ` â€¢ ${completion.quantity} ${habit.unit || 'units'}` : ' â€¢ Completed'}`\n                                                        : formattedDate)\n                                                    : '';\n                                                // Scale cell border based on cell size\n                                                const borderWidth = CELL_SIZE > 5 ? 1 : 0.5;\n                                                return ((0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: tooltipContent, placement: \"top\", enterDelay: 500, arrow: true, disableHoverListener: !isInCurrentYear, children: (0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                            gridColumn: colIdx + 2, // +2 because first column is for weekday labels\n                                                            gridRow: rowIdx + 1,\n                                                            width: CELL_SIZE,\n                                                            height: CELL_SIZE,\n                                                            bgcolor: isCompleted && isInCurrentYear\n                                                                ? habit.color + (mode === 'dark' ? 'cc' : 'bb')\n                                                                : mode === 'dark'\n                                                                    ? (isInCurrentYear ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0)')\n                                                                    : (isInCurrentYear ? 'transparent' : 'rgba(0,0,0,0)'),\n                                                            border: isInCurrentYear\n                                                                ? `${borderWidth}px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`\n                                                                : 'none',\n                                                            borderRadius: CELL_SIZE > 5 ? '1px' : '0px',\n                                                            cursor: (isFuture || !isInCurrentYear) ? 'default' : 'pointer',\n                                                            opacity: isFuture ? 0.3 : (isInCurrentYear ? 1 : 0.2),\n                                                            transition: 'background-color 0.2s, transform 0.15s',\n                                                            // Highlight first day of each month with stronger border\n                                                            borderLeft: isFirstDayOfMonth && isInCurrentYear\n                                                                ? `${borderWidth + 0.5}px solid ${mode === 'dark' ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.4)'}`\n                                                                : undefined,\n                                                            // Highlight current day\n                                                            ...(isCurrentDay && {\n                                                                boxShadow: `0 0 0 ${borderWidth + 0.5}px ${habit.color}`\n                                                            }),\n                                                            // Hover effect for larger cells\n                                                            '&:hover': CELL_SIZE > 4 && isInCurrentYear && !isFuture ? {\n                                                                transform: 'scale(1.2)',\n                                                                zIndex: 10,\n                                                                boxShadow: `0 2px 4px rgba(0,0,0,0.2)`,\n                                                                bgcolor: isCompleted\n                                                                    ? habit.color + 'ee'\n                                                                    : mode === 'dark' ? 'rgba(255,255,255,0.15)' : 'rgba(0,0,0,0.05)'\n                                                            } : {},\n                                                            position: 'relative',\n                                                        }, onClick: () => isInCurrentYear && !isFuture && handleDayClick(cellDate), onMouseEnter: () => setHoveredDate(cellDate), onMouseLeave: () => setHoveredDate(null) }) }, `cell-${colIdx}-${rowIdx}`));\n                                            })))] })] }, idx))) }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                                sx: {\n                                    borderRadius: '12px',\n                                    boxShadow: mode === 'dark'\n                                        ? '0 8px 30px rgba(0,0,0,0.5)'\n                                        : '0 8px 30px rgba(0,0,0,0.12)',\n                                    overflow: 'hidden',\n                                    bgcolor: 'background.paper',\n                                }\n                            }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                                        borderBottom: '1px solid',\n                                        borderColor: 'divider',\n                                        pb: 2,\n                                        background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                        color: '#fff',\n                                    }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), !habit.trackQuantity ? ((0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                                        color: habit.color,\n                                                        '&.Mui-checked': {\n                                                            color: habit.color,\n                                                        }\n                                                    } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) })) : (\n                                            // For habits that track quantity, always show the quantity field\n                                            (0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                                    const val = e.target.value;\n                                                    if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                                        setQuantity(val === '' ? '' : Number(val));\n                                                    }\n                                                }, sx: {\n                                                    mt: 1,\n                                                    '& .MuiOutlinedInput-root': {\n                                                        '&.Mui-focused fieldset': {\n                                                            borderColor: habit.color,\n                                                        },\n                                                    },\n                                                    '& .MuiInputLabel-root.Mui-focused': {\n                                                        color: habit.color,\n                                                    },\n                                                }, inputProps: {\n                                                    min: 0,\n                                                    max: 1000000,\n                                                } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                                onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                                setIsLogDialogOpen(false);\n                                            }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: habit.trackQuantity && quantity === '', sx: {\n                                                borderRadius: '20px',\n                                                px: 2,\n                                                background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                                boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                            }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                                sx: {\n                                    borderRadius: '12px',\n                                    boxShadow: mode === 'dark'\n                                        ? '0 8px 30px rgba(0,0,0,0.5)'\n                                        : '0 8px 30px rgba(0,0,0,0.12)',\n                                    overflow: 'hidden',\n                                    bgcolor: 'background.paper',\n                                }\n                            }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                                        borderBottom: '1px solid',\n                                        borderColor: 'divider',\n                                        pb: 2,\n                                        bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                                        color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                                    }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                                onDelete();\n                                                setIsDeleteDialogOpen(false);\n                                            }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }), \"); }; export default HabitCard; \"] }) }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0EsNkNBQTZDLFFBQVEsNkJBQTZCLG9CQUFvQixnREFBZ0Q7QUFDdEo7QUFDQTtBQUNBLHNGQUFzRixhQUFhLE9BQU8sWUFBWTtBQUN0SCw0RUFBNEUsWUFBWTtBQUN4Riw2Q0FBNkMsb0JBQW9CLElBQUksSUFBSSxnREFBZ0Q7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw4REFBOEQ7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEIsc0RBQXNELE1BQU0sb0NBQW9DLDZEQUE2RCwwSEFBMEgsR0FBRyx1REFBdUQsTUFBTSwyRkFBMkYseURBQXlELG1EQUFtRCw2QkFBNkIsc0JBQXNCLCtDQUErQztBQUNqc0I7QUFDQTtBQUNBLDZDQUE2Qyw4Q0FBOEMsNkJBQTZCLHNCQUFzQixJQUFJLElBQUksSUFBSSxVQUFVLDBCQUEwQixJQUFJLEdBQUc7QUFDck0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2NlbnQvLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy9IYWJpdENhcmQudHN4PzQzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWxcIik7XG5jb25zdCBpY29uc19tYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvaWNvbnMtbWF0ZXJpYWxcIik7XG5jb25zdCBkYXRlX2Zuc18xID0gcmVxdWlyZShcImRhdGUtZm5zXCIpO1xuY29uc3QgVGhlbWVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vY29udGV4dC9UaGVtZUNvbnRleHRcIik7XG5jb25zdCBzdHlsZXNfMSA9IHJlcXVpcmUoXCJAbXVpL21hdGVyaWFsL3N0eWxlc1wiKTtcbmNvbnN0IEhhYml0Q2FyZCA9ICh7IGhhYml0LCBvblRvZ2dsZUNvbXBsZXRpb24sIG9uRGVsZXRlIH0pID0+IHtcbiAgICBjb25zdCB7IG1vZGUgfSA9ICgwLCBUaGVtZUNvbnRleHRfMS51c2VUaGVtZSkoKTtcbiAgICBjb25zdCBtdWlUaGVtZSA9ICgwLCBzdHlsZXNfMS51c2VUaGVtZSkoKTtcbiAgICBjb25zdCBpc1NtYWxsU2NyZWVuID0gKDAsIG1hdGVyaWFsXzEudXNlTWVkaWFRdWVyeSkobXVpVGhlbWUuYnJlYWtwb2ludHMuZG93bignc20nKSk7XG4gICAgY29uc3QgW2lzTG9nRGlhbG9nT3Blbiwgc2V0SXNMb2dEaWFsb2dPcGVuXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW2lzRGVsZXRlRGlhbG9nT3Blbiwgc2V0SXNEZWxldGVEaWFsb2dPcGVuXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgW3NlbGVjdGVkRGF0ZSwgc2V0U2VsZWN0ZWREYXRlXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShuZXcgRGF0ZSgpKTtcbiAgICBjb25zdCBbcXVhbnRpdHksIHNldFF1YW50aXR5XSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgnJyk7XG4gICAgY29uc3QgW3VzZUNoZWNrYm94LCBzZXRVc2VDaGVja2JveF0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkodHJ1ZSk7XG4gICAgY29uc3QgW3NlbGVjdGVkWWVhciwgc2V0U2VsZWN0ZWRZZWFyXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuICAgIGNvbnN0IFtob3ZlcmVkRGF0ZSwgc2V0SG92ZXJlZERhdGVdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKG51bGwpO1xuICAgIC8vIERlZmluZSBjb25zdGFudHMgZmlyc3RcbiAgICBjb25zdCBDRUxMX0dBUCA9IDE7IC8vIE1pbmltdW0gZ2FwIGZvciBjb21wYWN0IGxheW91dFxuICAgIGNvbnN0IFdFRUtEQVlfTEFCRUxfV0lEVEggPSAxNTsgLy8gU21hbGxlciB3aWR0aCBmb3Igd2Vla2RheSBsYWJlbHNcbiAgICAvLyBEZWJ1ZyBmdW5jdGlvbiB0byBsb2cgZ3JpZCBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGRlYnVnR3JpZEluZm8gPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGdyaWQpID0+IHtcbiAgICAgICAgY29uc3QgdG90YWxXZWVrcyA9IGdyaWQubGVuZ3RoO1xuICAgICAgICBjb25zdCBkYXlzSW5GdWxsWWVhciA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMCwgMCkuZ2V0RGF0ZSgpID09PSAzNjYgPyAzNjYgOiAzNjU7XG4gICAgICAgIGNvbnN0IGRheXNJbkN1cnJlbnRZZWFyID0gZ3JpZC5mbGF0KCkuZmlsdGVyKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIpLmxlbmd0aDtcbiAgICAgICAgY29uc3QgamFuMSA9IGdyaWQuZmxhdCgpLmZpbmQoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDAgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDEpO1xuICAgICAgICBjb25zdCBkZWMzMSA9IGdyaWQuZmxhdCgpLmZpbmQoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDExICYmIGRhdGUuZ2V0RGF0ZSgpID09PSAzMSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBHcmlkIGZvciAke3NlbGVjdGVkWWVhcn06ICR7dG90YWxXZWVrc30gd2Vla3Mgw5cgNyBkYXlzYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBEYXlzIGluIHllYXI6ICR7ZGF5c0luRnVsbFllYXJ9LCBkYXlzIGRpc3BsYXllZCBmcm9tIHllYXI6ICR7ZGF5c0luQ3VycmVudFllYXJ9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBKYW4gMSBwcmVzZW50OiAkeyEhamFuMX0sIERlYyAzMSBwcmVzZW50OiAkeyEhZGVjMzF9YCk7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBncmlkIGlzIDUyIG9yIDUzIHdlZWtzIChzdGFuZGFyZCBmb3IgYSB5ZWFyKVxuICAgICAgICBjb25zdCBpc1N0YW5kYXJkU2l6ZSA9IHRvdGFsV2Vla3MgPj0gNTIgJiYgdG90YWxXZWVrcyA8PSA1MztcbiAgICAgICAgY29uc29sZS5sb2coYEdyaWQgc2l6ZSBjaGVjazogJHtpc1N0YW5kYXJkU2l6ZSA/ICdQQVNTRUQnIDogJ0ZBSUxFRCd9IC0gJHt0b3RhbFdlZWtzfSB3ZWVrcyAoc2hvdWxkIGJlIDUyLTUzKWApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2l6ZTogdG90YWxXZWVrcyxcbiAgICAgICAgICAgIGRheXNJblllYXI6IGRheXNJbkN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgaGFzSmFuMTogISFqYW4xLFxuICAgICAgICAgICAgaGFzRGVjMzE6ICEhZGVjMzEsXG4gICAgICAgICAgICBpc0NvcnJlY3RTaXplOiBpc1N0YW5kYXJkU2l6ZVxuICAgICAgICB9O1xuICAgIH0sIFtzZWxlY3RlZFllYXJdKTtcbiAgICAvLyBCdWlsZCBncmlkOiBncmlkW2NvbF1bcm93XSA9IGRhdGUgb3IgbnVsbFxuICAgIC8vIENvbCA9IHdlZWssIFJvdyA9IHdlZWtkYXlcbiAgICBjb25zdCBncmlkID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4ge1xuICAgICAgICAvLyBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXMgZm9yIHRoZSB5ZWFyXG4gICAgICAgIGNvbnN0IGphbjEgPSBuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDAsIDEpO1xuICAgICAgICBjb25zdCBkZWMzMSA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMTEsIDMxKTtcbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgU3VuZGF5IGJlZm9yZSBvciBvbiBKYW4gMVxuICAgICAgICBjb25zdCBmaXJzdERheU9mR3JpZCA9IG5ldyBEYXRlKGphbjEpO1xuICAgICAgICBjb25zdCBmaXJzdERheU9mV2VlayA9ICgwLCBkYXRlX2Zuc18xLmdldERheSkoZmlyc3REYXlPZkdyaWQpO1xuICAgICAgICBmaXJzdERheU9mR3JpZC5zZXREYXRlKGZpcnN0RGF5T2ZHcmlkLmdldERhdGUoKSAtIGZpcnN0RGF5T2ZXZWVrKTtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCBTYXR1cmRheSBhZnRlciBvciBvbiBEZWMgMzFcbiAgICAgICAgY29uc3QgbGFzdERheU9mR3JpZCA9IG5ldyBEYXRlKGRlYzMxKTtcbiAgICAgICAgY29uc3QgbGFzdERheU9mV2VlayA9ICgwLCBkYXRlX2Zuc18xLmdldERheSkobGFzdERheU9mR3JpZCk7XG4gICAgICAgIGxhc3REYXlPZkdyaWQuc2V0RGF0ZShsYXN0RGF5T2ZHcmlkLmdldERhdGUoKSArICg2IC0gbGFzdERheU9mV2VlaykpO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiB3ZWVrc1xuICAgICAgICBjb25zdCB0b3RhbFdlZWtzID0gTWF0aC5jZWlsKChsYXN0RGF5T2ZHcmlkLmdldFRpbWUoKSAtIGZpcnN0RGF5T2ZHcmlkLmdldFRpbWUoKSkgLyAoNyAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBncmlkIHdpdGggdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHdlZWtzXG4gICAgICAgIGNvbnN0IG5ld0dyaWQgPSBbXTtcbiAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBncmlkXG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKGZpcnN0RGF5T2ZHcmlkKTtcbiAgICAgICAgLy8gR2VuZXJhdGUgYWxsIHdlZWtzXG4gICAgICAgIGZvciAobGV0IHdlZWsgPSAwOyB3ZWVrIDwgdG90YWxXZWVrczsgd2VlaysrKSB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrUm93ID0gW107XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBkYXlzIGZvciBlYWNoIHdlZWtcbiAgICAgICAgICAgIGZvciAobGV0IGRheSA9IDA7IGRheSA8IDc7IGRheSsrKSB7XG4gICAgICAgICAgICAgICAgd2Vla1Jvdy5wdXNoKG5ldyBEYXRlKGN1cnJlbnREYXRlKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0dyaWQucHVzaCh3ZWVrUm93KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBEZWNlbWJlciAzMXN0IGlzIGluY2x1ZGVkIGluIHRoZSBncmlkXG4gICAgICAgIGNvbnN0IGhhc0RlYzMxID0gbmV3R3JpZC5mbGF0KCkuc29tZShkYXRlID0+IGRhdGUuZ2V0RnVsbFllYXIoKSA9PT0gc2VsZWN0ZWRZZWFyICYmIGRhdGUuZ2V0TW9udGgoKSA9PT0gMTEgJiYgZGF0ZS5nZXREYXRlKCkgPT09IDMxKTtcbiAgICAgICAgLy8gSWYgRGVjZW1iZXIgMzFzdCBpcyBtaXNzaW5nLCBhZGQgYWRkaXRpb25hbCB3ZWVrcyB1bnRpbCB3ZSBpbmNsdWRlIGl0XG4gICAgICAgIGlmICghaGFzRGVjMzEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVjZW1iZXIgMzFzdCwgJHtzZWxlY3RlZFllYXJ9IGlzIG1pc3NpbmcgZnJvbSB0aGUgZ3JpZC4gRXh0ZW5kaW5nIGdyaWQuYCk7XG4gICAgICAgICAgICAvLyBDb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZlxuICAgICAgICAgICAgbGV0IGFkZGl0aW9uYWxEYXRlID0gbmV3IERhdGUoY3VycmVudERhdGUpO1xuICAgICAgICAgICAgLy8gQWRkIHVwIHRvIDQgYWRkaXRpb25hbCB3ZWVrcyAoc2hvdWxkIGJlIGVub3VnaCBpbiBhbGwgY2FzZXMpXG4gICAgICAgICAgICBmb3IgKGxldCB3ZWVrID0gMDsgd2VlayA8IDQ7IHdlZWsrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdlZWtSb3cgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkYXkgPSAwOyBkYXkgPCA3OyBkYXkrKykge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrUm93LnB1c2gobmV3IERhdGUoYWRkaXRpb25hbERhdGUpKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbERhdGUuc2V0RGF0ZShhZGRpdGlvbmFsRGF0ZS5nZXREYXRlKCkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UndmUgbm93IGluY2x1ZGVkIERlY2VtYmVyIDMxc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxEYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0RlYzMxTm93ID0gbmV3R3JpZC5mbGF0KCkuY29uY2F0KHdlZWtSb3cpLnNvbWUoZGF0ZSA9PiBkYXRlLmdldEZ1bGxZZWFyKCkgPT09IHNlbGVjdGVkWWVhciAmJiBkYXRlLmdldE1vbnRoKCkgPT09IDExICYmIGRhdGUuZ2V0RGF0ZSgpID09PSAzMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRGVjMzFOb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdHcmlkLnB1c2god2Vla1Jvdyk7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgRGVjZW1iZXIgMzFzdCBpcyBub3cgaW4gdGhlIGdyaWQgYWZ0ZXIgYWRkaW5nIHRoaXMgd2Vla1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zRGVjMzEgPSBuZXdHcmlkLmZsYXQoKS5zb21lKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIgJiYgZGF0ZS5nZXRNb250aCgpID09PSAxMSAmJiBkYXRlLmdldERhdGUoKSA9PT0gMzEpO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc0RlYzMxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBHcmlkIGV4dGVuZGVkLiBEZWNlbWJlciAzMXN0LCAke3NlbGVjdGVkWWVhcn0gaXMgbm93IGluY2x1ZGVkLmApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ291bnQgZGF5cyBpbiB0aGUgY3VycmVudCB5ZWFyIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29uc3QgZGF5c0luWWVhciA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgMSwgMjkpLmdldERhdGUoKSA9PT0gMjkgPyAzNjYgOiAzNjU7XG4gICAgICAgIGNvbnN0IGRheXNJbkN1cnJlbnRZZWFyID0gbmV3R3JpZC5mbGF0KCkuZmlsdGVyKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXIpLmxlbmd0aDtcbiAgICAgICAgLy8gTG9nIGRlYnVnIGluZm9cbiAgICAgICAgY29uc29sZS5sb2coYENhbGVuZGFyIGdyaWQgZm9yICR7c2VsZWN0ZWRZZWFyfTogJHtuZXdHcmlkLmxlbmd0aH0gd2Vla3MgKCR7bmV3R3JpZC5sZW5ndGh9eDcpLCAke2RheXNJbkN1cnJlbnRZZWFyfS8ke2RheXNJblllYXJ9IGRheXMgaW4geWVhcmApO1xuICAgICAgICBjb25zb2xlLmxvZyhgRmlyc3QgZGF0ZSBpbiBncmlkOiAkeygwLCBkYXRlX2Zuc18xLmZvcm1hdCkobmV3R3JpZFswXVswXSwgJ3l5eXktTU0tZGQnKX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYExhc3QgZGF0ZSBpbiBncmlkOiAkeygwLCBkYXRlX2Zuc18xLmZvcm1hdCkobmV3R3JpZFtuZXdHcmlkLmxlbmd0aCAtIDFdWzZdLCAneXl5eS1NTS1kZCcpfWApO1xuICAgICAgICByZXR1cm4gbmV3R3JpZDtcbiAgICB9LCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgLy8gRGVmaW5lIGR5bmFtaWMgY2VsbCBzaXplIGJhc2VkIG9uIGF2YWlsYWJsZSB3aWR0aFxuICAgIGNvbnN0IGNhbGN1bGF0ZUNlbGxTaXplID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGF2YWlsYWJsZSB3aWR0aCwgYWNjb3VudGluZyBmb3IgcGFkZGluZyBhbmQgbGFiZWxzXG4gICAgICAgIGNvbnN0IGlzU21hbGxTY3JlZW4gPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDYwMDtcbiAgICAgICAgY29uc3QgaXNNZWRpdW1TY3JlZW4gPSB3aW5kb3cuaW5uZXJXaWR0aCA+PSA2MDAgJiYgd2luZG93LmlubmVyV2lkdGggPCA5NjA7XG4gICAgICAgIC8vIFJlZHVjZSBwYWRkaW5nIG9uIHNtYWxsZXIgc2NyZWVucyB0byBtYXhpbWl6ZSBzcGFjZSBmb3IgdGhlIGdyaWRcbiAgICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGlzU21hbGxTY3JlZW4gPyAyMCA6IGlzTWVkaXVtU2NyZWVuID8gNDAgOiA2MDtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1pbih3aW5kb3cuaW5uZXJXaWR0aCAtIGNvbnRhaW5lclBhZGRpbmcsIDExMDApO1xuICAgICAgICAvLyBBY2NvdW50IGZvciB3ZWVrZGF5IGxhYmVsc1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVXaWR0aCA9IGF2YWlsYWJsZVdpZHRoIC0gV0VFS0RBWV9MQUJFTF9XSURUSDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNlbGwgc2l6ZSBiYXNlZCBvbiBhdmFpbGFibGUgd2lkdGggYW5kIHRvdGFsIHdlZWtzXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gZml0IGFsbCA1MyB3ZWVrcyAobWF4IGluIGEgeWVhcikgcGx1cyBnYXBzXG4gICAgICAgIGNvbnN0IHRvdGFsV2Vla3MgPSBncmlkLmxlbmd0aDtcbiAgICAgICAgY29uc3QgdG90YWxHYXBzID0gdG90YWxXZWVrcyAtIDE7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBjZWxsIHNpemVcbiAgICAgICAgY29uc3QgY2VsbFNpemUgPSAoZWZmZWN0aXZlV2lkdGggLSAodG90YWxHYXBzICogQ0VMTF9HQVApKSAvIHRvdGFsV2Vla3M7XG4gICAgICAgIC8vIENsYW1wIHRvIHJlYXNvbmFibGUgc2l6ZSByYW5nZVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5mbG9vcihjZWxsU2l6ZSAqIDEwKSAvIDEwLCAxMCksIDIuOCk7XG4gICAgfSwgW2dyaWRdKTtcbiAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIGFuZCB1cGRhdGUgb24gd2luZG93IHJlc2l6ZVxuICAgIGNvbnN0IFtDRUxMX1NJWkUsIHNldENlbGxTaXplXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgoKSA9PiBjYWxjdWxhdGVDZWxsU2l6ZSgpKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgLy8gVXBkYXRlIGNlbGwgc2l6ZSBvbiB3aW5kb3cgcmVzaXplXG4gICAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNldENlbGxTaXplKGNhbGN1bGF0ZUNlbGxTaXplKCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbml0aWFsIGNhbGN1bGF0aW9uXG4gICAgICAgIHNldENlbGxTaXplKGNhbGN1bGF0ZUNlbGxTaXplKCkpO1xuICAgICAgICAvLyBEZWJ1ZyBncmlkIGluZm9ybWF0aW9uXG4gICAgICAgIGRlYnVnR3JpZEluZm8oZ3JpZCk7XG4gICAgICAgIC8vIEFkZCByZXNpemUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtjYWxjdWxhdGVDZWxsU2l6ZSwgZ3JpZCwgZGVidWdHcmlkSW5mb10pO1xuICAgIC8vIFNpbXBsZSBtb250aCBsYWJlbHMgcG9zaXRpb25lZCBhdCBleGFjdCA0LWNvbHVtbiBpbnRlcnZhbHNcbiAgICBjb25zdCBtb250aExhYmVscyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgLy8gRGVmaW5lIHRoZSBtb250aCBuYW1lc1xuICAgICAgICBjb25zdCBtb250aE5hbWVzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYyddO1xuICAgICAgICAvLyBGaW5kIGNvbHVtbiBwb3NpdGlvbnMgZm9yIHRoZSBmaXJzdCBkYXkgb2YgZWFjaCBtb250aFxuICAgICAgICBjb25zdCBtb250aENvbHVtblBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBtb250aCBvZiB0aGUgc2VsZWN0ZWQgeWVhclxuICAgICAgICBmb3IgKGxldCBtb250aCA9IDA7IG1vbnRoIDwgMTI7IG1vbnRoKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGF5T2ZNb250aCA9IG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgbW9udGgsIDEpO1xuICAgICAgICAgICAgLy8gRmluZCB0aGlzIGRhdGUgaW4gdGhlIGdyaWQgdG8gZ2V0IGl0cyBjb2x1bW5cbiAgICAgICAgICAgIGxldCBjb2x1bW5Gb3VuZCA9IC0xO1xuICAgICAgICAgICAgLy8gU2VhcmNoIHRocm91Z2ggdGhlIGdyaWQgdG8gZmluZCB0aGUgY29sdW1uIGNvbnRhaW5pbmcgdGhpcyBkYXRlXG4gICAgICAgICAgICBmb3IgKGxldCBjb2xJZHggPSAwOyBjb2xJZHggPCBncmlkLmxlbmd0aDsgY29sSWR4KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCBncmlkW2NvbElkeF0ubGVuZ3RoOyByb3dJZHgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmlkRGF0ZSA9IGdyaWRbY29sSWR4XVtyb3dJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZERhdGUuZ2V0RnVsbFllYXIoKSA9PT0gZmlyc3REYXlPZk1vbnRoLmdldEZ1bGxZZWFyKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWREYXRlLmdldE1vbnRoKCkgPT09IGZpcnN0RGF5T2ZNb250aC5nZXRNb250aCgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBncmlkRGF0ZS5nZXREYXRlKCkgPT09IGZpcnN0RGF5T2ZNb250aC5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkZvdW5kID0gY29sSWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbkZvdW5kICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBmb3VuZCwgYWRkIHRvIG91ciBwb3NpdGlvbnMgYXJyYXlcbiAgICAgICAgICAgIGlmIChjb2x1bW5Gb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBtb250aENvbHVtblBvc2l0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IG1vbnRoTmFtZXNbbW9udGhdLFxuICAgICAgICAgICAgICAgICAgICBjb2w6IGNvbHVtbkZvdW5kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vbnRoQ29sdW1uUG9zaXRpb25zO1xuICAgIH0sIFtncmlkLCBzZWxlY3RlZFllYXJdKTtcbiAgICBjb25zdCBpc0hhYml0Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIGNvbnN0IGNhbGN1bGF0ZVN0cmVhayA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIGxldCBzdHJlYWsgPSAwO1xuICAgICAgICBjb25zdCB0b2RheSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHdoaWxlIChpc0hhYml0Q29tcGxldGVkKGN1cnJlbnREYXRlKSAmJiAhKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoY3VycmVudERhdGUsIHRvZGF5KSkge1xuICAgICAgICAgICAgc3RyZWFrKys7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYWs7XG4gICAgfSwgW2lzSGFiaXRDb21wbGV0ZWRdKTtcbiAgICBjb25zdCBoYW5kbGVMb2dTdWJtaXQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICAvLyBGb3IgaGFiaXRzIHRoYXQgdHJhY2sgcXVhbnRpdHksIHVzZSB0aGUgcXVhbnRpdHkgdmFsdWVcbiAgICAgICAgaWYgKGhhYml0LnRyYWNrUXVhbnRpdHkpIHtcbiAgICAgICAgICAgIGlmIChxdWFudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJyksIE51bWJlcihxdWFudGl0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1xdWFudGl0eSBoYWJpdHMsIGFsd2F5cyBtYXJrIGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICBzZXRRdWFudGl0eSgnJyk7XG4gICAgICAgIHNldFVzZUNoZWNrYm94KHRydWUpO1xuICAgIH0sIFtoYWJpdC50cmFja1F1YW50aXR5LCBzZWxlY3RlZERhdGUsIHF1YW50aXR5LCBvblRvZ2dsZUNvbXBsZXRpb25dKTtcbiAgICBjb25zdCBoYW5kbGVEYXlDbGljayA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF5KSA9PiB7XG4gICAgICAgIGlmICgoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShkYXksIG5ldyBEYXRlKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IGFsbG93IGxvZ2dpbmcgZnV0dXJlIGRhdGVzXG4gICAgICAgIH1cbiAgICAgICAgc2V0U2VsZWN0ZWREYXRlKGRheSk7XG4gICAgICAgIHNldElzTG9nRGlhbG9nT3Blbih0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc3RyZWFrID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gY2FsY3VsYXRlU3RyZWFrKCksIFtjYWxjdWxhdGVTdHJlYWtdKTtcbiAgICBjb25zdCBpc0RheUNvbXBsZXRlZCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoZGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4gaGFiaXQuY29tcGxldGlvbnMuc29tZShjb21wbGV0aW9uID0+IGNvbXBsZXRpb24uZGF0ZSA9PT0gKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShkYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICBjb25zdCBoYW5kbGVQcmV2WWVhciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkWWVhcihwcmV2ID0+IHByZXYgLSAxKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaGFuZGxlTmV4dFllYXIgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICBzZXRTZWxlY3RlZFllYXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgfSwgW10pO1xuICAgIC8vIEdldCBjb21wbGV0aW9uIGZvciBhIHNwZWNpZmljIGRhdGVcbiAgICBjb25zdCBnZXRDb21wbGV0aW9uID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGVTdHIgPSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJyk7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5maW5kKGMgPT4gYy5kYXRlID09PSBkYXRlU3RyKTtcbiAgICB9LCBbaGFiaXQuY29tcGxldGlvbnNdKTtcbiAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5QYXBlciwgeyBlbGV2YXRpb246IDAsIHN4OiB7XG4gICAgICAgICAgICBwOiB7IHhzOiAxLCBzbTogMS41LCBtZDogMiB9LFxuICAgICAgICAgICAgcGI6IDEuNSxcbiAgICAgICAgICAgIG1iOiAzLFxuICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgID8gJzAgM3B4IDEwcHggcmdiYSgwLDAsMCwwLjM1KSdcbiAgICAgICAgICAgICAgICA6ICcwIDNweCAxMHB4IHJnYmEoMCwwLDAsMC4wOCknLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIG14OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6ICdoaWRkZW4nXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiaDVcIiwgYWxpZ246IFwiY2VudGVyXCIsIG5vV3JhcDogdHJ1ZSwgdGl0bGU6IGhhYml0Lm5hbWUsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDEuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA2MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAnMC4wMWVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgMXB4IDJweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4xKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzEuM3JlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLjc1LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJy0ycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAycHggc29saWQgJHtoYWJpdC5jb2xvcn0zM2AsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBoYWJpdC5uYW1lIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBweDogMSxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIG9uQ2xpY2s6IGhhbmRsZVByZXZZZWFyLCBzeDogeyBjb2xvcjogJ3RleHQucHJpbWFyeScsIHA6IDAuNyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25MZWZ0LCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXg6IDAuNyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQucHJpbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC45cmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBzZWxlY3RlZFllYXIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlTmV4dFllYXIsIGRpc2FibGVkOiBzZWxlY3RlZFllYXIgPj0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpLCBzeDogeyBjb2xvcjogJ3RleHQucHJpbWFyeScsIHA6IDAuNyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25SaWdodCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZ2FwOiAwLjcgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVG9vbHRpcCwgeyB0aXRsZTogYEN1cnJlbnQgc3RyZWFrOiAke3N0cmVha30gZGF5c2AsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBjb2xvcjogXCJ0ZXh0LnNlY29uZGFyeVwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuOXJlbSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1wiXFx1RDgzRFxcdUREMjUgXCIsICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgc3R5bGU6IHsgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAnM3B4JyB9LCBjaGlsZHJlbjogc3RyZWFrIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBzaXplOiBcInNtYWxsXCIsIHN0YXJ0SWNvbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkFkZCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0U2VsZWN0ZWREYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzTG9nRGlhbG9nT3Blbih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHk6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweDogMS41LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiAnNTVweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcwLjhyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGAke2hhYml0LmNvbG9yfTk5YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogYCR7aGFiaXQuY29sb3J9Y2NgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkxvZ1wiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIGNvbG9yOiBcImVycm9yXCIsIG9uQ2xpY2s6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3Blbih0cnVlKSwgc3g6IHsgcDogMC43IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuRGVsZXRlLCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSkgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLCAvLyBDZW50ZXIgdGhlIGNhbGVuZGFyIGhvcml6b250YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdDogMC41LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7Z3JpZC5sZW5ndGggPiA1MyA/IDAuOTUgOiAxfSlgLCAvLyBTbGlnaHQgc2NhbGUgZG93biBpZiBtYW55IHdlZWtzXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICdjZW50ZXIgdG9wJ1xuICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYGNhbGMoJHtncmlkLmxlbmd0aCAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCl9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAuOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWw6IGAke1dFRUtEQVlfTEFCRUxfV0lEVEh9cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMjBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAndmlzaWJsZScgLy8gQWxsb3cgbGFiZWxzIHRvIGJlIHZpc2libGUgaWYgdGhleSBleHRlbmQgYmV5b25kIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBtb250aExhYmVscy5tYXAoKGxhYmVsLCBpZHgpID0+ICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBgJHtsYWJlbC5jb2wgKiAoQ0VMTF9TSVpFICsgQ0VMTF9HQVApfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogQ0VMTF9TSVpFLCAvLyBNYXRjaCBjZWxsIHdpZHRoIGV4YWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknLCAvLyBDZW50ZXIgcHJlY2lzZWx5IG92ZXIgdGhlIGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiY2FwdGlvblwiLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzAuNjVyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQucHJpbWFyeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICc2MDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjA4KScgOiAncmdiYSgwLDAsMCwwLjA0KScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBweTogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMSknIDogJ3JnYmEoMCwwLDAsMC4wOCknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJywgLy8gUHJldmVudCB0ZXh0IHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLCAvLyBGb3IgcHJlY2lzZSBwb3NpdGlvbmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IDIgLy8gRW5zdXJlIGxhYmVsIGlzIGFib3ZlIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogbGFiZWwubW9udGggfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdncmlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFRlbXBsYXRlQ29sdW1uczogYCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weCByZXBlYXQoJHtncmlkLmxlbmd0aH0sICR7Q0VMTF9TSVpFfXB4KWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRUZW1wbGF0ZVJvd3M6IGByZXBlYXQoNywgJHtDRUxMX1NJWkV9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FwOiBDRUxMX0dBUCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJywgLy8gQ2VudGVyIHRoZSBncmlkIGhvcml6b250YWxseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnMXB4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcCgod2Vla2RheSkgPT4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkQ29sdW1uOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHdlZWtkYXkgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlTZWxmOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcjogMC4zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBXRUVLREFZX0xBQkVMX1dJRFRIIC0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJ2JhY2tncm91bmQucGFwZXInIDogJ2JhY2tncm91bmQucGFwZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBDRUxMX1NJWkUgPCA0ID8gJzAuNXJlbScgOiAnMC41NXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddW3dlZWtkYXldIH0pIH0sIHdlZWtkYXkpKSksIGdyaWQubWFwKCh3ZWVrQ29sdW1uLCBjb2xJZHgpID0+ICh3ZWVrQ29sdW1uLm1hcCgoZGF5LCByb3dJZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZGF0ZSBmb3IgdGhpcyBjZWxsIHBvc2l0aW9uIGZyb20gb3VyIGdyaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRlID0gZGF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjZWxsJ3MgZGF0ZSBpcyBpbiB0aGUgY3VycmVudCB5ZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0luQ3VycmVudFllYXIgPSBjZWxsRGF0ZS5nZXRGdWxsWWVhcigpID09PSBzZWxlY3RlZFllYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIHRoZSBmaXJzdCBkYXkgb2YgYSBtb250aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNGaXJzdERheU9mTW9udGggPSBjZWxsRGF0ZS5nZXREYXRlKCkgPT09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9IGlzRGF5Q29tcGxldGVkKGNlbGxEYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnV0dXJlID0gKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoY2VsbERhdGUsIG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RGF5ID0gKDAsIGRhdGVfZm5zXzEuaXNUb2RheSkoY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbXBsZXRpb24gZGV0YWlscyBmb3IgdG9vbHRpcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcGxldGlvbiA9IGdldENvbXBsZXRpb24oY2VsbERhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9ybWF0IGRhdGUgZm9yIHRvb2x0aXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGNlbGxEYXRlLCAnRUVFRSwgTU1NTSBkLCB5eXl5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUb29sdGlwIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2x0aXBDb250ZW50ID0gaXNJbkN1cnJlbnRZZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtmb3JtYXR0ZWREYXRlfSR7Y29tcGxldGlvbj8ucXVhbnRpdHkgPyBgIOKAoiAke2NvbXBsZXRpb24ucXVhbnRpdHl9ICR7aGFiaXQudW5pdCB8fCAndW5pdHMnfWAgOiAnIOKAoiBDb21wbGV0ZWQnfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXR0ZWREYXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSBjZWxsIGJvcmRlciBiYXNlZCBvbiBjZWxsIHNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gQ0VMTF9TSVpFID4gNSA/IDEgOiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Ub29sdGlwLCB7IHRpdGxlOiB0b29sdGlwQ29udGVudCwgcGxhY2VtZW50OiBcInRvcFwiLCBlbnRlckRlbGF5OiA1MDAsIGFycm93OiB0cnVlLCBkaXNhYmxlSG92ZXJMaXN0ZW5lcjogIWlzSW5DdXJyZW50WWVhciwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRDb2x1bW46IGNvbElkeCArIDIsIC8vICsyIGJlY2F1c2UgZmlyc3QgY29sdW1uIGlzIGZvciB3ZWVrZGF5IGxhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZFJvdzogcm93SWR4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBDRUxMX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IENFTExfU0laRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGlzQ29tcGxldGVkICYmIGlzSW5DdXJyZW50WWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaGFiaXQuY29sb3IgKyAobW9kZSA9PT0gJ2RhcmsnID8gJ2NjJyA6ICdiYicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoaXNJbkN1cnJlbnRZZWFyID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4wNSknIDogJ3JnYmEoMCwwLDAsMCknKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChpc0luQ3VycmVudFllYXIgPyAndHJhbnNwYXJlbnQnIDogJ3JnYmEoMCwwLDAsMCknKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogaXNJbkN1cnJlbnRZZWFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtib3JkZXJXaWR0aH1weCBzb2xpZCAke21vZGUgPT09ICdkYXJrJyA/ICcjNDQ0JyA6ICcjZTBlMGUwJ31gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IENFTExfU0laRSA+IDUgPyAnMXB4JyA6ICcwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAoaXNGdXR1cmUgfHwgIWlzSW5DdXJyZW50WWVhcikgPyAnZGVmYXVsdCcgOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0Z1dHVyZSA/IDAuMyA6IChpc0luQ3VycmVudFllYXIgPyAxIDogMC4yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb246ICdiYWNrZ3JvdW5kLWNvbG9yIDAuMnMsIHRyYW5zZm9ybSAwLjE1cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIaWdobGlnaHQgZmlyc3QgZGF5IG9mIGVhY2ggbW9udGggd2l0aCBzdHJvbmdlciBib3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckxlZnQ6IGlzRmlyc3REYXlPZk1vbnRoICYmIGlzSW5DdXJyZW50WWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7Ym9yZGVyV2lkdGggKyAwLjV9cHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjQpJyA6ICdyZ2JhKDAsMCwwLDAuNCknfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhpZ2hsaWdodCBjdXJyZW50IGRheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGlzQ3VycmVudERheSAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBgMCAwIDAgJHtib3JkZXJXaWR0aCArIDAuNX1weCAke2hhYml0LmNvbG9yfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG92ZXIgZWZmZWN0IGZvciBsYXJnZXIgY2VsbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzogQ0VMTF9TSVpFID4gNCAmJiBpc0luQ3VycmVudFllYXIgJiYgIWlzRnV0dXJlID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEuMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBgMCAycHggNHB4IHJnYmEoMCwwLDAsMC4yKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogaXNDb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBoYWJpdC5jb2xvciArICdlZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjE1KScgOiAncmdiYSgwLDAsMCwwLjA1KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBvbkNsaWNrOiAoKSA9PiBpc0luQ3VycmVudFllYXIgJiYgIWlzRnV0dXJlICYmIGhhbmRsZURheUNsaWNrKGNlbGxEYXRlKSwgb25Nb3VzZUVudGVyOiAoKSA9PiBzZXRIb3ZlcmVkRGF0ZShjZWxsRGF0ZSksIG9uTW91c2VMZWF2ZTogKCkgPT4gc2V0SG92ZXJlZERhdGUobnVsbCkgfSkgfSwgYGNlbGwtJHtjb2xJZHh9LSR7cm93SWR4fWApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV0gfSldIH0sIGlkeCkpKSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2csIHsgb3BlbjogaXNMb2dEaWFsb2dPcGVuLCBvbkNsb3NlOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBtYXhXaWR0aDogXCJ4c1wiLCBmdWxsV2lkdGg6IHRydWUsIFBhcGVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC4xMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ1RpdGxlLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBiOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGBsaW5lYXItZ3JhZGllbnQoNDVkZWcsICR7aGFiaXQuY29sb3J9IDMwJSwgJHtoYWJpdC5jb2xvcn05OSA5MCUpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtcIkxvZyBcIiwgaGFiaXQubmFtZV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dDb250ZW50LCB7IHN4OiB7IGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgbXQ6IDIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJzdWJ0aXRsZTJcIiwgZ3V0dGVyQm90dG9tOiB0cnVlLCBjb2xvcjogXCJ0ZXh0LnByaW1hcnlcIiwgY2hpbGRyZW46IFtcIkRhdGU6IFwiLCAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ01NTU0gZCwgeXl5eScpXSB9KSwgIWhhYml0LnRyYWNrUXVhbnRpdHkgPyAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkZvcm1Db250cm9sTGFiZWwsIHsgY29udHJvbDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkNoZWNrYm94LCB7IGNoZWNrZWQ6IHVzZUNoZWNrYm94LCBvbkNoYW5nZTogKGUpID0+IHNldFVzZUNoZWNrYm94KGUudGFyZ2V0LmNoZWNrZWQpLCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmLk11aS1jaGVja2VkJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB9KSwgbGFiZWw6ICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogXCJNYXJrIGFzIGNvbXBsZXRlZFwiIH0pIH0pKSA6IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGhhYml0cyB0aGF0IHRyYWNrIHF1YW50aXR5LCBhbHdheXMgc2hvdyB0aGUgcXVhbnRpdHkgZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRleHRGaWVsZCwgeyBmdWxsV2lkdGg6IHRydWUsIHR5cGU6IFwibnVtYmVyXCIsIGxhYmVsOiBgUXVhbnRpdHkke2hhYml0LnVuaXQgPyBgICgke2hhYml0LnVuaXR9KWAgOiAnJ31gLCB2YWx1ZTogcXVhbnRpdHksIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IChOdW1iZXIodmFsKSA+PSAwICYmIE51bWJlcih2YWwpIDw9IDEwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFF1YW50aXR5KHZhbCA9PT0gJycgPyAnJyA6IE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIC5NdWlPdXRsaW5lZElucHV0LXJvb3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmLk11aS1mb2N1c2VkIGZpZWxkc2V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgLk11aUlucHV0TGFiZWwtcm9vdC5NdWktZm9jdXNlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBpbnB1dFByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksIGlzRGF5Q29tcGxldGVkKHNlbGVjdGVkRGF0ZSkgJiYgKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgY29sb3I6IFwid2FybmluZ1wiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIlVuZG9cIiB9KSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlTG9nU3VibWl0LCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBkaXNhYmxlZDogaGFiaXQudHJhY2tRdWFudGl0eSAmJiBxdWFudGl0eSA9PT0gJycsIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHtoYWJpdC5jb2xvcn0gMzAlLCAke2hhYml0LmNvbG9yfTk5IDkwJSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBgMCAzcHggNXB4IDJweCAke2hhYml0LmNvbG9yfTMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFwiU2F2ZVwiIH0pXSB9KV0gfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nLCB7IG9wZW46IGlzRGVsZXRlRGlhbG9nT3Blbiwgb25DbG9zZTogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgbWF4V2lkdGg6IFwieHNcIiwgZnVsbFdpZHRoOiB0cnVlLCBQYXBlclByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcxMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogbW9kZSA9PT0gJ2RhcmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuNSknXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnMCA4cHggMzBweCByZ2JhKDAsMCwwLDAuMTIpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ1RpdGxlLCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ2RpdmlkZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBiOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICcjM2EwNTA1JyA6ICcjZmZlYmVlJywgLy8gRGFyay9saWdodCByZWQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBtb2RlID09PSAnZGFyaycgPyAnI2ZmNTI1MicgOiAnI2QzMmYyZicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJEZWxldGUgSGFiaXRcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgc3g6IHsgbXQ6IDIsIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogW1wiQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSBcXFwiXCIsIGhhYml0Lm5hbWUsIFwiXFxcIj8gVGhpcyBhY3Rpb24gY2Fubm90IGJlIHVuZG9uZS5cIl0gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nQWN0aW9ucywgeyBzeDogeyBweDogMywgcHk6IDIsIGJvcmRlclRvcDogJzFweCBzb2xpZCcsIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsIGJnY29sb3I6ICdiYWNrZ3JvdW5kLnBhcGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4gc2V0SXNEZWxldGVEaWFsb2dPcGVuKGZhbHNlKSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIkNhbmNlbFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb2xvcjogXCJlcnJvclwiLCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiRGVsZXRlXCIgfSldIH0pXSB9KV0gfSksIFwiKTsgfTsgZXhwb3J0IGRlZmF1bHQgSGFiaXRDYXJkOyBcIl0gfSkgfSkpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});