"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst ThemeContext_1 = __webpack_require__(/*! ../context/ThemeContext */ 49211);\nconst styles_1 = __webpack_require__(/*! @mui/material/styles */ 278403);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const { mode } = (0, ThemeContext_1.useTheme)();\n    const muiTheme = (0, styles_1.useTheme)();\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    const [selectedYear, setSelectedYear] = (0, react_1.useState)(new Date().getFullYear());\n    // Define dynamic cell size based on available width\n    const calculateCellSize = (0, react_1.useCallback)(() => {\n        // Determine a good starting cell size based on the number of weeks\n        const availableWidth = window.innerWidth > 1400 ? 1200 : window.innerWidth - 100;\n        const containerPadding = 80; // Account for container padding and margins\n        const availableSpace = Math.min(1024, availableWidth - containerPadding);\n        const maxPossibleCellSize = Math.floor((availableSpace - WEEKDAY_LABEL_WIDTH) / grid.length) - CELL_GAP;\n        // Set constraints for cell size\n        return Math.min(Math.max(maxPossibleCellSize, 10), 16); // Between 10px and 16px\n    }, [grid.length]);\n    // Calculate cell size once on component mount or when grid changes\n    const CELL_SIZE = (0, react_1.useMemo)(() => calculateCellSize(), [calculateCellSize]);\n    const CELL_GAP = 1; // Minimum gap for compact layout\n    const WEEKDAY_LABEL_WIDTH = 20; // Smaller width for weekday labels\n    // Build a GitHub-style heatmap grid for the selected year\n    const daysOfYear = (0, react_1.useMemo)(() => {\n        const yearStart = (0, date_fns_1.startOfYear)(new Date(selectedYear, 0, 1));\n        const yearEnd = (0, date_fns_1.endOfYear)(new Date(selectedYear, 11, 31));\n        return (0, date_fns_1.eachDayOfInterval)({ start: yearStart, end: yearEnd });\n    }, [selectedYear]);\n    const firstDayOfYear = (0, react_1.useMemo)(() => (0, date_fns_1.startOfYear)(new Date(selectedYear, 0, 1)), [selectedYear]);\n    const numWeeks = (0, react_1.useMemo)(() => (0, date_fns_1.differenceInCalendarWeeks)((0, date_fns_1.endOfYear)(new Date(selectedYear, 11, 31)), firstDayOfYear, { weekStartsOn: 0 }) + 1, [selectedYear, firstDayOfYear]);\n    const numRows = 7; // Sun-Sat\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = (0, react_1.useMemo)(() => {\n        const newGrid = Array.from({ length: numWeeks }, () => Array(numRows).fill(null));\n        daysOfYear.forEach(day => {\n            const week = (0, date_fns_1.differenceInCalendarWeeks)(day, firstDayOfYear, { weekStartsOn: 0 });\n            const weekday = (0, date_fns_1.getDay)(day); // 0=Sun, 6=Sat\n            if (week >= 0 && week < numWeeks) { // Only include days in this year\n                newGrid[week][weekday] = day;\n            }\n        });\n        return newGrid;\n    }, [daysOfYear, firstDayOfYear, numWeeks, numRows]);\n    // For month labels: improved calculation to accurately position month labels\n    const monthLabels = (0, react_1.useMemo)(() => {\n        // Initialize array to hold labels\n        const labels = [];\n        let currentMonth = -1;\n        let monthStartCol = 0;\n        // First pass: Find where each month starts and ends\n        grid.forEach((col, colIdx) => {\n            // Find first valid day in column to check month\n            const firstDayInCol = col.find(day => day !== null);\n            if (firstDayInCol) {\n                const monthOfDay = (0, date_fns_1.getMonth)(firstDayInCol);\n                // If this is a new month, record where it starts\n                if (monthOfDay !== currentMonth) {\n                    // If we were tracking a previous month, calculate its width\n                    if (currentMonth !== -1) {\n                        const width = colIdx - monthStartCol;\n                        labels.push({\n                            col: monthStartCol,\n                            month: (0, date_fns_1.format)(new Date(selectedYear, currentMonth, 1), 'MMM'),\n                            width: width\n                        });\n                    }\n                    // Start tracking the new month\n                    currentMonth = monthOfDay;\n                    monthStartCol = colIdx;\n                }\n                // Handle the last month in the year\n                if (colIdx === grid.length - 1 && currentMonth !== -1) {\n                    const width = colIdx - monthStartCol + 1; // +1 because we include the last column\n                    labels.push({\n                        col: monthStartCol,\n                        month: (0, date_fns_1.format)(new Date(selectedYear, currentMonth, 1), 'MMM'),\n                        width: width\n                    });\n                }\n            }\n        });\n        return labels;\n    }, [grid, selectedYear]);\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        if (useCheckbox) {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        else if (quantity !== '') {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [useCheckbox, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const handlePrevYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev - 1);\n    }, []);\n    const handleNextYear = (0, react_1.useCallback)(() => {\n        setSelectedYear(prev => prev + 1);\n    }, []);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2,\n            pb: 1,\n            mb: 2,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            border: '1px solid',\n            borderColor: 'divider',\n            borderRadius: '8px',\n            boxShadow: mode === 'dark'\n                ? '0 2px 8px rgba(0,0,0,0.3)'\n                : '0 2px 8px rgba(0,0,0,0.05)',\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { width: '100%', mx: 'auto', mb: 0 }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h5\", align: \"center\", noWrap: true, title: habit.name, sx: {\n                            mt: 0,\n                            mb: 1,\n                            width: '100%',\n                            overflow: 'hidden',\n                            textOverflow: 'ellipsis',\n                            color: habit.color,\n                            fontWeight: 600,\n                            letterSpacing: '0.02em',\n                            textShadow: mode === 'dark'\n                                ? '0 1px 2px rgba(0,0,0,0.3)'\n                                : '0 1px 1px rgba(0,0,0,0.1)',\n                            fontSize: '1.3rem',\n                            borderBottom: `2px solid ${habit.color}33`,\n                            paddingBottom: 0.5,\n                            position: 'relative',\n                            '&::after': {\n                                content: '\"\"',\n                                position: 'absolute',\n                                bottom: '-2px',\n                                left: 0,\n                                width: '100%',\n                                borderBottom: `2px solid ${habit.color}33`,\n                            }\n                        }, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center' }, children: [(0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handlePrevYear, sx: { color: 'text.primary' }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronLeft, { fontSize: \"small\" }) }), (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"body2\", sx: { mx: 0.5, fontWeight: 'bold', color: 'text.primary' }, children: selectedYear }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", onClick: handleNextYear, disabled: selectedYear >= new Date().getFullYear(), sx: { color: 'text.primary' }, children: (0, jsx_runtime_1.jsx)(icons_material_1.ChevronRight, { fontSize: \"small\" }) })] }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", sx: { display: 'flex', alignItems: 'center' }, children: [\"\\uD83D\\uDD25 \", (0, jsx_runtime_1.jsx)(\"span\", { style: { fontWeight: 'bold', marginLeft: '2px' }, children: streak })] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"contained\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, {}), onClick: () => {\n                                            setSelectedDate(new Date());\n                                            setIsLogDialogOpen(true);\n                                        }, sx: {\n                                            py: 0.6,\n                                            px: 1.5,\n                                            bgcolor: `${habit.color}99`,\n                                            '&:hover': {\n                                                bgcolor: `${habit.color}cc`,\n                                            }\n                                        }, children: \"Log\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, {}) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                            width: '100%',\n                            display: 'flex',\n                            flexDirection: 'column',\n                            alignItems: 'center',\n                            overflow: 'hidden' // Prevent overflow\n                        }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                    display: 'flex',\n                                    alignItems: 'center',\n                                    mb: 0.5,\n                                    ml: `${WEEKDAY_LABEL_WIDTH}px`,\n                                    width: `calc(${grid.length * (CELL_SIZE + CELL_GAP)}px)`,\n                                    justifyContent: 'flex-start',\n                                    position: 'relative',\n                                    height: '18px',\n                                    overflow: 'hidden'\n                                }, children: monthLabels.map((label, idx) => {\n                                    // Calculate the exact position and width\n                                    const startPosition = label.col * (CELL_SIZE + CELL_GAP);\n                                    const labelWidth = label.width * (CELL_SIZE + CELL_GAP) - CELL_GAP;\n                                    return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                            position: 'absolute',\n                                            left: startPosition,\n                                            width: labelWidth,\n                                            textAlign: 'center'\n                                        }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", noWrap: true, sx: {\n                                                fontSize: '0.65rem',\n                                                color: 'text.secondary',\n                                                fontWeight: 'medium',\n                                                lineHeight: 1,\n                                                display: 'inline-block',\n                                                position: 'relative',\n                                                '&::after': {\n                                                    content: '\"\"',\n                                                    position: 'absolute',\n                                                    bottom: '-3px',\n                                                    left: 0,\n                                                    width: '100%',\n                                                    borderBottom: `1px solid ${mode === 'dark' ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)'}`,\n                                                }\n                                            }, children: label.month }) }, idx));\n                                }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: {\n                                    display: 'grid',\n                                    gridTemplateColumns: `${WEEKDAY_LABEL_WIDTH}px repeat(${grid.length}, ${CELL_SIZE}px)`,\n                                    gap: CELL_GAP,\n                                    mb: 0,\n                                    width: `calc(${WEEKDAY_LABEL_WIDTH}px + ${grid.length * (CELL_SIZE + CELL_GAP)}px - ${CELL_GAP}px)`,\n                                    maxWidth: '100%',\n                                    overflow: 'hidden',\n                                    justifyContent: 'center'\n                                }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: 1, gridRow: weekday + 1, justifySelf: 'end', pr: 0.5 }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: { fontSize: '0.65rem', color: 'text.secondary', lineHeight: 1 }, children: ['S', 'M', 'T', 'W', 'T', 'F', 'S'][weekday] }) }, weekday))), grid.map((col, colIdx) => ([0, 1, 2, 3, 4, 5, 6].map((rowIdx) => {\n                                        const day = col[rowIdx];\n                                        if (!day)\n                                            return (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: colIdx + 2, gridRow: rowIdx + 1, width: CELL_SIZE, height: CELL_SIZE } }, `empty-${colIdx}-${rowIdx}`);\n                                        const isCompleted = isDayCompleted(day);\n                                        const isFuture = (0, date_fns_1.isAfter)(day, new Date());\n                                        const isCurrentDay = (0, date_fns_1.isToday)(day);\n                                        return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                                gridColumn: colIdx + 2,\n                                                gridRow: rowIdx + 1,\n                                                width: CELL_SIZE,\n                                                height: CELL_SIZE,\n                                                bgcolor: isCompleted\n                                                    ? habit.color + (mode === 'dark' ? 'aa' : '99')\n                                                    : mode === 'dark' ? 'rgba(255,255,255,0.05)' : 'transparent',\n                                                border: isCurrentDay\n                                                    ? `1px solid ${habit.color}`\n                                                    : `1px solid ${mode === 'dark' ? '#444' : '#e0e0e0'}`,\n                                                borderRadius: '2px',\n                                                cursor: isFuture ? 'not-allowed' : 'pointer',\n                                                opacity: isFuture ? 0.3 : 1,\n                                                transition: 'background-color 0.2s',\n                                                '&:hover': {\n                                                    bgcolor: isCompleted\n                                                        ? habit.color + 'cc'\n                                                        : mode === 'dark' ? 'rgba(255,255,255,0.1)' : '#f5f5f5',\n                                                }\n                                            }, onClick: () => !isFuture && handleDayClick(day) }, day.toString()));\n                                    })))] })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                            color: '#fff',\n                        }, children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, color: \"text.primary\", children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), (0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked), sx: {\n                                            color: habit.color,\n                                            '&.Mui-checked': {\n                                                color: habit.color,\n                                            }\n                                        } }), label: (0, jsx_runtime_1.jsx)(material_1.Typography, { color: \"text.primary\", children: \"Mark as completed\" }) }), !useCheckbox && ((0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: {\n                                        mt: 2,\n                                        '& .MuiOutlinedInput-root': {\n                                            '&.Mui-focused fieldset': {\n                                                borderColor: habit.color,\n                                            },\n                                        },\n                                        '& .MuiInputLabel-root.Mui-focused': {\n                                            color: habit.color,\n                                        },\n                                    }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, sx: { borderRadius: '20px', px: 2 }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: !useCheckbox && quantity === '', sx: {\n                                    borderRadius: '20px',\n                                    px: 2,\n                                    background: `linear-gradient(45deg, ${habit.color} 30%, ${habit.color}99 90%)`,\n                                    boxShadow: `0 3px 5px 2px ${habit.color}33`,\n                                }, children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, PaperProps: {\n                    sx: {\n                        borderRadius: '12px',\n                        boxShadow: mode === 'dark'\n                            ? '0 8px 30px rgba(0,0,0,0.5)'\n                            : '0 8px 30px rgba(0,0,0,0.12)',\n                        overflow: 'hidden',\n                        bgcolor: 'background.paper',\n                    }\n                }, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { sx: {\n                            borderBottom: '1px solid',\n                            borderColor: 'divider',\n                            pb: 2,\n                            bgcolor: mode === 'dark' ? '#3a0505' : '#ffebee', // Dark/light red background\n                            color: mode === 'dark' ? '#ff5252' : '#d32f2f',\n                        }, children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { sx: { mt: 2, bgcolor: 'background.paper' }, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { color: \"text.primary\", children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { sx: { px: 3, py: 2, borderTop: '1px solid', borderColor: 'divider', bgcolor: 'background.paper' }, children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), sx: { borderRadius: '20px', px: 2 }, children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", sx: { borderRadius: '20px', px: 2 }, children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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REFBNkQsMEhBQTBILEdBQUcsdURBQXVELE1BQU0sMkZBQTJGLHlEQUF5RCxtREFBbUQsNkJBQTZCLHNCQUFzQiwrQ0FBK0M7QUFDcnJCO0FBQ0E7QUFDQSxpQ0FBaUMsOENBQThDLDZCQUE2QixzQkFBc0IsSUFBSSxJQUFJLElBQUk7QUFDOUk7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2FzY2VudC8uL3NyYy9yZW5kZXJlci9jb21wb25lbnRzL0hhYml0Q2FyZC50c3g/NDNlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QganN4X3J1bnRpbWVfMSA9IHJlcXVpcmUoXCJyZWFjdC9qc3gtcnVudGltZVwiKTtcbmNvbnN0IHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IG1hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9tYXRlcmlhbFwiKTtcbmNvbnN0IGljb25zX21hdGVyaWFsXzEgPSByZXF1aXJlKFwiQG11aS9pY29ucy1tYXRlcmlhbFwiKTtcbmNvbnN0IGRhdGVfZm5zXzEgPSByZXF1aXJlKFwiZGF0ZS1mbnNcIik7XG5jb25zdCBUaGVtZUNvbnRleHRfMSA9IHJlcXVpcmUoXCIuLi9jb250ZXh0L1RoZW1lQ29udGV4dFwiKTtcbmNvbnN0IHN0eWxlc18xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWwvc3R5bGVzXCIpO1xuY29uc3QgSGFiaXRDYXJkID0gKHsgaGFiaXQsIG9uVG9nZ2xlQ29tcGxldGlvbiwgb25EZWxldGUgfSkgPT4ge1xuICAgIGNvbnN0IHsgbW9kZSB9ID0gKDAsIFRoZW1lQ29udGV4dF8xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IG11aVRoZW1lID0gKDAsIHN0eWxlc18xLnVzZVRoZW1lKSgpO1xuICAgIGNvbnN0IFtpc0xvZ0RpYWxvZ09wZW4sIHNldElzTG9nRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RlbGV0ZURpYWxvZ09wZW4sIHNldElzRGVsZXRlRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RlZERhdGUsIHNldFNlbGVjdGVkRGF0ZV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKSk7XG4gICAgY29uc3QgW3F1YW50aXR5LCBzZXRRdWFudGl0eV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoJycpO1xuICAgIGNvbnN0IFt1c2VDaGVja2JveCwgc2V0VXNlQ2hlY2tib3hdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHRydWUpO1xuICAgIGNvbnN0IFtzZWxlY3RlZFllYXIsIHNldFNlbGVjdGVkWWVhcl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKS5nZXRGdWxsWWVhcigpKTtcbiAgICAvLyBEZWZpbmUgZHluYW1pYyBjZWxsIHNpemUgYmFzZWQgb24gYXZhaWxhYmxlIHdpZHRoXG4gICAgY29uc3QgY2FsY3VsYXRlQ2VsbFNpemUgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKCkgPT4ge1xuICAgICAgICAvLyBEZXRlcm1pbmUgYSBnb29kIHN0YXJ0aW5nIGNlbGwgc2l6ZSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIHdlZWtzXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPiAxNDAwID8gMTIwMCA6IHdpbmRvdy5pbm5lcldpZHRoIC0gMTAwO1xuICAgICAgICBjb25zdCBjb250YWluZXJQYWRkaW5nID0gODA7IC8vIEFjY291bnQgZm9yIGNvbnRhaW5lciBwYWRkaW5nIGFuZCBtYXJnaW5zXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNlID0gTWF0aC5taW4oMTAyNCwgYXZhaWxhYmxlV2lkdGggLSBjb250YWluZXJQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgbWF4UG9zc2libGVDZWxsU2l6ZSA9IE1hdGguZmxvb3IoKGF2YWlsYWJsZVNwYWNlIC0gV0VFS0RBWV9MQUJFTF9XSURUSCkgLyBncmlkLmxlbmd0aCkgLSBDRUxMX0dBUDtcbiAgICAgICAgLy8gU2V0IGNvbnN0cmFpbnRzIGZvciBjZWxsIHNpemVcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1heFBvc3NpYmxlQ2VsbFNpemUsIDEwKSwgMTYpOyAvLyBCZXR3ZWVuIDEwcHggYW5kIDE2cHhcbiAgICB9LCBbZ3JpZC5sZW5ndGhdKTtcbiAgICAvLyBDYWxjdWxhdGUgY2VsbCBzaXplIG9uY2Ugb24gY29tcG9uZW50IG1vdW50IG9yIHdoZW4gZ3JpZCBjaGFuZ2VzXG4gICAgY29uc3QgQ0VMTF9TSVpFID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gY2FsY3VsYXRlQ2VsbFNpemUoKSwgW2NhbGN1bGF0ZUNlbGxTaXplXSk7XG4gICAgY29uc3QgQ0VMTF9HQVAgPSAxOyAvLyBNaW5pbXVtIGdhcCBmb3IgY29tcGFjdCBsYXlvdXRcbiAgICBjb25zdCBXRUVLREFZX0xBQkVMX1dJRFRIID0gMjA7IC8vIFNtYWxsZXIgd2lkdGggZm9yIHdlZWtkYXkgbGFiZWxzXG4gICAgLy8gQnVpbGQgYSBHaXRIdWItc3R5bGUgaGVhdG1hcCBncmlkIGZvciB0aGUgc2VsZWN0ZWQgeWVhclxuICAgIGNvbnN0IGRheXNPZlllYXIgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHllYXJTdGFydCA9ICgwLCBkYXRlX2Zuc18xLnN0YXJ0T2ZZZWFyKShuZXcgRGF0ZShzZWxlY3RlZFllYXIsIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeWVhckVuZCA9ICgwLCBkYXRlX2Zuc18xLmVuZE9mWWVhcikobmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpKTtcbiAgICAgICAgcmV0dXJuICgwLCBkYXRlX2Zuc18xLmVhY2hEYXlPZkludGVydmFsKSh7IHN0YXJ0OiB5ZWFyU3RhcnQsIGVuZDogeWVhckVuZCB9KTtcbiAgICB9LCBbc2VsZWN0ZWRZZWFyXSk7XG4gICAgY29uc3QgZmlyc3REYXlPZlllYXIgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiAoMCwgZGF0ZV9mbnNfMS5zdGFydE9mWWVhcikobmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAwLCAxKSksIFtzZWxlY3RlZFllYXJdKTtcbiAgICBjb25zdCBudW1XZWVrcyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+ICgwLCBkYXRlX2Zuc18xLmRpZmZlcmVuY2VJbkNhbGVuZGFyV2Vla3MpKCgwLCBkYXRlX2Zuc18xLmVuZE9mWWVhcikobmV3IERhdGUoc2VsZWN0ZWRZZWFyLCAxMSwgMzEpKSwgZmlyc3REYXlPZlllYXIsIHsgd2Vla1N0YXJ0c09uOiAwIH0pICsgMSwgW3NlbGVjdGVkWWVhciwgZmlyc3REYXlPZlllYXJdKTtcbiAgICBjb25zdCBudW1Sb3dzID0gNzsgLy8gU3VuLVNhdFxuICAgIC8vIEJ1aWxkIGdyaWQ6IGdyaWRbY29sXVtyb3ddID0gZGF0ZSBvciBudWxsXG4gICAgLy8gQ29sID0gd2VlaywgUm93ID0gd2Vla2RheVxuICAgIGNvbnN0IGdyaWQgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0dyaWQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1XZWVrcyB9LCAoKSA9PiBBcnJheShudW1Sb3dzKS5maWxsKG51bGwpKTtcbiAgICAgICAgZGF5c09mWWVhci5mb3JFYWNoKGRheSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ZWVrID0gKDAsIGRhdGVfZm5zXzEuZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcykoZGF5LCBmaXJzdERheU9mWWVhciwgeyB3ZWVrU3RhcnRzT246IDAgfSk7XG4gICAgICAgICAgICBjb25zdCB3ZWVrZGF5ID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShkYXkpOyAvLyAwPVN1biwgNj1TYXRcbiAgICAgICAgICAgIGlmICh3ZWVrID49IDAgJiYgd2VlayA8IG51bVdlZWtzKSB7IC8vIE9ubHkgaW5jbHVkZSBkYXlzIGluIHRoaXMgeWVhclxuICAgICAgICAgICAgICAgIG5ld0dyaWRbd2Vla11bd2Vla2RheV0gPSBkYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3R3JpZDtcbiAgICB9LCBbZGF5c09mWWVhciwgZmlyc3REYXlPZlllYXIsIG51bVdlZWtzLCBudW1Sb3dzXSk7XG4gICAgLy8gRm9yIG1vbnRoIGxhYmVsczogaW1wcm92ZWQgY2FsY3VsYXRpb24gdG8gYWNjdXJhdGVseSBwb3NpdGlvbiBtb250aCBsYWJlbHNcbiAgICBjb25zdCBtb250aExhYmVscyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcnJheSB0byBob2xkIGxhYmVsc1xuICAgICAgICBjb25zdCBsYWJlbHMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRNb250aCA9IC0xO1xuICAgICAgICBsZXQgbW9udGhTdGFydENvbCA9IDA7XG4gICAgICAgIC8vIEZpcnN0IHBhc3M6IEZpbmQgd2hlcmUgZWFjaCBtb250aCBzdGFydHMgYW5kIGVuZHNcbiAgICAgICAgZ3JpZC5mb3JFYWNoKChjb2wsIGNvbElkeCkgPT4ge1xuICAgICAgICAgICAgLy8gRmluZCBmaXJzdCB2YWxpZCBkYXkgaW4gY29sdW1uIHRvIGNoZWNrIG1vbnRoXG4gICAgICAgICAgICBjb25zdCBmaXJzdERheUluQ29sID0gY29sLmZpbmQoZGF5ID0+IGRheSAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAoZmlyc3REYXlJbkNvbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vbnRoT2ZEYXkgPSAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkoZmlyc3REYXlJbkNvbCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldyBtb250aCwgcmVjb3JkIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIGlmIChtb250aE9mRGF5ICE9PSBjdXJyZW50TW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSB0cmFja2luZyBhIHByZXZpb3VzIG1vbnRoLCBjYWxjdWxhdGUgaXRzIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TW9udGggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbElkeCAtIG1vbnRoU3RhcnRDb2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sOiBtb250aFN0YXJ0Q29sLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgY3VycmVudE1vbnRoLCAxKSwgJ01NTScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgdHJhY2tpbmcgdGhlIG5ldyBtb250aFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TW9udGggPSBtb250aE9mRGF5O1xuICAgICAgICAgICAgICAgICAgICBtb250aFN0YXJ0Q29sID0gY29sSWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGxhc3QgbW9udGggaW4gdGhlIHllYXJcbiAgICAgICAgICAgICAgICBpZiAoY29sSWR4ID09PSBncmlkLmxlbmd0aCAtIDEgJiYgY3VycmVudE1vbnRoICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGNvbElkeCAtIG1vbnRoU3RhcnRDb2wgKyAxOyAvLyArMSBiZWNhdXNlIHdlIGluY2x1ZGUgdGhlIGxhc3QgY29sdW1uXG4gICAgICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogbW9udGhTdGFydENvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKG5ldyBEYXRlKHNlbGVjdGVkWWVhciwgY3VycmVudE1vbnRoLCAxKSwgJ01NTScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSwgW2dyaWQsIHNlbGVjdGVkWWVhcl0pO1xuICAgIGNvbnN0IGlzSGFiaXRDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlU3RyZWFrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgbGV0IHN0cmVhayA9IDA7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgd2hpbGUgKGlzSGFiaXRDb21wbGV0ZWQoY3VycmVudERhdGUpICYmICEoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShjdXJyZW50RGF0ZSwgdG9kYXkpKSB7XG4gICAgICAgICAgICBzdHJlYWsrKztcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhaztcbiAgICB9LCBbaXNIYWJpdENvbXBsZXRlZF0pO1xuICAgIGNvbnN0IGhhbmRsZUxvZ1N1Ym1pdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIGlmICh1c2VDaGVja2JveCkge1xuICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWFudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSwgTnVtYmVyKHF1YW50aXR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgc2V0UXVhbnRpdHkoJycpO1xuICAgICAgICBzZXRVc2VDaGVja2JveCh0cnVlKTtcbiAgICB9LCBbdXNlQ2hlY2tib3gsIHNlbGVjdGVkRGF0ZSwgcXVhbnRpdHksIG9uVG9nZ2xlQ29tcGxldGlvbl0pO1xuICAgIGNvbnN0IGhhbmRsZURheUNsaWNrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXkpID0+IHtcbiAgICAgICAgaWYgKCgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGRheSwgbmV3IERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgYWxsb3cgbG9nZ2luZyBmdXR1cmUgZGF0ZXNcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF5KTtcbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBjYWxjdWxhdGVTdHJlYWsoKSwgW2NhbGN1bGF0ZVN0cmVha10pO1xuICAgIGNvbnN0IGlzRGF5Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIGNvbnN0IGhhbmRsZVByZXZZZWFyID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgc2V0U2VsZWN0ZWRZZWFyKHByZXYgPT4gcHJldiAtIDEpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBoYW5kbGVOZXh0WWVhciA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIHNldFNlbGVjdGVkWWVhcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlBhcGVyLCB7IGVsZXZhdGlvbjogMCwgc3g6IHtcbiAgICAgICAgICAgIHA6IDIsXG4gICAgICAgICAgICBwYjogMSxcbiAgICAgICAgICAgIG1iOiAyLFxuICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQnLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgID8gJzAgMnB4IDhweCByZ2JhKDAsMCwwLDAuMyknXG4gICAgICAgICAgICAgICAgOiAnMCAycHggOHB4IHJnYmEoMCwwLDAsMC4wNSknLFxuICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IHdpZHRoOiAnMTAwJScsIG14OiAnYXV0bycsIG1iOiAwIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJoNVwiLCBhbGlnbjogXCJjZW50ZXJcIiwgbm9XcmFwOiB0cnVlLCB0aXRsZTogaGFiaXQubmFtZSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IDYwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiAnMC4wMmVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnMCAxcHggMnB4IHJnYmEoMCwwLDAsMC4zKSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnMCAxcHggMXB4IHJnYmEoMCwwLDAsMC4xKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxLjNyZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckJvdHRvbTogYDJweCBzb2xpZCAke2hhYml0LmNvbG9yfTMzYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6OmFmdGVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnXCJcIicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206ICctMnB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQm90dG9tOiBgMnB4IHNvbGlkICR7aGFiaXQuY29sb3J9MzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBoYWJpdC5uYW1lIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcsIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBtYjogMSB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5JY29uQnV0dG9uLCB7IHNpemU6IFwic21hbGxcIiwgb25DbGljazogaGFuZGxlUHJldlllYXIsIHN4OiB7IGNvbG9yOiAndGV4dC5wcmltYXJ5JyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25MZWZ0LCB7IGZvbnRTaXplOiBcInNtYWxsXCIgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgc3g6IHsgbXg6IDAuNSwgZm9udFdlaWdodDogJ2JvbGQnLCBjb2xvcjogJ3RleHQucHJpbWFyeScgfSwgY2hpbGRyZW46IHNlbGVjdGVkWWVhciB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkljb25CdXR0b24sIHsgc2l6ZTogXCJzbWFsbFwiLCBvbkNsaWNrOiBoYW5kbGVOZXh0WWVhciwgZGlzYWJsZWQ6IHNlbGVjdGVkWWVhciA+PSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksIHN4OiB7IGNvbG9yOiAndGV4dC5wcmltYXJ5JyB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkNoZXZyb25SaWdodCwgeyBmb250U2l6ZTogXCJzbWFsbFwiIH0pIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgZ2FwOiAxIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRvb2x0aXAsIHsgdGl0bGU6IGBDdXJyZW50IHN0cmVhazogJHtzdHJlYWt9IGRheXNgLCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5UeXBvZ3JhcGh5LCB7IHZhcmlhbnQ6IFwiYm9keTJcIiwgY29sb3I6IFwidGV4dC5zZWNvbmRhcnlcIiwgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBhbGlnbkl0ZW1zOiAnY2VudGVyJyB9LCBjaGlsZHJlbjogW1wiXFx1RDgzRFxcdUREMjUgXCIsICgwLCBqc3hfcnVudGltZV8xLmpzeCkoXCJzcGFuXCIsIHsgc3R5bGU6IHsgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAnMnB4JyB9LCBjaGlsZHJlbjogc3RyZWFrIH0pXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBzaXplOiBcInNtYWxsXCIsIHN0YXJ0SWNvbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkFkZCwge30pLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFNlbGVjdGVkRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB5OiAwLjYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB4OiAxLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGAke2hhYml0LmNvbG9yfTk5YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBgJHtoYWJpdC5jb2xvcn1jY2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJMb2dcIiB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkljb25CdXR0b24sIHsgc2l6ZTogXCJzbWFsbFwiLCBjb2xvcjogXCJlcnJvclwiLCBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4odHJ1ZSksIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKGljb25zX21hdGVyaWFsXzEuRGVsZXRlLCB7fSkgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicgLy8gUHJldmVudCBvdmVyZmxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1iOiAwLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbDogYCR7V0VFS0RBWV9MQUJFTF9XSURUSH1weGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogYGNhbGMoJHtncmlkLmxlbmd0aCAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCl9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzE4cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBtb250aExhYmVscy5tYXAoKGxhYmVsLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhhY3QgcG9zaXRpb24gYW5kIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbGFiZWwuY29sICogKENFTExfU0laRSArIENFTExfR0FQKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSBsYWJlbC53aWR0aCAqIChDRUxMX1NJWkUgKyBDRUxMX0dBUCkgLSBDRUxMX0dBUDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogc3RhcnRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGxhYmVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIG5vV3JhcDogdHJ1ZSwgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMC42NXJlbScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3RleHQuc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdtZWRpdW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJjo6YWZ0ZXInOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogJy0zcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206IGAxcHggc29saWQgJHttb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjEpJyA6ICdyZ2JhKDAsMCwwLDAuMSknfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBsYWJlbC5tb250aCB9KSB9LCBpZHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZ3JpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBgJHtXRUVLREFZX0xBQkVMX1dJRFRIfXB4IHJlcGVhdCgke2dyaWQubGVuZ3RofSwgJHtDRUxMX1NJWkV9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogQ0VMTF9HQVAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBgY2FsYygke1dFRUtEQVlfTEFCRUxfV0lEVEh9cHggKyAke2dyaWQubGVuZ3RoICogKENFTExfU0laRSArIENFTExfR0FQKX1weCAtICR7Q0VMTF9HQVB9cHgpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtbMCwgMSwgMiwgMywgNCwgNSwgNl0ubWFwKCh3ZWVrZGF5KSA9PiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBncmlkQ29sdW1uOiAxLCBncmlkUm93OiB3ZWVrZGF5ICsgMSwganVzdGlmeVNlbGY6ICdlbmQnLCBwcjogMC41IH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgc3g6IHsgZm9udFNpemU6ICcwLjY1cmVtJywgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScsIGxpbmVIZWlnaHQ6IDEgfSwgY2hpbGRyZW46IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddW3dlZWtkYXldIH0pIH0sIHdlZWtkYXkpKSksIGdyaWQubWFwKChjb2wsIGNvbElkeCkgPT4gKFswLCAxLCAyLCAzLCA0LCA1LCA2XS5tYXAoKHJvd0lkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRheSA9IGNvbFtyb3dJZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBncmlkQ29sdW1uOiBjb2xJZHggKyAyLCBncmlkUm93OiByb3dJZHggKyAxLCB3aWR0aDogQ0VMTF9TSVpFLCBoZWlnaHQ6IENFTExfU0laRSB9IH0sIGBlbXB0eS0ke2NvbElkeH0tJHtyb3dJZHh9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDb21wbGV0ZWQgPSBpc0RheUNvbXBsZXRlZChkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnV0dXJlID0gKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoZGF5LCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0N1cnJlbnREYXkgPSAoMCwgZGF0ZV9mbnNfMS5pc1RvZGF5KShkYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sSWR4ICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRSb3c6IHJvd0lkeCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogQ0VMTF9TSVpFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBDRUxMX1NJWkUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBpc0NvbXBsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaGFiaXQuY29sb3IgKyAobW9kZSA9PT0gJ2RhcmsnID8gJ2FhJyA6ICc5OScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtb2RlID09PSAnZGFyaycgPyAncmdiYSgyNTUsMjU1LDI1NSwwLjA1KScgOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpc0N1cnJlbnREYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGAxcHggc29saWQgJHtoYWJpdC5jb2xvcn1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgMXB4IHNvbGlkICR7bW9kZSA9PT0gJ2RhcmsnID8gJyM0NDQnIDogJyNlMGUwZTAnfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICcycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBpc0Z1dHVyZSA/ICdub3QtYWxsb3dlZCcgOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBpc0Z1dHVyZSA/IDAuMyA6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiAnYmFja2dyb3VuZC1jb2xvciAwLjJzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJnY29sb3I6IGlzQ29tcGxldGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaGFiaXQuY29sb3IgKyAnY2MnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9kZSA9PT0gJ2RhcmsnID8gJ3JnYmEoMjU1LDI1NSwyNTUsMC4xKScgOiAnI2Y1ZjVmNScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uQ2xpY2s6ICgpID0+ICFpc0Z1dHVyZSAmJiBoYW5kbGVEYXlDbGljayhkYXkpIH0sIGRheS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpXSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0xvZ0RpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgUGFwZXJQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMTJweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IG1vZGUgPT09ICdkYXJrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjUpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJzAgOHB4IDMwcHggcmdiYSgwLDAsMCwwLjEyKScsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogYGxpbmVhci1ncmFkaWVudCg0NWRlZywgJHtoYWJpdC5jb2xvcn0gMzAlLCAke2hhYml0LmNvbG9yfTk5IDkwJSlgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogW1wiTG9nIFwiLCBoYWJpdC5uYW1lXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkRpYWxvZ0NvbnRlbnQsIHsgc3g6IHsgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBtdDogMiB9LCBjaGlsZHJlbjogWygwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcInN1YnRpdGxlMlwiLCBndXR0ZXJCb3R0b206IHRydWUsIGNvbG9yOiBcInRleHQucHJpbWFyeVwiLCBjaGlsZHJlbjogW1wiRGF0ZTogXCIsICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAnTU1NTSBkLCB5eXl5JyldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRm9ybUNvbnRyb2xMYWJlbCwgeyBjb250cm9sOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQ2hlY2tib3gsIHsgY2hlY2tlZDogdXNlQ2hlY2tib3gsIG9uQ2hhbmdlOiAoZSkgPT4gc2V0VXNlQ2hlY2tib3goZS50YXJnZXQuY2hlY2tlZCksIHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBoYWJpdC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYuTXVpLWNoZWNrZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaGFiaXQuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IH0pLCBsYWJlbDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBcIk1hcmsgYXMgY29tcGxldGVkXCIgfSkgfSksICF1c2VDaGVja2JveCAmJiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRleHRGaWVsZCwgeyBmdWxsV2lkdGg6IHRydWUsIHR5cGU6IFwibnVtYmVyXCIsIGxhYmVsOiBgUXVhbnRpdHkke2hhYml0LnVuaXQgPyBgICgke2hhYml0LnVuaXR9KWAgOiAnJ31gLCB2YWx1ZTogcXVhbnRpdHksIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IChOdW1iZXIodmFsKSA+PSAwICYmIE51bWJlcih2YWwpIDw9IDEwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFF1YW50aXR5KHZhbCA9PT0gJycgPyAnJyA6IE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG10OiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmIC5NdWlPdXRsaW5lZElucHV0LXJvb3QnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcmLk11aS1mb2N1c2VkIGZpZWxkc2V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyYgLk11aUlucHV0TGFiZWwtcm9vdC5NdWktZm9jdXNlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IGhhYml0LmNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBpbnB1dFByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksIGlzRGF5Q29tcGxldGVkKHNlbGVjdGVkRGF0ZSkgJiYgKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgY29sb3I6IFwid2FybmluZ1wiLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblRvZ2dsZUNvbXBsZXRpb24oKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShzZWxlY3RlZERhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc3g6IHsgYm9yZGVyUmFkaXVzOiAnMjBweCcsIHB4OiAyIH0sIGNoaWxkcmVuOiBcIlVuZG9cIiB9KSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogaGFuZGxlTG9nU3VibWl0LCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBkaXNhYmxlZDogIXVzZUNoZWNrYm94ICYmIHF1YW50aXR5ID09PSAnJywgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHg6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBgbGluZWFyLWdyYWRpZW50KDQ1ZGVnLCAke2hhYml0LmNvbG9yfSAzMCUsICR7aGFiaXQuY29sb3J9OTkgOTAlKWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6IGAwIDNweCA1cHggMnB4ICR7aGFiaXQuY29sb3J9MzNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJTYXZlXCIgfSldIH0pXSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2csIHsgb3BlbjogaXNEZWxldGVEaWFsb2dPcGVuLCBvbkNsb3NlOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBtYXhXaWR0aDogXCJ4c1wiLCBmdWxsV2lkdGg6IHRydWUsIFBhcGVyUHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzEycHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiBtb2RlID09PSAnZGFyaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC41KSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcwIDhweCAzMHB4IHJnYmEoMCwwLDAsMC4xMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgc3g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGI6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmdjb2xvcjogbW9kZSA9PT0gJ2RhcmsnID8gJyMzYTA1MDUnIDogJyNmZmViZWUnLCAvLyBEYXJrL2xpZ2h0IHJlZCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IG1vZGUgPT09ICdkYXJrJyA/ICcjZmY1MjUyJyA6ICcjZDMyZjJmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkRlbGV0ZSBIYWJpdFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nQ29udGVudCwgeyBzeDogeyBtdDogMiwgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY29sb3I6IFwidGV4dC5wcmltYXJ5XCIsIGNoaWxkcmVuOiBbXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIFxcXCJcIiwgaGFiaXQubmFtZSwgXCJcXFwiPyBUaGlzIGFjdGlvbiBjYW5ub3QgYmUgdW5kb25lLlwiXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IHN4OiB7IHB4OiAzLCBweTogMiwgYm9yZGVyVG9wOiAnMXB4IHNvbGlkJywgYm9yZGVyQ29sb3I6ICdkaXZpZGVyJywgYmdjb2xvcjogJ2JhY2tncm91bmQucGFwZXInIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpLCBzeDogeyBib3JkZXJSYWRpdXM6ICcyMHB4JywgcHg6IDIgfSwgY2hpbGRyZW46IFwiQ2FuY2VsXCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNvbG9yOiBcImVycm9yXCIsIHZhcmlhbnQ6IFwiY29udGFpbmVkXCIsIHN4OiB7IGJvcmRlclJhZGl1czogJzIwcHgnLCBweDogMiB9LCBjaGlsZHJlbjogXCJEZWxldGVcIiB9KV0gfSldIH0pXSB9KSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFiaXRDYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});