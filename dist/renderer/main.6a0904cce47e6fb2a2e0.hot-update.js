"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 199684:
/*!***********************************************!*\
  !*** ./src/renderer/context/HabitContext.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useHabits = exports.HabitProvider = void 0;\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst habit_1 = __webpack_require__(/*! ../types/habit */ 414105);\nconst HabitContext = (0, react_1.createContext)(undefined);\nconst STORAGE_KEY = 'habits';\nconst HabitProvider = ({ children }) => {\n    const [habits, setHabits] = (0, react_1.useState)(() => {\n        try {\n            const savedHabits = localStorage.getItem(STORAGE_KEY);\n            if (!savedHabits)\n                return [];\n            const parsedHabits = JSON.parse(savedHabits);\n            if (!Array.isArray(parsedHabits)) {\n                console.error('Invalid habits data in localStorage');\n                return [];\n            }\n            // Migrate old data if needed\n            return parsedHabits.map((habit) => ({\n                ...habit,\n                updatedAt: habit.updatedAt || habit.createdAt,\n                archived: habit.archived || false,\n                completions: habit.completions.map(completion => ({\n                    ...completion,\n                    completedAt: completion.completedAt || new Date(completion.date).toISOString(),\n                })),\n            }));\n        }\n        catch (error) {\n            console.error('Error loading habits from localStorage:', error);\n            return [];\n        }\n    });\n    const [error, setError] = (0, react_1.useState)(null);\n    (0, react_1.useEffect)(() => {\n        try {\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(habits));\n        }\n        catch (error) {\n            console.error('Error saving habits to localStorage:', error);\n            setError('Failed to save habits. Please try again.');\n        }\n    }, [habits]);\n    const addHabit = (0, react_1.useCallback)((habit) => {\n        setError(null);\n        try {\n            if (habits.length >= habit_1.MAX_HABITS) {\n                setError(`You can't create more than ${habit_1.MAX_HABITS} habits.`);\n                return;\n            }\n            if (habits.some(h => h.name.toLowerCase() === habit.name.toLowerCase())) {\n                setError('A habit with this name already exists.');\n                return;\n            }\n            const validationErrors = (0, habit_1.validateHabit)(habit);\n            if (validationErrors.length > 0) {\n                setError(validationErrors[0].message);\n                return;\n            }\n            const now = new Date().toISOString();\n            const newHabit = {\n                ...habit,\n                id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n                createdAt: now,\n                updatedAt: now,\n                completions: [],\n                archived: false,\n            };\n            setHabits(prev => [...prev, newHabit]);\n        }\n        catch (error) {\n            console.error('Error adding habit:', error);\n            setError('Failed to add habit. Please try again.');\n        }\n    }, [habits]);\n    const toggleHabitCompletion = (0, react_1.useCallback)((habitId, date, quantity, notes) => {\n        setError(null);\n        if (!habitId || !date) {\n            setError('Invalid habit or date.');\n            return;\n        }\n        setHabits(prev => prev.map(habit => {\n            if (habit.id === habitId) {\n                const existingCompletion = habit.completions.find(c => c.date === date);\n                let newCompletions;\n                if (existingCompletion) {\n                    // Remove completion if it exists\n                    newCompletions = habit.completions.filter(c => c.date !== date);\n                }\n                else {\n                    // Add new completion\n                    if (habit.completions.length >= habit_1.MAX_COMPLETIONS_PER_HABIT) {\n                        setError('Maximum number of completions reached for this habit.');\n                        return habit;\n                    }\n                    const completion = {\n                        date,\n                        completedAt: new Date().toISOString(),\n                    };\n                    if (habit.trackQuantity && typeof quantity === 'number') {\n                        completion.quantity = quantity;\n                    }\n                    if (notes?.trim()) {\n                        completion.notes = notes.trim();\n                    }\n                    newCompletions = [...habit.completions, completion];\n                }\n                return {\n                    ...habit,\n                    completions: newCompletions,\n                    updatedAt: new Date().toISOString(),\n                };\n            }\n            return habit;\n        }));\n    }, []);\n    const deleteHabit = (0, react_1.useCallback)((habitId) => {\n        setError(null);\n        if (!habitId) {\n            setError('Invalid habit ID.');\n            return;\n        }\n        setHabits(prev => {\n            const habitExists = prev.some(h => h.id === habitId);\n            if (!habitExists) {\n                setError('Habit not found.');\n                return prev;\n            }\n            return prev.filter(habit => habit.id !== habitId);\n        });\n    }, []);\n    const archiveHabit = (0, react_1.useCallback)((habitId) => {\n        setError(null);\n        if (!habitId) {\n            setError('Invalid habit ID.');\n            return;\n        }\n        setHabits(prev => prev.map(habit => {\n            if (habit.id === habitId) {\n                return {\n                    ...habit,\n                    archived: true,\n                    updatedAt: new Date().toISOString(),\n                };\n            }\n            return habit;\n        }));\n    }, []);\n    const getHabitStats = (0, react_1.useCallback)((habitId) => {\n        const habit = habits.find(h => h.id === habitId);\n        if (!habit)\n            return null;\n        const completions = habit.completions;\n        const totalCompletions = completions.length;\n        // Calculate streaks\n        let currentStreak = 0;\n        let longestStreak = 0;\n        let currentCount = 0;\n        // Sort completions by date\n        const sortedDates = completions\n            .map(c => new Date(c.date))\n            .sort((a, b) => b.getTime() - a.getTime());\n        if (sortedDates.length > 0) {\n            const today = new Date();\n            today.setHours(0, 0, 0, 0);\n            let currentDate = new Date(sortedDates[0]);\n            currentDate.setHours(0, 0, 0, 0);\n            // Calculate current streak\n            while (currentDate <= today) {\n                const hasCompletion = sortedDates.some(date => date.getFullYear() === currentDate.getFullYear() &&\n                    date.getMonth() === currentDate.getMonth() &&\n                    date.getDate() === currentDate.getDate());\n                if (hasCompletion) {\n                    currentCount++;\n                }\n                else {\n                    break;\n                }\n                currentDate.setDate(currentDate.getDate() - 1);\n            }\n            currentStreak = currentCount;\n            longestStreak = currentCount;\n            // Calculate longest streak\n            currentCount = 0;\n            for (let i = 0; i < sortedDates.length - 1; i++) {\n                const date1 = sortedDates[i];\n                const date2 = sortedDates[i + 1];\n                const diffDays = Math.round((date1.getTime() - date2.getTime()) / (1000 * 60 * 60 * 24));\n                if (diffDays === 1) {\n                    currentCount++;\n                    longestStreak = Math.max(longestStreak, currentCount);\n                }\n                else {\n                    currentCount = 0;\n                }\n            }\n        }\n        // Calculate completion rate\n        const daysSinceCreation = Math.ceil((new Date().getTime() - new Date(habit.createdAt).getTime()) / (1000 * 60 * 60 * 24));\n        const completionRate = (totalCompletions / daysSinceCreation) * 100;\n        // Calculate quantity stats if applicable\n        let averageQuantity;\n        let totalQuantity;\n        if (habit.trackQuantity) {\n            const quantities = completions\n                .map(c => c.quantity)\n                .filter((q) => typeof q === 'number');\n            if (quantities.length > 0) {\n                totalQuantity = quantities.reduce((sum, q) => sum + q, 0);\n                averageQuantity = totalQuantity / quantities.length;\n            }\n        }\n        return {\n            totalCompletions,\n            currentStreak,\n            longestStreak,\n            completionRate,\n            averageQuantity,\n            totalQuantity,\n            lastCompletionDate: completions.length > 0 ? completions[completions.length - 1].date : undefined,\n        };\n    }, [habits]);\n    const value = react_1.default.useMemo(() => ({\n        habits,\n        addHabit,\n        toggleHabitCompletion,\n        deleteHabit,\n        archiveHabit,\n        getHabitStats,\n        error,\n    }), [habits, addHabit, toggleHabitCompletion, deleteHabit, archiveHabit, getHabitStats, error]);\n    return ((0, jsx_runtime_1.jsx)(HabitContext.Provider, { value: value, children: children }));\n};\nexports.HabitProvider = HabitProvider;\nconst useHabits = () => {\n    const context = (0, react_1.useContext)(HabitContext);\n    if (context === undefined) {\n        throw new Error('useHabits must be used within a HabitProvider');\n    }\n    return context;\n};\nexports.useHabits = useHabits;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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azovL2FzY2VudC8uL3NyYy9yZW5kZXJlci9jb250ZXh0L0hhYml0Q29udGV4dC50c3g/MWNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3duS2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgb3duS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICB2YXIgYXIgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gbykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSkgYXJbYXIubGVuZ3RoXSA9IGs7XG4gICAgICAgICAgICByZXR1cm4gYXI7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvd25LZXlzKG8pO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb2QpIHtcbiAgICAgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgPSBvd25LZXlzKG1vZCksIGkgPSAwOyBpIDwgay5sZW5ndGg7IGkrKykgaWYgKGtbaV0gIT09IFwiZGVmYXVsdFwiKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGtbaV0pO1xuICAgICAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VIYWJpdHMgPSBleHBvcnRzLkhhYml0UHJvdmlkZXIgPSB2b2lkIDA7XG5jb25zdCBqc3hfcnVudGltZV8xID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgaGFiaXRfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy9oYWJpdFwiKTtcbmNvbnN0IEhhYml0Q29udGV4dCA9ICgwLCByZWFjdF8xLmNyZWF0ZUNvbnRleHQpKHVuZGVmaW5lZCk7XG5jb25zdCBTVE9SQUdFX0tFWSA9ICdoYWJpdHMnO1xuY29uc3QgSGFiaXRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBbaGFiaXRzLCBzZXRIYWJpdHNdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNhdmVkSGFiaXRzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpO1xuICAgICAgICAgICAgaWYgKCFzYXZlZEhhYml0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIYWJpdHMgPSBKU09OLnBhcnNlKHNhdmVkSGFiaXRzKTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJzZWRIYWJpdHMpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW52YWxpZCBoYWJpdHMgZGF0YSBpbiBsb2NhbFN0b3JhZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNaWdyYXRlIG9sZCBkYXRhIGlmIG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEhhYml0cy5tYXAoKGhhYml0KSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLmhhYml0LFxuICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDogaGFiaXQudXBkYXRlZEF0IHx8IGhhYml0LmNyZWF0ZWRBdCxcbiAgICAgICAgICAgICAgICBhcmNoaXZlZDogaGFiaXQuYXJjaGl2ZWQgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgY29tcGxldGlvbnM6IGhhYml0LmNvbXBsZXRpb25zLm1hcChjb21wbGV0aW9uID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbXBsZXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZEF0OiBjb21wbGV0aW9uLmNvbXBsZXRlZEF0IHx8IG5ldyBEYXRlKGNvbXBsZXRpb24uZGF0ZSkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGhhYml0cyBmcm9tIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShudWxsKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKCgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShoYWJpdHMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBoYWJpdHMgdG8gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAgIHNldEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBoYWJpdHMuIFBsZWFzZSB0cnkgYWdhaW4uJyk7XG4gICAgICAgIH1cbiAgICB9LCBbaGFiaXRzXSk7XG4gICAgY29uc3QgYWRkSGFiaXQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGhhYml0KSA9PiB7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGhhYml0cy5sZW5ndGggPj0gaGFiaXRfMS5NQVhfSEFCSVRTKSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoYFlvdSBjYW4ndCBjcmVhdGUgbW9yZSB0aGFuICR7aGFiaXRfMS5NQVhfSEFCSVRTfSBoYWJpdHMuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhYml0cy5zb21lKGggPT4gaC5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IGhhYml0Lm5hbWUudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcignQSBoYWJpdCB3aXRoIHRoaXMgbmFtZSBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gKDAsIGhhYml0XzEudmFsaWRhdGVIYWJpdCkoaGFiaXQpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKHZhbGlkYXRpb25FcnJvcnNbMF0ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgbmV3SGFiaXQgPSB7XG4gICAgICAgICAgICAgICAgLi4uaGFiaXQsXG4gICAgICAgICAgICAgICAgaWQ6IGAke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICAgICAgICAgICAgY29tcGxldGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGFyY2hpdmVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRIYWJpdHMocHJldiA9PiBbLi4ucHJldiwgbmV3SGFiaXRdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBoYWJpdDonLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRFcnJvcignRmFpbGVkIHRvIGFkZCBoYWJpdC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgfVxuICAgIH0sIFtoYWJpdHNdKTtcbiAgICBjb25zdCB0b2dnbGVIYWJpdENvbXBsZXRpb24gPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGhhYml0SWQsIGRhdGUsIHF1YW50aXR5LCBub3RlcykgPT4ge1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgaWYgKCFoYWJpdElkIHx8ICFkYXRlKSB7XG4gICAgICAgICAgICBzZXRFcnJvcignSW52YWxpZCBoYWJpdCBvciBkYXRlLicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldEhhYml0cyhwcmV2ID0+IHByZXYubWFwKGhhYml0ID0+IHtcbiAgICAgICAgICAgIGlmIChoYWJpdC5pZCA9PT0gaGFiaXRJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ29tcGxldGlvbiA9IGhhYml0LmNvbXBsZXRpb25zLmZpbmQoYyA9PiBjLmRhdGUgPT09IGRhdGUpO1xuICAgICAgICAgICAgICAgIGxldCBuZXdDb21wbGV0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdDb21wbGV0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb21wbGV0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBuZXdDb21wbGV0aW9ucyA9IGhhYml0LmNvbXBsZXRpb25zLmZpbHRlcihjID0+IGMuZGF0ZSAhPT0gZGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGNvbXBsZXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LmNvbXBsZXRpb25zLmxlbmd0aCA+PSBoYWJpdF8xLk1BWF9DT01QTEVUSU9OU19QRVJfSEFCSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCdNYXhpbXVtIG51bWJlciBvZiBjb21wbGV0aW9ucyByZWFjaGVkIGZvciB0aGlzIGhhYml0LicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhYml0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhYml0LnRyYWNrUXVhbnRpdHkgJiYgdHlwZW9mIHF1YW50aXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGlvbi5xdWFudGl0eSA9IHF1YW50aXR5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3Rlcz8udHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9uLm5vdGVzID0gbm90ZXMudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbXBsZXRpb25zID0gWy4uLmhhYml0LmNvbXBsZXRpb25zLCBjb21wbGV0aW9uXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uaGFiaXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zOiBuZXdDb21wbGV0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYWJpdDtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBkZWxldGVIYWJpdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoaGFiaXRJZCkgPT4ge1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgaWYgKCFoYWJpdElkKSB7XG4gICAgICAgICAgICBzZXRFcnJvcignSW52YWxpZCBoYWJpdCBJRC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRIYWJpdHMocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYWJpdEV4aXN0cyA9IHByZXYuc29tZShoID0+IGguaWQgPT09IGhhYml0SWQpO1xuICAgICAgICAgICAgaWYgKCFoYWJpdEV4aXN0cykge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCdIYWJpdCBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJldi5maWx0ZXIoaGFiaXQgPT4gaGFiaXQuaWQgIT09IGhhYml0SWQpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgYXJjaGl2ZUhhYml0ID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChoYWJpdElkKSA9PiB7XG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgICBpZiAoIWhhYml0SWQpIHtcbiAgICAgICAgICAgIHNldEVycm9yKCdJbnZhbGlkIGhhYml0IElELicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldEhhYml0cyhwcmV2ID0+IHByZXYubWFwKGhhYml0ID0+IHtcbiAgICAgICAgICAgIGlmIChoYWJpdC5pZCA9PT0gaGFiaXRJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmhhYml0LFxuICAgICAgICAgICAgICAgICAgICBhcmNoaXZlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYWJpdDtcbiAgICAgICAgfSkpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBnZXRIYWJpdFN0YXRzID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChoYWJpdElkKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhYml0ID0gaGFiaXRzLmZpbmQoaCA9PiBoLmlkID09PSBoYWJpdElkKTtcbiAgICAgICAgaWYgKCFoYWJpdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBjb21wbGV0aW9ucyA9IGhhYml0LmNvbXBsZXRpb25zO1xuICAgICAgICBjb25zdCB0b3RhbENvbXBsZXRpb25zID0gY29tcGxldGlvbnMubGVuZ3RoO1xuICAgICAgICAvLyBDYWxjdWxhdGUgc3RyZWFrc1xuICAgICAgICBsZXQgY3VycmVudFN0cmVhayA9IDA7XG4gICAgICAgIGxldCBsb25nZXN0U3RyZWFrID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb3VudCA9IDA7XG4gICAgICAgIC8vIFNvcnQgY29tcGxldGlvbnMgYnkgZGF0ZVxuICAgICAgICBjb25zdCBzb3J0ZWREYXRlcyA9IGNvbXBsZXRpb25zXG4gICAgICAgICAgICAubWFwKGMgPT4gbmV3IERhdGUoYy5kYXRlKSlcbiAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBiLmdldFRpbWUoKSAtIGEuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKHNvcnRlZERhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRvZGF5LnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoc29ydGVkRGF0ZXNbMF0pO1xuICAgICAgICAgICAgY3VycmVudERhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgY3VycmVudCBzdHJlYWtcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50RGF0ZSA8PSB0b2RheSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0NvbXBsZXRpb24gPSBzb3J0ZWREYXRlcy5zb21lKGRhdGUgPT4gZGF0ZS5nZXRGdWxsWWVhcigpID09PSBjdXJyZW50RGF0ZS5nZXRGdWxsWWVhcigpICYmXG4gICAgICAgICAgICAgICAgICAgIGRhdGUuZ2V0TW9udGgoKSA9PT0gY3VycmVudERhdGUuZ2V0TW9udGgoKSAmJlxuICAgICAgICAgICAgICAgICAgICBkYXRlLmdldERhdGUoKSA9PT0gY3VycmVudERhdGUuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ29tcGxldGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5zZXREYXRlKGN1cnJlbnREYXRlLmdldERhdGUoKSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFN0cmVhayA9IGN1cnJlbnRDb3VudDtcbiAgICAgICAgICAgIGxvbmdlc3RTdHJlYWsgPSBjdXJyZW50Q291bnQ7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbG9uZ2VzdCBzdHJlYWtcbiAgICAgICAgICAgIGN1cnJlbnRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZERhdGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUxID0gc29ydGVkRGF0ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0ZTIgPSBzb3J0ZWREYXRlc1tpICsgMV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZkRheXMgPSBNYXRoLnJvdW5kKChkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlmZkRheXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgIGxvbmdlc3RTdHJlYWsgPSBNYXRoLm1heChsb25nZXN0U3RyZWFrLCBjdXJyZW50Q291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGNvbXBsZXRpb24gcmF0ZVxuICAgICAgICBjb25zdCBkYXlzU2luY2VDcmVhdGlvbiA9IE1hdGguY2VpbCgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShoYWJpdC5jcmVhdGVkQXQpLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwICogNjAgKiAyNCkpO1xuICAgICAgICBjb25zdCBjb21wbGV0aW9uUmF0ZSA9ICh0b3RhbENvbXBsZXRpb25zIC8gZGF5c1NpbmNlQ3JlYXRpb24pICogMTAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgcXVhbnRpdHkgc3RhdHMgaWYgYXBwbGljYWJsZVxuICAgICAgICBsZXQgYXZlcmFnZVF1YW50aXR5O1xuICAgICAgICBsZXQgdG90YWxRdWFudGl0eTtcbiAgICAgICAgaWYgKGhhYml0LnRyYWNrUXVhbnRpdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1YW50aXRpZXMgPSBjb21wbGV0aW9uc1xuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLnF1YW50aXR5KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHEpID0+IHR5cGVvZiBxID09PSAnbnVtYmVyJyk7XG4gICAgICAgICAgICBpZiAocXVhbnRpdGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG90YWxRdWFudGl0eSA9IHF1YW50aXRpZXMucmVkdWNlKChzdW0sIHEpID0+IHN1bSArIHEsIDApO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2VRdWFudGl0eSA9IHRvdGFsUXVhbnRpdHkgLyBxdWFudGl0aWVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG90YWxDb21wbGV0aW9ucyxcbiAgICAgICAgICAgIGN1cnJlbnRTdHJlYWssXG4gICAgICAgICAgICBsb25nZXN0U3RyZWFrLFxuICAgICAgICAgICAgY29tcGxldGlvblJhdGUsXG4gICAgICAgICAgICBhdmVyYWdlUXVhbnRpdHksXG4gICAgICAgICAgICB0b3RhbFF1YW50aXR5LFxuICAgICAgICAgICAgbGFzdENvbXBsZXRpb25EYXRlOiBjb21wbGV0aW9ucy5sZW5ndGggPiAwID8gY29tcGxldGlvbnNbY29tcGxldGlvbnMubGVuZ3RoIC0gMV0uZGF0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LCBbaGFiaXRzXSk7XG4gICAgY29uc3QgdmFsdWUgPSByZWFjdF8xLmRlZmF1bHQudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBoYWJpdHMsXG4gICAgICAgIGFkZEhhYml0LFxuICAgICAgICB0b2dnbGVIYWJpdENvbXBsZXRpb24sXG4gICAgICAgIGRlbGV0ZUhhYml0LFxuICAgICAgICBhcmNoaXZlSGFiaXQsXG4gICAgICAgIGdldEhhYml0U3RhdHMsXG4gICAgICAgIGVycm9yLFxuICAgIH0pLCBbaGFiaXRzLCBhZGRIYWJpdCwgdG9nZ2xlSGFiaXRDb21wbGV0aW9uLCBkZWxldGVIYWJpdCwgYXJjaGl2ZUhhYml0LCBnZXRIYWJpdFN0YXRzLCBlcnJvcl0pO1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShIYWJpdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmV4cG9ydHMuSGFiaXRQcm92aWRlciA9IEhhYml0UHJvdmlkZXI7XG5jb25zdCB1c2VIYWJpdHMgPSAoKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCByZWFjdF8xLnVzZUNvbnRleHQpKEhhYml0Q29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUhhYml0cyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgSGFiaXRQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn07XG5leHBvcnRzLnVzZUhhYml0cyA9IHVzZUhhYml0cztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///199684\n");

/***/ })

});