"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdateascent"]("main",{

/***/ 587222:
/*!***********************************************!*\
  !*** ./src/renderer/components/HabitCard.tsx ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst jsx_runtime_1 = __webpack_require__(/*! react/jsx-runtime */ 474848);\nconst react_1 = __importStar(__webpack_require__(/*! react */ 296540));\nconst material_1 = __webpack_require__(/*! @mui/material */ 495304);\nconst icons_material_1 = __webpack_require__(/*! @mui/icons-material */ 465113);\nconst date_fns_1 = __webpack_require__(/*! date-fns */ 917705);\nconst HabitCard = ({ habit, onToggleCompletion, onDelete }) => {\n    const [isLogDialogOpen, setIsLogDialogOpen] = (0, react_1.useState)(false);\n    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = (0, react_1.useState)(false);\n    const [selectedDate, setSelectedDate] = (0, react_1.useState)(new Date());\n    const [quantity, setQuantity] = (0, react_1.useState)('');\n    const [useCheckbox, setUseCheckbox] = (0, react_1.useState)(true);\n    // Full year days\n    const yearStart = (0, react_1.useMemo)(() => (0, date_fns_1.startOfYear)(new Date()), []);\n    const yearEnd = (0, react_1.useMemo)(() => (0, date_fns_1.endOfYear)(new Date()), []);\n    const yearDays = (0, react_1.useMemo)(() => (0, date_fns_1.eachDayOfInterval)({ start: yearStart, end: yearEnd }), [yearStart, yearEnd]);\n    // Group days by week (columns) and weekday (rows)\n    const weeks = (0, react_1.useMemo)(() => {\n        const weekMap = {};\n        yearDays.forEach(day => {\n            const week = (0, date_fns_1.getISOWeek)(day);\n            const weekday = (0, date_fns_1.getDay)(day);\n            if (!weekMap[week])\n                weekMap[week] = {};\n            weekMap[week][weekday] = day;\n        });\n        return weekMap;\n    }, [yearDays]);\n    // Build a GitHub-style heatmap grid for the year\n    const year = new Date().getFullYear();\n    const daysOfYear = (0, react_1.useMemo)(() => (0, date_fns_1.eachDayOfInterval)({ start: (0, date_fns_1.startOfYear)(new Date(year, 0, 1)), end: (0, date_fns_1.endOfYear)(new Date(year, 11, 31)) }), [year]);\n    const firstDayOfYear = (0, date_fns_1.startOfYear)(new Date(year, 0, 1));\n    const numWeeks = (0, date_fns_1.differenceInCalendarWeeks)((0, date_fns_1.endOfYear)(new Date(year, 11, 31)), firstDayOfYear, { weekStartsOn: 0 }) + 1;\n    const numRows = 7; // Sun-Sat\n    // Build grid: grid[col][row] = date or null\n    // Col = week, Row = weekday\n    const grid = Array.from({ length: numWeeks }, () => Array(numRows).fill(null));\n    daysOfYear.forEach(day => {\n        const week = (0, date_fns_1.differenceInCalendarWeeks)(day, firstDayOfYear, { weekStartsOn: 0 });\n        const weekday = (0, date_fns_1.getDay)(day); // 0=Sun, 6=Sat\n        grid[week][weekday] = day;\n    });\n    // For month labels: map colIdx to month if the first day in the column is in a new month\n    const monthLabels = [];\n    let lastMonth = -1;\n    grid.forEach((col, colIdx) => {\n        // Find first day in the column\n        const firstDayInCol = col.find(day => day !== null);\n        if (firstDayInCol) {\n            const m = (0, date_fns_1.getMonth)(firstDayInCol);\n            if (m !== lastMonth) {\n                monthLabels.push({ col: colIdx, month: (0, date_fns_1.format)(firstDayInCol, 'MMM') });\n                lastMonth = m;\n            }\n        }\n    });\n    const isHabitCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    const calculateStreak = (0, react_1.useCallback)(() => {\n        let streak = 0;\n        const today = new Date();\n        let currentDate = new Date();\n        while (isHabitCompleted(currentDate) && !(0, date_fns_1.isAfter)(currentDate, today)) {\n            streak++;\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        return streak;\n    }, [isHabitCompleted]);\n    const handleLogSubmit = (0, react_1.useCallback)(() => {\n        if (useCheckbox) {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n        }\n        else if (quantity !== '') {\n            onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'), Number(quantity));\n        }\n        setIsLogDialogOpen(false);\n        setQuantity('');\n        setUseCheckbox(true);\n    }, [useCheckbox, selectedDate, quantity, onToggleCompletion]);\n    const handleDayClick = (0, react_1.useCallback)((day) => {\n        if ((0, date_fns_1.isAfter)(day, new Date())) {\n            return; // Don't allow logging future dates\n        }\n        setSelectedDate(day);\n        setIsLogDialogOpen(true);\n    }, []);\n    const streak = (0, react_1.useMemo)(() => calculateStreak(), [calculateStreak]);\n    const isDayCompleted = (0, react_1.useCallback)((date) => {\n        return habit.completions.some(completion => completion.date === (0, date_fns_1.format)(date, 'yyyy-MM-dd'));\n    }, [habit.completions]);\n    return ((0, jsx_runtime_1.jsxs)(material_1.Paper, { elevation: 0, sx: {\n            p: 2,\n            mb: 2,\n            bgcolor: 'background.paper',\n            display: 'flex',\n            flexDirection: 'column',\n            height: '100%',\n            border: '1px solid',\n            borderColor: 'divider',\n        }, children: [(0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }, children: [(0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"h6\", noWrap: true, title: habit.name, children: habit.name }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'flex', alignItems: 'center', gap: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Tooltip, { title: `Current streak: ${streak} days`, children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"body2\", color: \"text.secondary\", children: [\"\\uD83D\\uDD25 \", streak] }) }), (0, jsx_runtime_1.jsx)(material_1.Button, { variant: \"outlined\", size: \"small\", startIcon: (0, jsx_runtime_1.jsx)(icons_material_1.Add, {}), onClick: () => {\n                                    setSelectedDate(new Date());\n                                    setIsLogDialogOpen(true);\n                                }, children: \"Log today\" }), (0, jsx_runtime_1.jsx)(material_1.IconButton, { size: \"small\", color: \"error\", onClick: () => setIsDeleteDialogOpen(true), children: (0, jsx_runtime_1.jsx)(icons_material_1.Delete, {}) })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { overflowX: 'auto', pb: 1 }, children: [(0, jsx_runtime_1.jsx)(material_1.Box, { sx: { display: 'flex', mb: 0.5, pl: '32px' }, children: grid.map((col, colIdx) => {\n                            const label = monthLabels.find(m => m.col === colIdx);\n                            return label ? ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: { width: 16, textAlign: 'center' }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: { fontSize: '0.65rem', color: 'text.secondary' }, children: label.month }) }, colIdx)) : (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { width: 16 } }, colIdx);\n                        }) }), (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { display: 'grid', gridTemplateColumns: `32px repeat(${grid.length}, 16px)`, gap: 0.3 }, children: [[0, 1, 2, 3, 4, 5, 6].map((weekday) => ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: 1, gridRow: weekday + 2, justifySelf: 'end', pr: 0.5 }, children: (0, jsx_runtime_1.jsx)(material_1.Typography, { variant: \"caption\", sx: { fontSize: '0.65rem', color: 'text.secondary' }, children: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][weekday] }) }, weekday))), grid.map((col, colIdx) => ([0, 1, 2, 3, 4, 5, 6].map((rowIdx) => {\n                                const day = col[rowIdx];\n                                if (!day)\n                                    return (0, jsx_runtime_1.jsx)(material_1.Box, { sx: { gridColumn: colIdx + 2, gridRow: rowIdx + 2, width: 16, height: 16, bgcolor: 'transparent' } }, `empty-${colIdx}-${rowIdx}`);\n                                const isCompleted = isDayCompleted(day);\n                                const isFuture = (0, date_fns_1.isAfter)(day, new Date());\n                                const isCurrentDay = (0, date_fns_1.isToday)(day);\n                                return ((0, jsx_runtime_1.jsx)(material_1.Box, { sx: {\n                                        gridColumn: colIdx + 2,\n                                        gridRow: rowIdx + 2,\n                                        width: 16,\n                                        height: 16,\n                                        m: 0.2,\n                                        bgcolor: isCompleted ? habit.color + '99' : 'transparent',\n                                        border: isCurrentDay ? `1px solid ${habit.color}` : '1px solid #e0e0e0',\n                                        borderRadius: '3px',\n                                        display: 'flex',\n                                        alignItems: 'center',\n                                        justifyContent: 'center',\n                                        position: 'relative',\n                                        cursor: isFuture ? 'not-allowed' : 'pointer',\n                                        opacity: isFuture ? 0.3 : 1,\n                                    }, onClick: () => !isFuture && handleDayClick(day) }, day.toString()));\n                            })))] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isLogDialogOpen, onClose: () => setIsLogDialogOpen(false), maxWidth: \"xs\", fullWidth: true, children: [(0, jsx_runtime_1.jsxs)(material_1.DialogTitle, { children: [\"Log \", habit.name] }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: (0, jsx_runtime_1.jsxs)(material_1.Box, { sx: { mt: 2 }, children: [(0, jsx_runtime_1.jsxs)(material_1.Typography, { variant: \"subtitle2\", gutterBottom: true, children: [\"Date: \", (0, date_fns_1.format)(selectedDate, 'MMMM d, yyyy')] }), (0, jsx_runtime_1.jsx)(material_1.FormControlLabel, { control: (0, jsx_runtime_1.jsx)(material_1.Checkbox, { checked: useCheckbox, onChange: (e) => setUseCheckbox(e.target.checked) }), label: \"Mark as completed\" }), !useCheckbox && ((0, jsx_runtime_1.jsx)(material_1.TextField, { fullWidth: true, type: \"number\", label: `Quantity${habit.unit ? ` (${habit.unit})` : ''}`, value: quantity, onChange: (e) => {\n                                        const val = e.target.value;\n                                        if (val === '' || (Number(val) >= 0 && Number(val) <= 1000000)) {\n                                            setQuantity(val === '' ? '' : Number(val));\n                                        }\n                                    }, sx: { mt: 2 }, inputProps: {\n                                        min: 0,\n                                        max: 1000000,\n                                    } }))] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsLogDialogOpen(false), children: \"Cancel\" }), isDayCompleted(selectedDate) && ((0, jsx_runtime_1.jsx)(material_1.Button, { color: \"warning\", onClick: () => {\n                                    onToggleCompletion((0, date_fns_1.format)(selectedDate, 'yyyy-MM-dd'));\n                                    setIsLogDialogOpen(false);\n                                }, children: \"Undo\" })), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: handleLogSubmit, variant: \"contained\", disabled: !useCheckbox && quantity === '', children: \"Save\" })] })] }), (0, jsx_runtime_1.jsxs)(material_1.Dialog, { open: isDeleteDialogOpen, onClose: () => setIsDeleteDialogOpen(false), maxWidth: \"xs\", fullWidth: true, children: [(0, jsx_runtime_1.jsx)(material_1.DialogTitle, { children: \"Delete Habit\" }), (0, jsx_runtime_1.jsx)(material_1.DialogContent, { children: (0, jsx_runtime_1.jsxs)(material_1.Typography, { children: [\"Are you sure you want to delete \\\"\", habit.name, \"\\\"? This action cannot be undone.\"] }) }), (0, jsx_runtime_1.jsxs)(material_1.DialogActions, { children: [(0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => setIsDeleteDialogOpen(false), children: \"Cancel\" }), (0, jsx_runtime_1.jsx)(material_1.Button, { onClick: () => {\n                                    onDelete();\n                                    setIsDeleteDialogOpen(false);\n                                }, color: \"error\", variant: \"contained\", children: \"Delete\" })] })] })] }));\n};\nexports[\"default\"] = HabitCard;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QixtRUFBbUUsbURBQW1ELGtCQUFrQixXQUFXLFFBQVE7QUFDcDdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVEsT0FBTztBQUNwRDtBQUNBO0FBQ0EsdUNBQXVDLEtBQUssR0FBRyx1REFBdUQsdURBQXVELDhEQUE4RCxnRkFBZ0Y7QUFDM1M7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0IsZ0RBQWdELDZHQUE2RyxJQUFJLElBQUksZ0RBQWdELG9LQUFvSywwQkFBMEIsc0RBQXNELDJEQUEyRCxtR0FBbUcsR0FBRyx1REFBdUQsdURBQXVELGlFQUFpRSwrQ0FBK0M7QUFDNzNCO0FBQ0E7QUFDQSxpQ0FBaUMsNERBQTRELElBQUksSUFBSSxJQUFJO0FBQ3pHO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hc2NlbnQvLi9zcmMvcmVuZGVyZXIvY29tcG9uZW50cy9IYWJpdENhcmQudHN4PzQzZTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGpzeF9ydW50aW1lXzEgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCByZWFjdF8xID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBtYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvbWF0ZXJpYWxcIik7XG5jb25zdCBpY29uc19tYXRlcmlhbF8xID0gcmVxdWlyZShcIkBtdWkvaWNvbnMtbWF0ZXJpYWxcIik7XG5jb25zdCBkYXRlX2Zuc18xID0gcmVxdWlyZShcImRhdGUtZm5zXCIpO1xuY29uc3QgSGFiaXRDYXJkID0gKHsgaGFiaXQsIG9uVG9nZ2xlQ29tcGxldGlvbiwgb25EZWxldGUgfSkgPT4ge1xuICAgIGNvbnN0IFtpc0xvZ0RpYWxvZ09wZW4sIHNldElzTG9nRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtpc0RlbGV0ZURpYWxvZ09wZW4sIHNldElzRGVsZXRlRGlhbG9nT3Blbl0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzZWxlY3RlZERhdGUsIHNldFNlbGVjdGVkRGF0ZV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobmV3IERhdGUoKSk7XG4gICAgY29uc3QgW3F1YW50aXR5LCBzZXRRdWFudGl0eV0gPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoJycpO1xuICAgIGNvbnN0IFt1c2VDaGVja2JveCwgc2V0VXNlQ2hlY2tib3hdID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKHRydWUpO1xuICAgIC8vIEZ1bGwgeWVhciBkYXlzXG4gICAgY29uc3QgeWVhclN0YXJ0ID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gKDAsIGRhdGVfZm5zXzEuc3RhcnRPZlllYXIpKG5ldyBEYXRlKCkpLCBbXSk7XG4gICAgY29uc3QgeWVhckVuZCA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+ICgwLCBkYXRlX2Zuc18xLmVuZE9mWWVhcikobmV3IERhdGUoKSksIFtdKTtcbiAgICBjb25zdCB5ZWFyRGF5cyA9ICgwLCByZWFjdF8xLnVzZU1lbW8pKCgpID0+ICgwLCBkYXRlX2Zuc18xLmVhY2hEYXlPZkludGVydmFsKSh7IHN0YXJ0OiB5ZWFyU3RhcnQsIGVuZDogeWVhckVuZCB9KSwgW3llYXJTdGFydCwgeWVhckVuZF0pO1xuICAgIC8vIEdyb3VwIGRheXMgYnkgd2VlayAoY29sdW1ucykgYW5kIHdlZWtkYXkgKHJvd3MpXG4gICAgY29uc3Qgd2Vla3MgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdlZWtNYXAgPSB7fTtcbiAgICAgICAgeWVhckRheXMuZm9yRWFjaChkYXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VlayA9ICgwLCBkYXRlX2Zuc18xLmdldElTT1dlZWspKGRheSk7XG4gICAgICAgICAgICBjb25zdCB3ZWVrZGF5ID0gKDAsIGRhdGVfZm5zXzEuZ2V0RGF5KShkYXkpO1xuICAgICAgICAgICAgaWYgKCF3ZWVrTWFwW3dlZWtdKVxuICAgICAgICAgICAgICAgIHdlZWtNYXBbd2Vla10gPSB7fTtcbiAgICAgICAgICAgIHdlZWtNYXBbd2Vla11bd2Vla2RheV0gPSBkYXk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2Vla01hcDtcbiAgICB9LCBbeWVhckRheXNdKTtcbiAgICAvLyBCdWlsZCBhIEdpdEh1Yi1zdHlsZSBoZWF0bWFwIGdyaWQgZm9yIHRoZSB5ZWFyXG4gICAgY29uc3QgeWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcbiAgICBjb25zdCBkYXlzT2ZZZWFyID0gKDAsIHJlYWN0XzEudXNlTWVtbykoKCkgPT4gKDAsIGRhdGVfZm5zXzEuZWFjaERheU9mSW50ZXJ2YWwpKHsgc3RhcnQ6ICgwLCBkYXRlX2Zuc18xLnN0YXJ0T2ZZZWFyKShuZXcgRGF0ZSh5ZWFyLCAwLCAxKSksIGVuZDogKDAsIGRhdGVfZm5zXzEuZW5kT2ZZZWFyKShuZXcgRGF0ZSh5ZWFyLCAxMSwgMzEpKSB9KSwgW3llYXJdKTtcbiAgICBjb25zdCBmaXJzdERheU9mWWVhciA9ICgwLCBkYXRlX2Zuc18xLnN0YXJ0T2ZZZWFyKShuZXcgRGF0ZSh5ZWFyLCAwLCAxKSk7XG4gICAgY29uc3QgbnVtV2Vla3MgPSAoMCwgZGF0ZV9mbnNfMS5kaWZmZXJlbmNlSW5DYWxlbmRhcldlZWtzKSgoMCwgZGF0ZV9mbnNfMS5lbmRPZlllYXIpKG5ldyBEYXRlKHllYXIsIDExLCAzMSkpLCBmaXJzdERheU9mWWVhciwgeyB3ZWVrU3RhcnRzT246IDAgfSkgKyAxO1xuICAgIGNvbnN0IG51bVJvd3MgPSA3OyAvLyBTdW4tU2F0XG4gICAgLy8gQnVpbGQgZ3JpZDogZ3JpZFtjb2xdW3Jvd10gPSBkYXRlIG9yIG51bGxcbiAgICAvLyBDb2wgPSB3ZWVrLCBSb3cgPSB3ZWVrZGF5XG4gICAgY29uc3QgZ3JpZCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IG51bVdlZWtzIH0sICgpID0+IEFycmF5KG51bVJvd3MpLmZpbGwobnVsbCkpO1xuICAgIGRheXNPZlllYXIuZm9yRWFjaChkYXkgPT4ge1xuICAgICAgICBjb25zdCB3ZWVrID0gKDAsIGRhdGVfZm5zXzEuZGlmZmVyZW5jZUluQ2FsZW5kYXJXZWVrcykoZGF5LCBmaXJzdERheU9mWWVhciwgeyB3ZWVrU3RhcnRzT246IDAgfSk7XG4gICAgICAgIGNvbnN0IHdlZWtkYXkgPSAoMCwgZGF0ZV9mbnNfMS5nZXREYXkpKGRheSk7IC8vIDA9U3VuLCA2PVNhdFxuICAgICAgICBncmlkW3dlZWtdW3dlZWtkYXldID0gZGF5O1xuICAgIH0pO1xuICAgIC8vIEZvciBtb250aCBsYWJlbHM6IG1hcCBjb2xJZHggdG8gbW9udGggaWYgdGhlIGZpcnN0IGRheSBpbiB0aGUgY29sdW1uIGlzIGluIGEgbmV3IG1vbnRoXG4gICAgY29uc3QgbW9udGhMYWJlbHMgPSBbXTtcbiAgICBsZXQgbGFzdE1vbnRoID0gLTE7XG4gICAgZ3JpZC5mb3JFYWNoKChjb2wsIGNvbElkeCkgPT4ge1xuICAgICAgICAvLyBGaW5kIGZpcnN0IGRheSBpbiB0aGUgY29sdW1uXG4gICAgICAgIGNvbnN0IGZpcnN0RGF5SW5Db2wgPSBjb2wuZmluZChkYXkgPT4gZGF5ICE9PSBudWxsKTtcbiAgICAgICAgaWYgKGZpcnN0RGF5SW5Db2wpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoMCwgZGF0ZV9mbnNfMS5nZXRNb250aCkoZmlyc3REYXlJbkNvbCk7XG4gICAgICAgICAgICBpZiAobSAhPT0gbGFzdE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgbW9udGhMYWJlbHMucHVzaCh7IGNvbDogY29sSWR4LCBtb250aDogKDAsIGRhdGVfZm5zXzEuZm9ybWF0KShmaXJzdERheUluQ29sLCAnTU1NJykgfSk7XG4gICAgICAgICAgICAgICAgbGFzdE1vbnRoID0gbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGlzSGFiaXRDb21wbGV0ZWQgPSAoMCwgcmVhY3RfMS51c2VDYWxsYmFjaykoKGRhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGhhYml0LmNvbXBsZXRpb25zLnNvbWUoY29tcGxldGlvbiA9PiBjb21wbGV0aW9uLmRhdGUgPT09ICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoZGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgfSwgW2hhYml0LmNvbXBsZXRpb25zXSk7XG4gICAgY29uc3QgY2FsY3VsYXRlU3RyZWFrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKCgpID0+IHtcbiAgICAgICAgbGV0IHN0cmVhayA9IDA7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgd2hpbGUgKGlzSGFiaXRDb21wbGV0ZWQoY3VycmVudERhdGUpICYmICEoMCwgZGF0ZV9mbnNfMS5pc0FmdGVyKShjdXJyZW50RGF0ZSwgdG9kYXkpKSB7XG4gICAgICAgICAgICBzdHJlYWsrKztcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLnNldERhdGUoY3VycmVudERhdGUuZ2V0RGF0ZSgpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmVhaztcbiAgICB9LCBbaXNIYWJpdENvbXBsZXRlZF0pO1xuICAgIGNvbnN0IGhhbmRsZUxvZ1N1Ym1pdCA9ICgwLCByZWFjdF8xLnVzZUNhbGxiYWNrKSgoKSA9PiB7XG4gICAgICAgIGlmICh1c2VDaGVja2JveCkge1xuICAgICAgICAgICAgb25Ub2dnbGVDb21wbGV0aW9uKCgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAneXl5eS1NTS1kZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChxdWFudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSwgTnVtYmVyKHF1YW50aXR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKGZhbHNlKTtcbiAgICAgICAgc2V0UXVhbnRpdHkoJycpO1xuICAgICAgICBzZXRVc2VDaGVja2JveCh0cnVlKTtcbiAgICB9LCBbdXNlQ2hlY2tib3gsIHNlbGVjdGVkRGF0ZSwgcXVhbnRpdHksIG9uVG9nZ2xlQ29tcGxldGlvbl0pO1xuICAgIGNvbnN0IGhhbmRsZURheUNsaWNrID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXkpID0+IHtcbiAgICAgICAgaWYgKCgwLCBkYXRlX2Zuc18xLmlzQWZ0ZXIpKGRheSwgbmV3IERhdGUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgYWxsb3cgbG9nZ2luZyBmdXR1cmUgZGF0ZXNcbiAgICAgICAgfVxuICAgICAgICBzZXRTZWxlY3RlZERhdGUoZGF5KTtcbiAgICAgICAgc2V0SXNMb2dEaWFsb2dPcGVuKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBzdHJlYWsgPSAoMCwgcmVhY3RfMS51c2VNZW1vKSgoKSA9PiBjYWxjdWxhdGVTdHJlYWsoKSwgW2NhbGN1bGF0ZVN0cmVha10pO1xuICAgIGNvbnN0IGlzRGF5Q29tcGxldGVkID0gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKChkYXRlKSA9PiB7XG4gICAgICAgIHJldHVybiBoYWJpdC5jb21wbGV0aW9ucy5zb21lKGNvbXBsZXRpb24gPT4gY29tcGxldGlvbi5kYXRlID09PSAoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKGRhdGUsICd5eXl5LU1NLWRkJykpO1xuICAgIH0sIFtoYWJpdC5jb21wbGV0aW9uc10pO1xuICAgIHJldHVybiAoKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5QYXBlciwgeyBlbGV2YXRpb246IDAsIHN4OiB7XG4gICAgICAgICAgICBwOiAyLFxuICAgICAgICAgICAgbWI6IDIsXG4gICAgICAgICAgICBiZ2NvbG9yOiAnYmFja2dyb3VuZC5wYXBlcicsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkJyxcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZGl2aWRlcicsXG4gICAgICAgIH0sIGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZGlzcGxheTogJ2ZsZXgnLCBqdXN0aWZ5Q29udGVudDogJ3NwYWNlLWJldHdlZW4nLCBhbGlnbkl0ZW1zOiAnY2VudGVyJywgbWI6IDIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImg2XCIsIG5vV3JhcDogdHJ1ZSwgdGl0bGU6IGhhYml0Lm5hbWUsIGNoaWxkcmVuOiBoYWJpdC5uYW1lIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBkaXNwbGF5OiAnZmxleCcsIGFsaWduSXRlbXM6ICdjZW50ZXInLCBnYXA6IDEgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVG9vbHRpcCwgeyB0aXRsZTogYEN1cnJlbnQgc3RyZWFrOiAke3N0cmVha30gZGF5c2AsIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJib2R5MlwiLCBjb2xvcjogXCJ0ZXh0LnNlY29uZGFyeVwiLCBjaGlsZHJlbjogW1wiXFx1RDgzRFxcdUREMjUgXCIsIHN0cmVha10gfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5CdXR0b24sIHsgdmFyaWFudDogXCJvdXRsaW5lZFwiLCBzaXplOiBcInNtYWxsXCIsIHN0YXJ0SWNvbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShpY29uc19tYXRlcmlhbF8xLkFkZCwge30pLCBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZERhdGUobmV3IERhdGUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBcIkxvZyB0b2RheVwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuSWNvbkJ1dHRvbiwgeyBzaXplOiBcInNtYWxsXCIsIGNvbG9yOiBcImVycm9yXCIsIG9uQ2xpY2s6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3Blbih0cnVlKSwgY2hpbGRyZW46ICgwLCBqc3hfcnVudGltZV8xLmpzeCkoaWNvbnNfbWF0ZXJpYWxfMS5EZWxldGUsIHt9KSB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBvdmVyZmxvd1g6ICdhdXRvJywgcGI6IDEgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdmbGV4JywgbWI6IDAuNSwgcGw6ICczMnB4JyB9LCBjaGlsZHJlbjogZ3JpZC5tYXAoKGNvbCwgY29sSWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBtb250aExhYmVscy5maW5kKG0gPT4gbS5jb2wgPT09IGNvbElkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsID8gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgd2lkdGg6IDE2LCB0ZXh0QWxpZ246ICdjZW50ZXInIH0sIGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuVHlwb2dyYXBoeSwgeyB2YXJpYW50OiBcImNhcHRpb25cIiwgc3g6IHsgZm9udFNpemU6ICcwLjY1cmVtJywgY29sb3I6ICd0ZXh0LnNlY29uZGFyeScgfSwgY2hpbGRyZW46IGxhYmVsLm1vbnRoIH0pIH0sIGNvbElkeCkpIDogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyB3aWR0aDogMTYgfSB9LCBjb2xJZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeHMpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7IGRpc3BsYXk6ICdncmlkJywgZ3JpZFRlbXBsYXRlQ29sdW1uczogYDMycHggcmVwZWF0KCR7Z3JpZC5sZW5ndGh9LCAxNnB4KWAsIGdhcDogMC4zIH0sIGNoaWxkcmVuOiBbWzAsIDEsIDIsIDMsIDQsIDUsIDZdLm1hcCgod2Vla2RheSkgPT4gKCgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgZ3JpZENvbHVtbjogMSwgZ3JpZFJvdzogd2Vla2RheSArIDIsIGp1c3RpZnlTZWxmOiAnZW5kJywgcHI6IDAuNSB9LCBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJjYXB0aW9uXCIsIHN4OiB7IGZvbnRTaXplOiAnMC42NXJlbScsIGNvbG9yOiAndGV4dC5zZWNvbmRhcnknIH0sIGNoaWxkcmVuOiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddW3dlZWtkYXldIH0pIH0sIHdlZWtkYXkpKSksIGdyaWQubWFwKChjb2wsIGNvbElkeCkgPT4gKFswLCAxLCAyLCAzLCA0LCA1LCA2XS5tYXAoKHJvd0lkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXkgPSBjb2xbcm93SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJveCwgeyBzeDogeyBncmlkQ29sdW1uOiBjb2xJZHggKyAyLCBncmlkUm93OiByb3dJZHggKyAyLCB3aWR0aDogMTYsIGhlaWdodDogMTYsIGJnY29sb3I6ICd0cmFuc3BhcmVudCcgfSB9LCBgZW1wdHktJHtjb2xJZHh9LSR7cm93SWR4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0NvbXBsZXRlZCA9IGlzRGF5Q29tcGxldGVkKGRheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRnV0dXJlID0gKDAsIGRhdGVfZm5zXzEuaXNBZnRlcikoZGF5LCBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RGF5ID0gKDAsIGRhdGVfZm5zXzEuaXNUb2RheSkoZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQm94LCB7IHN4OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZENvbHVtbjogY29sSWR4ICsgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmlkUm93OiByb3dJZHggKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG06IDAuMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZ2NvbG9yOiBpc0NvbXBsZXRlZCA/IGhhYml0LmNvbG9yICsgJzk5JyA6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiBpc0N1cnJlbnREYXkgPyBgMXB4IHNvbGlkICR7aGFiaXQuY29sb3J9YCA6ICcxcHggc29saWQgI2UwZTBlMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnM3B4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogaXNGdXR1cmUgPyAnbm90LWFsbG93ZWQnIDogJ3BvaW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IGlzRnV0dXJlID8gMC4zIDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG9uQ2xpY2s6ICgpID0+ICFpc0Z1dHVyZSAmJiBoYW5kbGVEYXlDbGljayhkYXkpIH0sIGRheS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpKV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0xvZ0RpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzTG9nRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ1RpdGxlLCB7IGNoaWxkcmVuOiBbXCJMb2cgXCIsIGhhYml0Lm5hbWVdIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nQ29udGVudCwgeyBjaGlsZHJlbjogKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5Cb3gsIHsgc3g6IHsgbXQ6IDIgfSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgdmFyaWFudDogXCJzdWJ0aXRsZTJcIiwgZ3V0dGVyQm90dG9tOiB0cnVlLCBjaGlsZHJlbjogW1wiRGF0ZTogXCIsICgwLCBkYXRlX2Zuc18xLmZvcm1hdCkoc2VsZWN0ZWREYXRlLCAnTU1NTSBkLCB5eXl5JyldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRm9ybUNvbnRyb2xMYWJlbCwgeyBjb250cm9sOiAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQ2hlY2tib3gsIHsgY2hlY2tlZDogdXNlQ2hlY2tib3gsIG9uQ2hhbmdlOiAoZSkgPT4gc2V0VXNlQ2hlY2tib3goZS50YXJnZXQuY2hlY2tlZCkgfSksIGxhYmVsOiBcIk1hcmsgYXMgY29tcGxldGVkXCIgfSksICF1c2VDaGVja2JveCAmJiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLlRleHRGaWVsZCwgeyBmdWxsV2lkdGg6IHRydWUsIHR5cGU6IFwibnVtYmVyXCIsIGxhYmVsOiBgUXVhbnRpdHkke2hhYml0LnVuaXQgPyBgICgke2hhYml0LnVuaXR9KWAgOiAnJ31gLCB2YWx1ZTogcXVhbnRpdHksIG9uQ2hhbmdlOiAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IChOdW1iZXIodmFsKSA+PSAwICYmIE51bWJlcih2YWwpIDw9IDEwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFF1YW50aXR5KHZhbCA9PT0gJycgPyAnJyA6IE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzeDogeyBtdDogMiB9LCBpbnB1dFByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heDogMTAwMDAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gfSkpXSB9KSB9KSwgKDAsIGpzeF9ydW50aW1lXzEuanN4cykobWF0ZXJpYWxfMS5EaWFsb2dBY3Rpb25zLCB7IGNoaWxkcmVuOiBbKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBvbkNsaWNrOiAoKSA9PiBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpLCBjaGlsZHJlbjogXCJDYW5jZWxcIiB9KSwgaXNEYXlDb21wbGV0ZWQoc2VsZWN0ZWREYXRlKSAmJiAoKDAsIGpzeF9ydW50aW1lXzEuanN4KShtYXRlcmlhbF8xLkJ1dHRvbiwgeyBjb2xvcjogXCJ3YXJuaW5nXCIsIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uVG9nZ2xlQ29tcGxldGlvbigoMCwgZGF0ZV9mbnNfMS5mb3JtYXQpKHNlbGVjdGVkRGF0ZSwgJ3l5eXktTU0tZGQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0xvZ0RpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjaGlsZHJlbjogXCJVbmRvXCIgfSkpLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUxvZ1N1Ym1pdCwgdmFyaWFudDogXCJjb250YWluZWRcIiwgZGlzYWJsZWQ6ICF1c2VDaGVja2JveCAmJiBxdWFudGl0eSA9PT0gJycsIGNoaWxkcmVuOiBcIlNhdmVcIiB9KV0gfSldIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZywgeyBvcGVuOiBpc0RlbGV0ZURpYWxvZ09wZW4sIG9uQ2xvc2U6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSksIG1heFdpZHRoOiBcInhzXCIsIGZ1bGxXaWR0aDogdHJ1ZSwgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuRGlhbG9nVGl0bGUsIHsgY2hpbGRyZW46IFwiRGVsZXRlIEhhYml0XCIgfSksICgwLCBqc3hfcnVudGltZV8xLmpzeCkobWF0ZXJpYWxfMS5EaWFsb2dDb250ZW50LCB7IGNoaWxkcmVuOiAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLlR5cG9ncmFwaHksIHsgY2hpbGRyZW46IFtcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgXFxcIlwiLCBoYWJpdC5uYW1lLCBcIlxcXCI/IFRoaXMgYWN0aW9uIGNhbm5vdCBiZSB1bmRvbmUuXCJdIH0pIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3hzKShtYXRlcmlhbF8xLkRpYWxvZ0FjdGlvbnMsIHsgY2hpbGRyZW46IFsoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHNldElzRGVsZXRlRGlhbG9nT3BlbihmYWxzZSksIGNoaWxkcmVuOiBcIkNhbmNlbFwiIH0pLCAoMCwganN4X3J1bnRpbWVfMS5qc3gpKG1hdGVyaWFsXzEuQnV0dG9uLCB7IG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRJc0RlbGV0ZURpYWxvZ09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBjb2xvcjogXCJlcnJvclwiLCB2YXJpYW50OiBcImNvbnRhaW5lZFwiLCBjaGlsZHJlbjogXCJEZWxldGVcIiB9KV0gfSldIH0pXSB9KSk7XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gSGFiaXRDYXJkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///587222\n");

/***/ })

});